<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="开发进阶知识," />










<meta name="description" content="结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式-结构型模式">
<meta property="og:url" content="http://example.com/posts/18127.html">
<meta property="og:site_name" content="主页">
<meta property="og:description" content="结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/posts/18127/image-20240313182958332.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240313183849810.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240313184112960.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240313184304644.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240313184632609.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240325180839879.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240325181312494.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240325182144916.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240325182421310.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240326184154308.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240326184505398.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240326184516104.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240326184753654.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327185356259.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327185429537.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327185717738.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327190304920.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327190814916.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327190938690.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240327191428466.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240401183018070.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240401183412101.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240408185701020.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240408185844014.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240408190141222.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240408190633588.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240408190958009.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240409184246134.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240409184550672.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240409184932147.png">
<meta property="og:image" content="http://example.com/posts/18127/image-20240409185609538.png">
<meta property="article:published_time" content="2024-03-13T10:11:38.000Z">
<meta property="article:modified_time" content="2024-04-10T12:04:09.088Z">
<meta property="article:author" content="Xu Zhipeng">
<meta property="article:tag" content="开发进阶知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/posts/18127/image-20240313182958332.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/posts/18127.html"/>





  <title>设计模式-结构型模式 | 主页</title>
  








<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="主页" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">xzp个人小站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/18127.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式-结构型模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-03-13T18:11:38+08:00">
                2024-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  62
                </span>
              
            </div>
          

          
              <div class="post-description">
                  结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式包括以下几种具体模式：</p>
<ol>
<li>适配器（<code>Adapter</code>）：让接口不兼容的对象能够相互合作</li>
<li>桥接（<code>Bridge</code>）：可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用</li>
<li>组合（<code>Composite</code>）：使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们（比如遍历）</li>
<li>装饰（<code>Decorator</code>）：允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为</li>
<li>外观（<code>Facade</code>）：能为程序库、框架或其他复杂类提供一个简单的接口</li>
<li>享元（<code>Flyweight</code>）：摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象</li>
<li>代理（<code>Proxy</code>）：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理</li>
</ol>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><blockquote>
<p>封装器模式、Wrapper、Adapter</p>
</blockquote>
<p>适配器是一种结构型设计模式，它能使接口不兼容的对象能够相互合作</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你正在开发一款股票市场监测程序，它会从不同来源下载XML格式的股票数据，然后向用户呈现出美观的图表。</p>
<p>在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容JSON格式的数据。</p>
<p><img src="/posts/18127/image-20240313182958332.png" alt="image-20240313182958332"></p>
<p>你可以修改程序库来支持 XML。但是，这可能需要修改部分依赖该程序库的现有代码。甚至还有更糟糕的情况，你可能根本没有程序库的源代码，从而无法对其进行修改。  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>创建一个适配器，适配器是一个特殊的对象，能够转换对象接口，使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。被封装的对象甚至察觉不到适配器的存在。例如，你可以使用一个将所有数据转换为英制单位（如英尺和英里）的适配器封装运行于米和千米单位制中的对象  </p>
<p>适配器不仅可以转换不同格式的数据，还有助于采用不同接口的对象之间的合作。它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口</li>
<li>现有对象可以使用该接口安全地调用适配器方法</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象</li>
</ol>
<p>有时你甚至可以创建一个双向适配器来实现双向转换调用  </p>
<p><img src="/posts/18127/image-20240313183849810.png" alt="image-20240313183849810"></p>
<p>为了解决数据格式不兼容的问题，你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器，然后让客户端仅通过这些适配器来与函数库进行交流。当某个适配器被调用时，它会将传入的 XML 数据转换为 JSON 结构，并将其传递给被封装分析对象的相应方法。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>对象适配器</strong></p>
<p>实现时使用了构成原则：适配器实现了其中一个对象的接口，并对另一个对象进行封装。</p>
<p><img src="/posts/18127/image-20240313184112960.png" alt="image-20240313184112960"></p>
<ol>
<li>客户端（<code>Client</code>）是包含当前程序业务逻辑的类。</li>
<li>客户端接口（<code>Client Interface</code>）描述了其他类与客户端代码合作时必须遵循的协议。</li>
<li>服务（<code>Service</code>）中有一些功能类（通常来自第三方或遗留系统)。客户端与其接口不兼容，因此无法直接调用其功能</li>
<li><strong>适配器</strong>（<code>Adapter</code>）是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用</li>
<li>客户端代码只需通过接口与适配器交互即可，无需与具体的适配器类耦合。因此，你可以向程序中添加新类型的适配器而无需修改已有代码。这在服务类的接口被更改或替换时很有用：你无需修改客户端代码就可以创建新的适配器类  </li>
</ol>
<p><strong>类适配器</strong></p>
<p>这一实现使用了继承机制：适配器同时继承两个对象的接口。请注意， 这种方式仅能在支持多重继承的编程语言中实现，例如 C++  </p>
<p><img src="/posts/18127/image-20240313184304644.png" alt="image-20240313184304644"></p>
<ol>
<li>类适配器不需要封装任何对象，因为它同时继承了客户端和<br> 服务的行为。适配功能在重写的方法中完成。最后生成的适<br> 配器可替代已有的客户端类进行使用</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>方钉与圆孔</p>
<p><img src="/posts/18127/image-20240313184632609.png" alt="image-20240313184632609"></p>
<p>适配器假扮成一个圆钉（RoundPeg），其半径等于方钉（SquarePeg）横截面对角线的一半（即能够容纳方钉的最小外接圆的半径）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你有两个接口相互兼容的类：圆孔（RoundHole）和圆钉（RoundPeg）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundHole</span> is</span><br><span class="line">	constructor <span class="title function_">RoundHole</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> 	method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line"> 	<span class="comment">// 返回孔的半径。</span></span><br><span class="line"></span><br><span class="line"> 	method <span class="title function_">fits</span><span class="params">(peg: RoundPeg)</span> is</span><br><span class="line"> 		<span class="keyword">return</span> <span class="built_in">this</span>.getRadius() &gt;= peg.getRadius()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">  constructor <span class="title function_">RoundPeg</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line"> <span class="comment">// 返回钉子的半径。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 但还有一个不兼容的类：方钉（SquarePeg）。</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SquarePeg</span> is</span><br><span class="line"> 	constructor <span class="title function_">SquarePeg</span><span class="params">(width)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> 	method <span class="title function_">getWidth</span><span class="params">()</span> is</span><br><span class="line"> 	<span class="comment">// 返回方钉的宽度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适配器对象作为圆钉。</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SquarePegAdapter</span> <span class="keyword">extends</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">   <span class="comment">// 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。</span></span><br><span class="line">   <span class="keyword">private</span> field peg: SquarePeg</span><br><span class="line">   constructor <span class="title function_">SquarePegAdapter</span><span class="params">(peg: SquarePeg)</span> is</span><br><span class="line">   	<span class="built_in">this</span>.peg = peg</span><br><span class="line"></span><br><span class="line"> method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">   <span class="comment">// 适配器会假扮为一个圆钉，</span></span><br><span class="line">   <span class="comment">// 其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="line">   <span class="keyword">return</span> peg.getWidth() * Math.sqrt(<span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 客户端代码中的某个位置。</span></span><br><span class="line">  hole = <span class="keyword">new</span> <span class="title class_">RoundHole</span>(<span class="number">5</span>)</span><br><span class="line">  rpeg = <span class="keyword">new</span> <span class="title class_">RoundPeg</span>(<span class="number">5</span>)</span><br><span class="line">  hole.fits(rpeg) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	small_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">5</span>)</span><br><span class="line">  large_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">10</span>)</span><br><span class="line">  hole.fits(small_sqpeg) <span class="comment">// 此处无法编译（类型不一致）。</span></span><br><span class="line"></span><br><span class="line">  small_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(small_sqpeg)</span><br><span class="line">  large_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(large_sqpeg)</span><br><span class="line">  hole.fits(small_sqpeg_adapter) <span class="comment">// true</span></span><br><span class="line">  hole.fits(large_sqpeg_adapter) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类</p>
<p>  适配器模式允许你创建一个中间层类，其可作为代码与遗留类、第三方类或提供怪异接口的类之间的转换器  </p>
</li>
<li><p>如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性</p>
<p>  你可以扩展每个子类，将缺少的功能添加到新的子类中。但是，你必须在所有新子类中重复添加这些代码，这样会使得代码有坏味道</p>
<p>  将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。然后你可以将缺少功能的对象封装在适配器中，从而动态地获取所需功能。如要这一点正常运作，目标类必须要有通用接口，适配器的成员变量应当遵循该通用接口。这种方式同装饰模式非常相似  </p>
</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保至少有两个类的接口不兼容：<ol>
<li>一个无法修改（通常是第三方、遗留系统或者存在众多已<br> 有依赖的类）的功能性服务类</li>
<li>一个或多个将受益于使用服务类的客户端类</li>
</ol>
</li>
<li>声明客户端接口，描述客户端如何与服务交互</li>
<li>创建遵循客户端接口的适配器类。所有方法暂时都为空</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化，但有时在调用其方法时将该变量传递给适配器会更方便</li>
<li>依次实现适配器类客户端接口的所有方法。适配器会将实际工作委派给服务对象，自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。这样一来，你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>单一职责原则 你可以将接口或数据转换代码从程序主要业务逻辑中分离</li>
<li>开闭原则 只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器</li>
</ul>
<hr>
<ul>
<li>代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单</li>
</ul>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 桥接">桥接</a>通常会于开发前期进行设计，使你能够将程序的各个部分独立开来以便开发。另一方面，<a href="# 适配器">适配器</a>通常在已有程序中使用，让相互不兼容的类能很好地合作</li>
<li>适配器可以对已有对象的接口进行修改，<a href="# 装饰">装饰</a>则能在不改变对象接口的前提下强化对象功能。此外，装饰还支持递归组合，适配器则无法实现</li>
<li>适配器能为被封装对象提供不同的接口，<a href="# 代理">代理</a>能为对象提供相同的接口，装饰则能为对象提供加强的接口</li>
<li><a href="# 外观">外观</a>为现有对象定义了一个新接口，适配器则会试图运用已有的接口。适配器通常只封装一个对象，外观通常会作用于整个对象子系统上</li>
<li>桥接、<a href="# 状态">状态</a>和<a href="# 策略">策略</a>（在某种程度上包括适配器）模式的接口非常相似。实际上，它们都基于组合模式——即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题</li>
</ul>
<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><blockquote>
<p>Bridge</p>
</blockquote>
<p>桥接是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p>
<h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如有一个几何形状<code>Shape</code>类，从它能扩展出两个子类：圆形<code>Circle</code>和方形<code>Square</code>。你希望对这样的类层次结构进行扩展以使其包含颜色，所以你打算创建名为红色<code>Red</code>和蓝色<code>Blue</code>的形状子类。但是，由于你已有两个子类，所以总共需要创建四个类才能覆盖所有组合，例如蓝色圆形<code>BlueCircle</code>和红色方形<code>RedSquare</code>。</p>
<p><img src="/posts/18127/image-20240325180839879.png" alt="image-20240325180839879"></p>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。例如添加三角形状，你需要新增两个子类，也就是每种颜色一个；此后新增一种新颜色需要新增三个子类，即每种形状一个。如此以往，情况会越来越糟糕。  </p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题的根本原因是我们试图在两个独立的维度（形状与颜色）上扩展形状类。这在处理类继承时是很常见的问题。</p>
<p>桥接模式通过将继承改为组合的方式来解决这个问题。具体来说，就是抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象，从而使得一个类不必拥有所有的状态和行为。</p>
<p><img src="/posts/18127/image-20240325181312494.png" alt="image-20240325181312494"></p>
<p>根据该方法，我们可以将颜色相关的代码抽取到拥有红色和蓝色两个子类的颜色类中，然后在形状类中添加一个指向某一颜色对象的引用成员变量。现在，形状类可以将所有与颜色相关的工作委派给连入的颜色对象。这样的引用就成为了形状和颜色之间的桥梁。此后，新增颜色将不再需要修改形状的类层次，反之亦然。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240325182144916.png" alt="image-20240325182144916"></p>
<ol>
<li><p><strong>抽象部分</strong>（Abstraction）提供高层控制逻辑，依赖于完成底层实际工作的实现对象</p>
</li>
<li><p><strong>实现部分</strong>（Implementation）为所有具体实现声明通用接口。抽象部分仅能通过在这里声明的方法与实现对象交互</p>
<p> 抽象部分可以列出和实现部分一样的方法，但是抽象部分通常声明一些复杂行为，这些行为依赖于多种由实现部分声明的原语操作  </p>
</li>
<li><p><strong>具体实现</strong>（Concrete Implementations）中包括特定于平台的<br> 代码</p>
</li>
<li><p><strong>精确抽象</strong>（Refined Abstraction）提供控制逻辑的变体。与其<br> 父类一样，它们通过通用实现接口与不同的实现进行交互</p>
</li>
<li><p><strong>客户端</strong>（Client）一般仅关心如何与抽象部分合作。但是，客户端需要将抽象对象与一个实现对象连接起来</p>
</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>示例演示了桥接模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。 设备<code>Device</code>类作为实现部分， 而遥控器<code>Remote</code>类则作为抽象部分</p>
<p><img src="/posts/18127/image-20240325182421310.png" alt="image-20240325182421310"></p>
<p>最初类层次结构被拆分为两个部分：设备和遥控器  </p>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。所有遥控器通过通用设备接口与设备进行交互，使得同一个遥控器可以支持不同类型的设备  </p>
<p>你可以开发独立于设备类的遥控器类，只需新建一个遥控器子类即可。例如，基础遥控器可能只有两个按钮，但你可在其基础上扩展新功能，比如额外的一节电池或一块触摸屏</p>
<p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">	<span class="keyword">protected</span> field device: Device</span><br><span class="line">	constructor <span class="title function_">RemoteControl</span><span class="params">(device: Device)</span> is</span><br><span class="line">		<span class="built_in">this</span>.device = device</span><br><span class="line">	method <span class="title function_">togglePower</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(device.isEnabled()</span>) then</span><br><span class="line">			device.disable()</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			device.enable()</span><br><span class="line">			</span><br><span class="line">	method <span class="title function_">volumeDown</span><span class="params">()</span> is</span><br><span class="line">		device.setVolume(device.getVolume() - <span class="number">10</span>)</span><br><span class="line">		</span><br><span class="line">	method <span class="title function_">volumeUp</span><span class="params">()</span> is</span><br><span class="line">		device.setVolume(device.getVolume() + <span class="number">10</span>)</span><br><span class="line">		</span><br><span class="line">	method <span class="title function_">channelDown</span><span class="params">()</span> is</span><br><span class="line">		device.setChannel(device.getChannel() - <span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">	method <span class="title function_">channelUp</span><span class="params">()</span> is</span><br><span class="line">		device.setChannel(device.getChannel() + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedRemoteControl</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">  method <span class="title function_">mute</span><span class="params">()</span> is</span><br><span class="line">    device.setVolume(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而抽象接口则会基于这些操作定义较高层次的操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Device</span> is</span><br><span class="line">	method <span class="title function_">isEnabled</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">enable</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">disable</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">getVolume</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">setVolume</span><span class="params">(percent)</span></span><br><span class="line">	method <span class="title function_">getchannel</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">setchannel</span><span class="params">(channel)</span><span class="comment">//所有设备都遵循相同的接口。</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Radio</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码中的某个位置。</span></span><br><span class="line"></span><br><span class="line">tv = <span class="keyword">new</span> <span class="title class_">Tv</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> <span class="title class_">Radio</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">AdvancedRemoteControl</span>(radio)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式</p>
<p>  类的代码行数越多，弄清其运作方式就越困难，对其进行修改所花费的时间就越长。一个功能上的变化可能需要在整个类范围内进行修改，而且常常会产生错误，甚至还会有一些严重的副作用、</p>
<p>  桥接模式可以将庞杂类拆分为几个类层次结构。此后，你可以修改任意一个类层次结构而不会影响到其他类层次结构。这种方法可以简化代码的维护工作，并将修改已有代码的风险降到最低</p>
</li>
<li><p>如果你希望在几个独立维度上扩展一个类，可使用该模式</p>
<p>  桥接建议将每个维度抽取为独立的类层次。初始类将相关工作委派给属于对应类层次的对象，无需自己完成所有工作</p>
</li>
<li><p>如果你需要在运行时切换不同实现方法，可使用桥接模式</p>
<p>  当然并不是说一定要实现这一点，桥接模式可替换抽象部分中的实现对象，具体操作就和给成员变量赋新值一样简单</p>
<p>  顺便提一句，最后一点是很多人混淆桥接模式和策略模式的主要原因。记住，设计模式并不仅是一种对类进行组织的方式，它还能用于沟通意图和解决问题  </p>
</li>
</ul>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>明确类中独立的维度。独立的概念可能是：抽象/平台，域/基础设施，前端/后端或接口/实现。</li>
<li>了解客户端的业务需求，并在抽象基类中定义它们。</li>
<li>确定在所有平台上都可执行的业务，并在通用实现接口中声明抽象部分所需的业务。</li>
<li>为你域内的所有平台创建实现类，但需确保它们遵循实现部分的接口。</li>
<li>在抽象类中添加指向实现类型的引I用成员变量。抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</li>
<li>如果你的高层逻辑有多个变体，则可通过扩展抽象基类为每个变体创建一个精确抽象。</li>
<li>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。此后，客户端只需与抽象对象进行交互，无需和实现对象打交道。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。</li>
<li>开闭原则。你可以新增抽象部分和实现部分，且它们之间不会相互影响。</li>
<li>单一职责原则。抽象部分专注于处理高层逻辑，实现部分处理平台细节。</li>
</ul>
<hr>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 桥接">桥接</a>通常会于开发前期进行设计，使你能够将程序的各个部分独立开来以便开发。另一方面，<a href="# 适配器">适配器</a>通常在已有程序中使用，让相互不兼容的类能很好地合作。</li>
<li>桥接、<a href="# 状态">状态</a>和<a href="# 策略">策略</a>（在某种程度上包括适配器）模式的接口非常相似。实际上，它们都基于<a href="# 组合">组合</a>模式—即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>你可以将<a href="# 抽象工厂">抽象工厂</a>和桥接搭配使用。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。</li>
<li>你可以结合使用<a href="# 生成器">生成器</a>和桥接模式：主管类负责抽象工作，各种不同的生成器负责实现工作。</li>
</ul>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote>
<p>对象树、Object Tree、Composite</p>
</blockquote>
<p>组合是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们</p>
<h3 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h3><p>例如，你有两类对象：产品和盒子。一个盒子中可以包含多个产品或者几个较小的盒子。这些小盒子中同样可以包含一些产品或更小的盒子，以此类推。<br>假设你希望在这些类的基础上开发一个定购系统。订单中可以包含无包装的简单产品，也可以包含装满产品的盒子以及其他盒子。此时你会如何计算每张订单的总价格呢？</p>
<p><img src="/posts/18127/image-20240326184154308.png" alt="image-20240326184154308"></p>
<p>现实世界可以打开所有盒子，找到每件产品，然后计算总价，但在程序中并不能简单地使用循环语句来完成该工作。因为必须事先知道所有产品和盒子的类别，所有盒子的嵌套层数以及其他繁杂的细节信息。因此，直接计算极不方便，甚至完全不可行。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>组合模式建议使用一个通用接口来与产品和盒子进行交互，并且在该接口中声明一个计算总价的方法：</p>
<ul>
<li>对于一个产品，该方法直接返回其价格</li>
<li>对于一个盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。</li>
</ul>
<p>如果其中某个项目是小一号的盒子，那么当前盒子也会遍历其中的所有项目，以此类推，直到计算出所有内部组成部分的价格。</p>
<p><img src="/posts/18127/image-20240326184505398.png" alt="image-20240326184505398"></p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240326184516104.png" alt="image-20240326184516104"></p>
<ol>
<li><strong>组件</strong>（Component）接口描述了树中简单项目和复杂项目所共有的操作</li>
<li><strong>叶节点</strong>（Leaf）是树的基本结构，它不包含子项目</li>
<li><strong>容器</strong>（Container）—又名”组合（Composite）”—是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用的组件接口与其子项目交互。</li>
<li><strong>客户端</strong>（Client）通过组件接口与所有项目交互。因此，客<br>户端能以相同方式与树状结构中的简单或复杂项目交互</li>
</ol>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>借助组合模式帮助你在图形编辑器中实现一系列的几何图形。组合图形 <code>CompoundGraphic</code> 是一个容器，它可以由多个包括容器在内的子图形构成。组合图形与简单图形拥有相同的方法。但是，组合图形自身并不完成具体工作，而是将请求递归地传递给自己的子项目，然后“汇总”结果。<br>通过所有图形类所共有的接口，客户端代码可以与所有图形互动。因此，客户端不知道与其交互的是简单图形还是组合图形。客户端可以与非常复杂的对象结构进行交互，而无需与组成该结构的实体类紧密耦合。</p>
<p><img src="/posts/18127/image-20240326184753654.png" alt="image-20240326184753654" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口会声明组合中简单和复杂对象的通用操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Graphic</span> is</span><br><span class="line">  </span><br><span class="line">	method <span class="title function_">move</span><span class="params">(x， y)</span></span><br><span class="line">  </span><br><span class="line">	method <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象E通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。class Dot implements Graphic is</span></span><br><span class="line">	field x, y</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Dot</span><span class="params">(x, y）&#123;...&#125;</span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	method move(x, y)</span> is</span><br><span class="line">		<span class="built_in">this</span>.x += x</span><br><span class="line">		<span class="built_in">this</span>.y += y</span><br><span class="line">	method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">		<span class="comment">//在坐标位置(X,Y)处绘制一个点。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//所有组件类都可以扩展其他组件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Dot</span> is</span><br><span class="line">  field radius</span><br><span class="line"></span><br><span class="line">  constructor <span class="title function_">Circle</span><span class="params">(x, y, radius)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">//在坐标位置（X，Y）处绘制一个半径为R的圆。</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项目，然后”汇总”结果。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompoundGraphic</span> <span class="keyword">implements</span> <span class="title class_">Graphic</span> is</span><br><span class="line">	field children: array of Graphic</span><br><span class="line">  <span class="comment">//组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span></span><br><span class="line">  method <span class="title function_">add</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">  	<span class="comment">//在子项目数组中添加一个子项目。</span></span><br><span class="line">  method <span class="title function_">remove</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">    <span class="comment">//从子项目数组中移除一个子项目。</span></span><br><span class="line">  method <span class="title function_">move</span><span class="params">(x, y)</span> is</span><br><span class="line">    <span class="title function_">foreach</span> <span class="params">(child in children)</span> <span class="keyword">do</span> </span><br><span class="line">  		child.move(x, y)</span><br><span class="line"><span class="comment">//组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，最后组合将会完成整个对象树的遍历工作。</span></span><br><span class="line">  method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">//1. 对于每个子部件：</span></span><br><span class="line">    <span class="comment">//  1.1 绘制该部件。</span></span><br><span class="line">    <span class="comment">//  2.2 更新边框坐标。</span></span><br><span class="line">    <span class="comment">//2. 根据边框坐标绘制一个虚线长方形</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同时支持简单叶节点组件和复杂组件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageEditor</span> is</span><br><span class="line">  field all: CompoundGraphic</span><br><span class="line">  method <span class="title function_">load</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">    <span class="variable">all</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">    all.add（<span class="keyword">new</span> <span class="title class_">Dot</span>（<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">		all.add（<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>,<span class="number">3</span>, <span class="number">10</span>）)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将所需组件组合为复杂的组合组件。</span></span><br><span class="line">	method <span class="title function_">groupSelected</span><span class="params">(components: array of Graphic)</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">  	foreach (component in components) <span class="keyword">do</span></span><br><span class="line">				group.add(component)</span><br><span class="line">  			all.remove(component)</span><br><span class="line">    all.add(group)</span><br><span class="line">  	<span class="comment">//所有组件都将被绘制</span></span><br><span class="line">		all.draw()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你需要实现树状对象结构，可以使用组合模式\</p>
<p>组合模式为你提供了两种共享公共接口的基本元素类型：简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。这使得你可以构建树状嵌套递归对象结构</p>
</li>
<li><p>如果你希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式</p>
<p>组合模式中定义的所有元素共用同一个接口。在这一接口的帮助下，客户端不必在意其所使用的对象的具体类</p>
</li>
</ul>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>确保应用的核心模型能够以树状结构表示。尝试将其分解为简单元素和容器。记住，容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li><p>声明组件接口及其一系列方法，这些方法对简单和复杂元素都有意义。</p>
</li>
<li><p>创建一个叶节点类表示简单元素。程序中可以有多个不同的叶节点类。</p>
</li>
<li><p>创建一个容器类表示复杂元素。在该类中，创建一个数组成员变量来存储对于其子元素的引用。该数组必须能够同时保存叶节点和容器，因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时，记住容器应该将大部分工作交给其子元素来完成。</p>
</li>
<li><p>最后，在容器中定义添加和删除子元素的方法。</p>
<p>记住，这些操作可在组件接口中声明。这将会违反_接口隔离原则_，因为叶节点类中的这些方法为空。但是，这可以让客户端无差别地访问所有元素，即使是组成树状结构的元素。  </p>
</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以利用多态和递归机制更方便地使用复杂树结构</li>
<li>开闭原则。无需更改现有代码，你就可以在应用中添加新元素，使其成为对象树的一部分</li>
</ul>
<hr>
<ul>
<li>对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解</li>
</ul>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p><a href="# 桥接">桥接</a>、<a href="# 状态">状态</a>和<a href="# 策略">策略</a>（在某种程度上包括<a href="# 适配器">适配器</a>）模式的接口非常相似。实际上，它们都基于<a href="# 组合">组合</a>模式一即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>你可以在创建复杂组合树时使用<a href="# 生成器">生成器</a>，因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li><p><a href="# 责任链">责任链</a>通常和组合模式结合使用。在这种情况下，叶组件接收到请求后，可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li><p>你可以使用<a href="# 迭代器">选代器</a>来遍历组合树。</p>
</li>
<li><p>你可以使用<a href="# 访问者">访问者</a>对整个组合树执行操作。</p>
</li>
<li><p>你可以使用<a href="# 享元">享元</a>实现组合树的共享叶节点以节省内存。</p>
</li>
<li><p>组合和<a href="# 装饰">装饰</a>的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合，但其只有一个子组件。此外还有一个明显不同：装饰为被封装对象添加了额外的职责，组合仅对其子节点的结果进行了“求和”。</p>
<p>但是，模式也可以相互合作：你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于原型的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。</p>
</li>
</ul>
<h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><blockquote>
<p>装饰器模式、Wrapper、Decorator</p>
</blockquote>
<p>装饰是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<h3 id="问题背景-3"><a href="#问题背景-3" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你正在开发一个提供通知功能的库，其他程序可使用它向用户发送关于重要事件的通知。</p>
<p>库的最初版本基于通知器<code>Notifier</code>类，其中只有很少的几个成员变量，一个构造函数和一个<code>send</code>发送方法。该方法可以接收来自客户端的消息参数，并将该消息发送给一系列的邮箱，邮箱列表则是通过构造函数传递给通知器的。作为客户端的第三方程序仅会创建和配置通知器对象一次，然后在有重要事件发生时对其进行调用。</p>
<p><img src="/posts/18127/image-20240327185356259.png" alt="image-20240327185356259"></p>
<p>此后某个时刻，你会发现库的用户希望使用除邮件通知之外的功能。许多用户会希望接收关于紧急事件的手机短信，还有些用户希望在微信上接收消息，而公司用户则希望在QQ上接收消息。</p>
<p><img src="/posts/18127/image-20240327185429537.png" alt="image-20240327185429537"></p>
<p>首先扩展通知器类，然后在新的子类中加入额外的通知方法。现在客户端要对所需通知形式的对应类进行初始化，然后使用该类发送后续所有的通知消息</p>
<p>但是很快有人会问：“为什么不同时使用多种通知形式呢？如果房子着火了，你大概会想在所有渠道中都收到相同的消息吧。</p>
<p>你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。但这种方式会使得代码量迅速膨胀，不仅仅是程序库代码，客户端代码也会如此</p>
<p><img src="/posts/18127/image-20240327185717738.png" alt="image-20240327185717738"></p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>当你需要更改一个对象的行为时，第一个跳入脑海的想法就是扩展它所属的类。但是，你不能忽视继承可能引发的几个严重问题。</p>
<ol>
<li>继承是静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来替代当前的整个对象。</li>
<li>子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为</li>
</ol>
<p>另一种方法是组合或者聚合。两者的工作方式几乎一模一样：一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象；继承中的对象则继承了父类的行为，它们自己能够完成这些工作。 </p>
<p>可以使用这个新方法来轻松替换各种连接的“小帮手”对象，从而能在运行时改变容器的行为。一个对象可以使用多个类的行为，包含多个指向其他对象的引用，并将各种工作委派给引用对象。  </p>
<p>聚合（或组合）是许多设计模式背后的关键原则（包括装饰在内）。</p>
<p><img src="/posts/18127/image-20240327190304920.png" alt="image-20240327190304920"></p>
<p>封装器是装饰模式的别称，这个称谓明确地表达了该模式的主要思想。“封装器”是一个能与其他“目标”对象连接的对象。封装器包含与目标对象相同的一系列方法，它会将所有接收到的请求委派给目标对象。但是，封装器可以在将请求委派给目标前后对其进行处理，所以可能会改变最终结果。</p>
<p>封装器实现了与其封装对象相同的接口。因此从客户端的角度来看，这些对象是完全一样的。封装器中的引用成员变量可以是遵循相同接口的任意对象。这使得你可以将一个对象放入多个封装器中，并在对象中添加所有这些封装器的组合行为。</p>
<p>比如在消息通知示例中，我们可以将简单邮件通知行为放在基类 通知器 中，但将所有其他通知方法放入装饰中。  </p>
<p><img src="/posts/18127/image-20240327190814916.png" alt="image-20240327190814916"></p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240327190938690.png" alt="image-20240327190938690"></p>
<ol>
<li>部件（Component）声明封装器和被封装对象的公用接口。  </li>
<li>具体部件（Concrete Component）类是被封装对象所属的类。它定义了基础行为，但装饰类可以改变这些行为。</li>
<li>基础装饰（Base Decorator）类拥有一个指向被封装对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象。</li>
<li>具体装饰类（Concrete Decorators）定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为</li>
<li>客户端（Client）可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象互动即可。</li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>装饰模式能够对敏感数据进行压缩和加密，从而将数据从使用数据的代码中独立出来  </p>
<p><img src="/posts/18127/image-20240327191428466.png" alt="image-20240327191428466"></p>
<p>程序使用一对装饰来封装数据源对象。这两个封装器都改变了从磁盘读写数据的方式：</p>
<ul>
<li>当数据即将被写入磁盘前，装饰对数据进行加密和压缩。在原始类对改变毫无察觉的情况下，将加密后的受保护数据写入文件。</li>
<li>当数据刚从磁盘读出后，同样通过装饰对数据进行解压和解密。装饰和数据源类实现同一接口，从而能在客户端代码中相互替换  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰可以改变组件接口所定义的操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataSource</span> is</span><br><span class="line">	method <span class="title function_">writeData</span><span class="params">(data)</span></span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">  constructor <span class="title function_">FileDataSource</span><span class="params">(filename)</span> &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">    <span class="comment">// 将数据写入文件。</span></span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">    <span class="comment">// 从文件读取数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并且负责对其进行初始化。</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSourceDecorator</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">	<span class="keyword">protected</span> field wrappee: DataSource</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">DataSourceDecorator</span><span class="params">(source: DataSource)</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">wrappee</span> <span class="operator">=</span> source</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些额外的行为。</span></span><br><span class="line">	method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">		wrappee.writeData(data)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 具体装饰可可简化装饰类的扩展工作。调用其父类的操作实现，而不是直接调用被封装对象。这种方式可简化装饰类的扩展工作。</span></span><br><span class="line">	method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">    <span class="keyword">return</span> wrappee.readData()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。装饰必须在调用封装对象之前或之后执行额外的行为。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncryptionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">  method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">    <span class="comment">// 1. 对传递数据进行加密。</span></span><br><span class="line">    <span class="comment">// 2. 将加密后数据传递给被封装对象 writeData（写入数据）方法</span></span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">  	<span class="comment">// 1. 通过被封装对象的 readData（读取数据）方法获取数据</span></span><br><span class="line">  	<span class="comment">// 2. 如果数据被加密就尝试解密</span></span><br><span class="line">  	<span class="comment">// 3. 返回结果。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 你可以将对象封装在多层装饰中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompressionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">  method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">  	<span class="comment">// 1. 压缩传递数据。</span></span><br><span class="line">  	<span class="comment">// 2. 将压缩后数据传递给被封装对象 writeData（写入数据）方法。</span></span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">  	<span class="comment">// 1. 通过被封装对象的 readData（读取数据）方法获取数据</span></span><br><span class="line">  	<span class="comment">// 2. 如果数据被压缩就尝试解压</span></span><br><span class="line">  	<span class="comment">// 3. 返回结果。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 选项 1：装饰组件的简单示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">dumbUsageExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;somefile.dat&quot;</span>)</span><br><span class="line">  	source.writeData(salaryRecords)</span><br><span class="line">  	<span class="comment">// 将明码数据写入目标文件</span></span><br><span class="line">  </span><br><span class="line">  	source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line">  	source.writeData(salaryRecords)</span><br><span class="line">  	<span class="comment">// 将压缩数据写入目标文件</span></span><br><span class="line">  </span><br><span class="line">  	source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">  	<span class="comment">// 源变量中现在包含：</span></span><br><span class="line">  	<span class="comment">// Encryption &gt; Compression &gt; FileDataSource</span></span><br><span class="line">  	<span class="comment">// 已将压缩且加密的数据写入目标文件</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 选项 2：客户端使用外部数据源。SalaryManager（工资管理器）对象并不关心数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配置器获取的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalaryManager</span> is</span><br><span class="line">  field source: DataSource</span><br><span class="line">  constructor <span class="title function_">SalaryManager</span><span class="params">(source: DataSource)</span> &#123; ... &#125;</span><br><span class="line">	method <span class="title function_">load</span><span class="params">()</span> is</span><br><span class="line">    <span class="keyword">return</span> source.readData()</span><br><span class="line">	method <span class="title function_">save</span><span class="params">()</span> is</span><br><span class="line">    source.writeData(salaryRecords)</span><br><span class="line">  <span class="comment">// ...其他有用的方法..</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 程序可在运行时根据配置或环境组装不同的装饰堆桟。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">  method <span class="title function_">configurationExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;salary.dat&quot;</span>)</span><br><span class="line">  	<span class="keyword">if</span> (enabledEncryption)</span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">    <span class="keyword">if</span> (enabledCompression)</span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line">    logger = <span class="keyword">new</span> <span class="title class_">SalaryManager</span>(source)</span><br><span class="line">    salary = logger.load()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式</p>
<p>装饰能将业务逻辑组织为层次结构，你可为各层创建一个装饰，在运行时将各种不同逻辑组合成对象。由于这些对象都遵循通用接口，客户端代码能以相同的方式使用这些对象  </p>
</li>
<li><p>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式  </p>
<p>许多编程语言使用 final 最终 关键字来限制对某个类的进一步扩展。复用最终类已有行为的唯一方法是使用装饰模式：用封装器对其进行封装  </p>
</li>
</ul>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</li>
<li>找出基本组件和可选层次的通用方法。创建一个组件接口并在其中声明这些方法。</li>
<li>创建一个具体组件类，并定义其基础行为。</li>
<li>创建装饰基类，使用一个成员变量存储指向被封装对象的引用。该成员变量必须被声明为组件接口类型，从而能在运行时连接具体组件和装饰。装饰基类必须将所有工作委派给被封装的对象。</li>
<li>确保所有类实现组件接口。</li>
<li>将装饰基类扩展为具体装饰。具体装饰必须在调用父类方法（总是委派给被封装对象）之前或之后执行自身的行为。  </li>
<li>客户端代码负责创建装饰并将其组合成客户端所需的形式  </li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你无需创建新子类即可扩展对象的行为。</li>
<li>你可以在运行时添加或删除对象的功能。</li>
<li>你可以用多个装饰封装对象来组合几种行为。</li>
<li>单一职责原则。你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</li>
</ul>
<hr>
<ul>
<li>在封装器栈中删除特定封装器比较困难。</li>
<li>实现行为不受装饰栈顺序影响的装饰比较困难。</li>
<li>各层的初始化配置代码看上去可能会很糟糕。</li>
</ul>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p><a href="# 适配器">适配器</a>可以对已有对象的接口进行修改，<a href="# 装饰">装饰</a>则能在不改变对象接口的前提下强化对象功能。此外，装饰还支持递归组合，适配器则无法实现</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口，<a href="# 代理">代理</a>能为对象提供相同的接口，装饰则能为对象提供加强的接口。  </p>
</li>
<li><p><a href="# 责任链">责任链</a>和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。</p>
<p>责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断请求的传递。</p>
</li>
<li><p>组合和装饰的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。装饰类似于组合，但其只有一个子组件。此外还有一个明显不同：装饰为被封装对象添加了额外的职责，组合仅对其子节点的结果进行了“求和”。</p>
<p>但是，模式也可以相互合作：你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于<a href="# 原型">原型</a>的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。</p>
</li>
<li>装饰可让你更改对象的外表，策略则让你能够改变其本质。</li>
<li>装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。</li>
</ul>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><blockquote>
<p>门面模式、Facade</p>
</blockquote>
<p>外观是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p>
<h3 id="问题背景-4"><a href="#问题背景-4" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。正常情况下，你需要负责所有对象的初始化工作、管理其依赖关系并按正确的顺序执行方法等。</p>
<p>最终，程序中类的业务逻辑将与第三方类的实现细节紧密耦合，使得理解和维护代码的工作很难进行。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观提供的功能可能比较有限，但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合，但只需使用其中非常少的功能，那么使用外观模式会非常方便，例如，上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库，但它只需使用一个包含encode(filename,format)方法（以文件名与文件格式为参数进行编码的方法）的类即可。在创建这个类并将其连接到视频转换库后，你就拥有了自己的第一个外观。</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240401183018070.png" alt="image-20240401183018070"></p>
<ol>
<li>外观（<code>Facade</code>）提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求，知晓如何操作一切活动部件。</li>
<li>创建附加外观（<code>Additional Facade</code>）类可以避免多种不相关的功能污染单一外观，使其变成又一个复杂结构。客户端和其他外观都可使用附加外观。</li>
<li>复杂子系统（<code>Complex Subsystem</code>）由数十个不同对象构成。如果要用这些对象完成有意义的工作，你必须深入了解子系统的实现细节，比如按照正确顺序初始化对象和为其提供正确格式的数据。</li>
<li>客户端（<code>Client</code>）使用外观代替对子系统对象的直接调用。  </li>
</ol>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>外观模式简化了客户端与复杂视频转换框架之间的交互</p>
<p><img src="/posts/18127/image-20240401183412101.png" alt="image-20240401183412101"></p>
<p>创建一个封装所需功能并隐藏其他代码的外观类，从而无需使全部代码直接与数十个框架类进行交互。该结构还能将未来框架升级或更换所造成的影响最小化，因为你只需修改程序中外观方法的实现即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法对其进行简化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoFile</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OggCompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MPEG4CompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodecFactory</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitrateReader</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioMixer</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在功能性和简洁性之间做出的权衡。</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoConverter</span> is</span><br><span class="line">  method <span class="title function_">convert</span><span class="params">(filename, format)</span>:File <span class="type">is</span></span><br><span class="line">  	<span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoFile</span>(filename)</span><br><span class="line">  	sourceCodec = <span class="keyword">new</span> <span class="title class_">CodecFactory</span>.extract(file)</span><br><span class="line">  	<span class="keyword">if</span> (format == <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">    	destinationCodec = <span class="keyword">new</span> <span class="title class_">MPEG4CompressionCodec</span>()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      destinationCodec = <span class="keyword">new</span> <span class="title class_">OggCompressionCodec</span>()</span><br><span class="line">    buffer = BitrateReader.read(filename, sourceCodec)</span><br><span class="line">    result = BitrateReader.convert(buffer, destinationCodec)</span><br><span class="line">    result = (<span class="keyword">new</span> <span class="title class_">AudioMixer</span>()).fix(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(result)</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，那只需重写外观类即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">convertor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoConverter</span>()</span><br><span class="line">  	mp4 = convertor.convert(<span class="string">&quot;funny-cats-video.ogg&quot;</span>, <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">  	mp4.save()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式</strong></p>
<p>子系统通常会随着时间的推进变得越来越复杂。即便是应用了设计模式，通常你也会创建更多的类。尽管在多种情形中子系统可能是更灵活或易于复用的，但其所需的配置和样板代码数量将会增长得更快。为了解决这个问题，外观将会提供指向子系统中最常用功能的快捷方式，能够满足客户端的大部分需求。</p>
</li>
<li><p><strong>如果需要将子系统组织为多层结构，可以使用外观</strong></p>
<p>创建外观来定义子系统中各层次的入口。你可以要求子系统仅使用外观来进行交互，以减少子系统之间的耦合</p>
<p>视频转换框架可以拆分为两个层次：音频相关和视频相关。可以为每个层次创建一个外观，然后要求各层的类必须通过这些外观进行交互。这种方式看上去与中介者模式非常相似</p>
</li>
</ul>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类，那么你的方向就是正确的  </li>
<li>在一个新的外观类中声明并实现该接口。外观应将客户端代码的调用重定向到子系统中的相应对象处。如果客户端代码没有对子系统进行初始化，也没有对其后续生命周期进行管理，那么外观必须完成此类工作</li>
<li>如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观来与子系统进行交互。此后客户端代码将不会受到任何由子系统代码修改而造成的影响，比如子系统升级后，你只需修改外观中的代码即可</li>
<li>如果外观变得过于臃肿，你可以考虑将其部分行为抽取为一个新的专用外观类</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以让自己的代码独立于复杂子系统</li>
</ul>
<hr>
<ul>
<li>外观可能成为与程序中所有类都耦合的上帝对象  </li>
</ul>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 外观">外观</a>为现有对象定义了一个新接口，<a href="# 适配器">适配器</a>则会试图运用已有的接口。适配器通常只封装一个对象，外观通常会作用于整个对象子系统上</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽<a href="# 抽象工厂">象工厂</a>来代替外观</li>
<li><a href="# 享元">享元</a>展示了如何生成大量的小型对象，<a href="# 外观">外观</a>则展示了如何用一个对象来代表整个子系统</li>
<li>外观和<a href="# 中介者">中介者</a>的职责类似：它们都尝试在大量紧密耦合的类中组织起合作<ul>
<li>外观为子系统中的所有对象定义了一个简单接口，但是它不提供任何新功能。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流</li>
<li>中介者将系统中组件的沟通行为中心化。各组件只知道中介者对象，无法直接相互交流</li>
</ul>
</li>
<li>外观类通常可以转换为单例类，因为在大部分情况下一个外观对象就足够了</li>
<li>外观与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同</li>
</ul>
<h2 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h2><blockquote>
<p>缓存、Cache、Flyweight</p>
</blockquote>
<p>享元是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中　　载入更多对象。</p>
<h3 id="问题背景-5"><a href="#问题背景-5" class="headerlink" title="问题背景"></a>问题背景</h3><p>需要开发一款简单的游戏：玩家们在地图上移动并相互射击。你决定实现一个真实的粒子系统，并将其作为游戏的特色。大量的子弹、导弹和爆炸弹片会在整个地图上穿行，为玩家提供紧张刺激的游戏体验。</p>
<p>开发完成后，你推送提交了最新版本的程序，并在编译游戏后将其发送给了一个朋友进行测试。尽管该游戏在你的电脑上完美运行，但是你的朋友却无法长时间进行游戏：游戏总是会在他的电脑上运行几分钟后崩溃。在研究了几个小时的调试消息记录后，你发现导致游戏崩溃的原因是内存容量不足。朋友的设备性能远比不上你的电脑，因此游戏运行在他的电脑上时很快就会出现问题。</p>
<p>真正的问题与粒子系统有关。每个粒子（一颗子弹、一枚导弹或一块弹片）都由包含完整数据的独立对象来表示。当玩家在游戏中鏖战进入高潮后的某一时刻，游戏将无法在剩余内存中载入新建粒子，于是程序就崩溃了。</p>
<p><img src="/posts/18127/image-20240408185701020.png" alt="image-20240408185701020"></p>
<h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>仔细观察粒子<code>Particle</code>类，你可能会注意到颜色（<code>color</code>）和贴图（<code>sprite</code>）这两个成员变量所消耗的内存要比其他变量多得多。更糟糕的是，对于所有的粒子来说，这两个成员变量所存储的数据几乎完全一样（比如所有子弹的颜色和贴图都一样）。</p>
<p><img src="/posts/18127/image-20240408185844014.png" alt="image-20240408185844014"></p>
<p>每个粒子的另一些状态（坐标、移动矢量和速度）则是不同的。因为这些成员变量的数值会不断变化。这些数据代表粒子在存续期间不断变化的情景，但每个粒子的颜色和贴图则会保持不变。  </p>
<p>每个粒子的另一些状态（坐标、移动矢量和速度）则是不同的。因为这些成员变量的数值会不断变化。这些数据代表粒子在存续期间不断变化的情景，但每个粒子的颜色和贴图则会保持不变。  </p>
<p>对象的常量数据通常被称为内在状态，其位于对象中，其他对象只能读取但不能修改其数值。而对象的其他状态常常能被其他对象“从外部”改变，因此被称为外在状态。  </p>
<p>享元模式建议不在对象中存储外在状态，而是将其传递给依赖于它的一个特殊方法。程序只在对象中保存内在状态，以方便在不同情景下重用。这些对象的区别仅在于其内在状态（与外在状态相比，内在状态的变体要少很多），因此你所需的对象数量会大大削减。  </p>
<p><img src="/posts/18127/image-20240408190141222.png" alt="image-20240408190141222"></p>
<p>假如能从粒子类中抽出外在状态，那么我们只需三个不同的对象（子弹、导弹和弹片）就能表示游戏中的所有粒子。你现在很可能已经猜到了，我们将这样一个仅存储内在状态的对象称为享元</p>
<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240408190633588.png" alt="image-20240408190633588"></p>
<ol>
<li>享元模式只是一种优化。在应用该模式之前，你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题，并且确保该问题无法使用其他更好的方式来解决</li>
<li>享元（Flyweight）类包含原始对象中部分能在多个对象中共享的状态。同一享元对象可在许多不同情景中使用。享元中存储的状态被称为“内在状态”。传递给享元方法的状态被称为“外在状态” </li>
<li>情景（Context）类包含原始对象中各不相同的外在状态。情景与享元对象组合在一起就能表示原始对象的全部状态</li>
<li>通常情况下，原始对象的行为会保留在享元类中。因此调用享元方法必须提供部分外在状态作为参数。但你也可将行为移动到情景类中，然后将连入的享元作为单纯的数据对象</li>
<li>客户端（Client）负责计算或存储享元的外在状态。在客户端看来，享元是一种可在运行时进行配置的模板对象，具体的配置方式为向其方法中传入一些情景数据参数</li>
<li>享元工厂（Flyweight Factory）会对已有享元的缓存池进行管理。有了工厂后，客户端就无需直接创建享元，它们只需调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参数在之前已创建的享元中进行查找，如果找到满足条件的享元就将其返回；如果没有找到就根据参数新建享元</li>
</ol>
<h3 id="伪代码-5"><a href="#伪代码-5" class="headerlink" title="伪代码"></a>伪代码</h3><p>享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存</p>
<p><img src="/posts/18127/image-20240408190958009.png" alt="image-20240408190958009"></p>
<p>该模式从主要的 树 <code>Tree</code> 类中抽取内在状态，并将其移动到享元类 树种类 <code>TreeType</code> 之中</p>
<p>最初程序需要在多个对象中存储相同数据，而现在仅需在几个享元对象中保存数据，然后在作为情景的 树 对象中连入享元即可。客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为，并能在需要时复用对象  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象中，然后让众多的单个树对象去引用它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeType</span> is</span><br><span class="line">	field name</span><br><span class="line">	field color</span><br><span class="line">	field texture</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">TreeType</span><span class="params">(name, color, texture） 							&#123;...&#125;</span></span><br><span class="line"><span class="params">	method draw(canvas, x, y)</span> is</span><br><span class="line">		<span class="comment">//1.创建特定类型、颜色和纹理的位图。</span></span><br><span class="line">		<span class="comment">//2．在画布坐标（X,Y）处绘制位图。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">// 享元工厂决定是否复用已有享元或者创建一个新的对象。class TreeFactory is</span></span><br><span class="line">	<span class="keyword">static</span> field treeTypes: collection of tree types</span><br><span class="line">	<span class="keyword">static</span> method <span class="title function_">getTreeType</span><span class="params">(name, color, texture)</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">type</span> <span class="operator">=</span> treeTypes.find(name, color, texture)</span><br><span class="line">		<span class="keyword">if</span> (type == <span class="literal">null</span>)</span><br><span class="line">			type = <span class="keyword">new</span> <span class="title class_">TreeType</span>(name, color, texture)</span><br><span class="line">			treeTypes.add(type)</span><br><span class="line">		<span class="keyword">return</span> type</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们体积很小：仅有两个整型坐标和一个引用成员变量。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> is </span><br><span class="line">	field x,y</span><br><span class="line">	field type: TreeType</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Tree</span><span class="params">(x, y， type)</span>&#123;...&#125;</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">draw</span><span class="params">(canvas)</span> is</span><br><span class="line">		type.draw(canvas, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树（Tree）和森林（Forest）类是享元的客户端。如果不打算继续对树类进行开发，你可以将它们合并。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Forest</span> is</span><br><span class="line">	field trees: collection of Trees</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">plantTree</span><span class="params">(x,y,name,color,texture)</span><span class="type">is</span></span><br><span class="line">		<span class="variable">type</span> <span class="operator">=</span> TreeFactory.getTreeType(name, color, texture)</span><br><span class="line">		tree = <span class="keyword">new</span> <span class="title class_">Tree</span>(x, y, type)</span><br><span class="line">		trees.add(tree)</span><br><span class="line">		</span><br><span class="line">  method <span class="title function_">draw</span><span class="params">(canvas)</span> is</span><br><span class="line">  	<span class="title function_">foreach</span> <span class="params">(tree in trees)</span> </span><br><span class="line">  		dotree.draw(canvas)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式</li>
<li>应用该模式所获的收益大小取决于使用它的方式和情景。它在下列情况中最有效 :<ul>
<li>程序需要生成数量巨大的相似对象</li>
<li>这将耗尽目标设备的所有内存</li>
<li>对象中包含可抽取且能在多个对象间共享的重复状态。</li>
</ul>
</li>
</ul>
<h3 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>将需要改写为享元的类成员变量拆分为两个部分:<ul>
<li>内在状态：包含不变的、可在许多对象中重复使用的数据的成员变量。</li>
<li>外在状态：包含每个对象各自不同的情景数据的成员变量</li>
</ul>
</li>
<li>保留类中表示内在状态的成员变量，并将其属性设置为不可修改。这些变量仅可在构造函数中获得初始数值。</li>
<li>找到所有使用外在状态成员变量的方法，为在方法中所用的每个成员变量新建一个参数，并使用该参数代替成员变量。</li>
<li>你可以有选择地创建工厂类来管理享元缓存池，它负责在新建享元时检查已有的享元。如果选择使用工厂，客户端就只能通过工厂来请求享元，它们需要将享元的内在状态作为参数传递给工厂。</li>
<li>客户端必须存储和计算外在状态（情景）的数值，因为只有这样才能调用享元对象的方法。为了使用方便，外在状态和引用享元的成员变量可以移动到单独的情景类中</li>
</ol>
<h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>如果程序中有很多相似对象，那么你将可以节省大量内存</li>
</ul>
<hr>
<ul>
<li>你可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分情景数据</li>
<li>代码会变得更加复杂。团队中的新成员总是会问：“为什么要像这样拆分一个实体的状态？”  </li>
</ul>
<h3 id="与其他模式的关系-5"><a href="#与其他模式的关系-5" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>你可以使用享元实现组合树的共享叶节点以节省内存  </li>
<li>享元展示了如何生成大量的小型对象，外观则展示了如何用一个对象来代表整个子系统</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象，那么享元就和单例类似了。但这两个模式有两个根本性的不同<ul>
<li>只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同</li>
<li>单例对象可以是可变的。享元对象是不可变的  </li>
</ul>
</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><blockquote>
<p>Proxy</p>
</blockquote>
<p>代理是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p>
<h3 id="问题背景-6"><a href="#问题背景-6" class="headerlink" title="问题背景"></a>问题背景</h3><p>有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它，并非总是需要</p>
<p><img src="/posts/18127/image-20240409184246134.png" alt="image-20240409184246134"></p>
<p>你可以实现延迟初始化：在实际有需要时再创建该对象。对象的所有客户端都要执行延迟初始代码。不幸的是，这很可能会带来很多重复代码。</p>
<p>在理想情况下，我们希望将代码直接放入对象的类中，但这并非总是能实现：比如类可能是第三方封闭库的一部分  </p>
<h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><p>代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端。代理类接收到客户端请求后会创建实际的服务对象，并将所有工作委派给它</p>
<p><img src="/posts/18127/image-20240409184550672.png" alt="image-20240409184550672"></p>
<p>代理将自己伪装成数据库对象，可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作</p>
<p>如果需要在类的主要业务逻辑前后执行一些工作，你无需修改类就能完成这项工作。由于代理实现的接口与原类相同，因此你可将其传递给任何一个使用实际服务对象的客户端</p>
<h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240409184932147.png" alt="image-20240409184932147"></p>
<ol>
<li>服务接口（<code>Service Interface</code>）声明了服务接口。代理必须遵循该接口才能伪装成服务对象</li>
<li>服务（<code>Service</code>）类提供了一些实用的业务逻辑</li>
<li>代理（<code>Proxy</code>）类包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象。通常情况下，代理会对其服务对象的整个生命周期进行管理</li>
<li>客户端（<code>Client</code>） 能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理</li>
</ol>
<h3 id="伪代码-6"><a href="#伪代码-6" class="headerlink" title="伪代码"></a>伪代码</h3><p>使用代理模式在第三方腾讯视频（<code>TencentVideo</code>，代码示例中记为TV）程序库中添加延迟初始化和缓存。<br><img src="/posts/18127/image-20240409185609538.png" alt="image-20240409185609538" style="zoom:80%;"></p>
<p>程序库提供了视频下载类。但是该类的效率非常低。如果客户端程序多次请求同一视频，程序库会反复下载该视频，而不会将首次下载的文件缓存下来复用。</p>
<p>代理类实现和原下载器相同的接口，并将所有工作委派给原下载器。不过，代理类会保存所有的文件下载记录，如果程序多次请求同一文件，它会返回缓存的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">field needReset</span><br><span class="line"><span class="comment">// 远程服务接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThirdPartyTVLib</span> is</span><br><span class="line">	method <span class="title function_">listVideos</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">getVideoInfo</span><span class="params">(id)</span></span><br><span class="line">	method <span class="title function_">downloadvideo</span><span class="params">(id)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息一模一样，程序的速度依然会减慢。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdPartyTvclass</span> <span class="keyword">implements</span> <span class="title class_">ThirdPartyTVLib</span> is</span><br><span class="line">	method <span class="title function_">listVideos</span><span class="params">()</span> is</span><br><span class="line">		<span class="comment">//向腾讯视频发送一个API请求。</span></span><br><span class="line">  method <span class="title function_">getVideoInfo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="comment">//获取某个视频的元数据。</span></span><br><span class="line">  method <span class="title function_">downloadVideo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="comment">//从腾讯视频下载一个视频文件。</span></span><br><span class="line">  	</span><br><span class="line"><span class="comment">//为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签名是final（最终）。因此我们会在一个实现了服务类接口的新代理类中放入缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CachedTVClass</span> <span class="keyword">implements</span> <span class="title class_">ThirdPartyTVLib</span> is</span><br><span class="line">	<span class="keyword">private</span> field service: ThirdPartyTVLib</span><br><span class="line">	<span class="keyword">private</span> field listcache, videoCache</span><br><span class="line">	field needReset</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">CachedTVClass</span><span class="params">(service: ThirdPartyTVLib)</span> is</span><br><span class="line">		<span class="built_in">this</span>.service = service</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">listVideos</span><span class="params">()</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(listCache == <span class="literal">null</span> || needReset)</span></span><br><span class="line">  		listCache = service.listVideos()</span><br><span class="line">  	<span class="keyword">return</span> listCache</span><br><span class="line">  	</span><br><span class="line">  method <span class="title function_">getVideoInfo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(videoCache == <span class="literal">null</span> || needReset)</span></span><br><span class="line">  		videoCache = service.getVideoInfo(id)</span><br><span class="line">    <span class="keyword">return</span> videoCache</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">downloadVideo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(!downloadExists(id)</span> || needReset)</span><br><span class="line">  		service.downloadVideo(id)</span><br><span class="line">  		</span><br><span class="line"><span class="comment">// 之前直接与服务对象交互的GUI类不需要改变，前提是它仅通过接口与服务对象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实现了相同的接口。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TVManager</span> is</span><br><span class="line">  	<span class="keyword">protected</span> field service: ThirdPartyTVLib</span><br><span class="line">     </span><br><span class="line">    constructor <span class="title function_">TVManager</span><span class="params">(service: ThirdPartyTVLib)</span> is</span><br><span class="line">    	<span class="built_in">this</span>.service = service</span><br><span class="line">      </span><br><span class="line">    method <span class="title function_">renderVideoPage</span><span class="params">(id)</span> <span class="type">is</span></span><br><span class="line">      <span class="variable">info</span> <span class="operator">=</span> service.getVideoInfo(id)</span><br><span class="line">      <span class="comment">// 渲染视频页面</span></span><br><span class="line">    </span><br><span class="line">    method <span class="title function_">renderListPanel</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">      <span class="variable">list</span> <span class="operator">=</span> service.listVideos()</span><br><span class="line">      <span class="comment">//渲染视频缩略图列表。</span></span><br><span class="line">      </span><br><span class="line">    method <span class="title function_">reactOnUserInput</span><span class="params">()</span> is</span><br><span class="line">      <span class="title function_">renderVideoPage</span><span class="params">()</span></span><br><span class="line">      renderListPanel()</span><br><span class="line">      </span><br><span class="line"><span class="comment">//程序可在运行时对代理进行配置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">init</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">aTVService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyTVClass</span>()</span><br><span class="line">  	aTVProxy = <span class="keyword">new</span> <span class="title class_">CachedTVClass</span>(aTVService)</span><br><span class="line">  	manager = <span class="keyword">new</span> <span class="title class_">TVManager</span>(aTVProxy)</span><br><span class="line">    manager.reactOnUserInput()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象，可将对象的初始化延迟到真正有需要的时候</p>
</li>
<li><p>访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可使用代理模式</p>
<p>代理可仅在客户端凭据满足要求时将请求传递给服务对象</p>
</li>
<li><p>本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形</p>
<p>在这种情形中，代理通过网络传递客户端请求，负责处理所有与网络相关的复杂细节</p>
</li>
<li><p>记录日志请求（日志记录代理）。适用于当你需要保存对于服务对象的请求历史记录时。代理可以在向服务传递请求前进行记录</p>
<p>缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时</p>
<p>代理可对重复请求所需的相同结果进行缓存，还可使用请求参数作为索引缓存的键值</p>
</li>
<li><p>智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象</p>
<p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。代理会时不时地遍历各个客户端，检查它们是否仍在运行。如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源</p>
<p>代理还可以记录客户端是否修改了服务对象。其他客户端还可以复用未修改的对象</p>
</li>
</ul>
<h3 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>如果没有现成的服务接口，你就需要创建一个接口来实现代理和服务对象的可交换性。从服务类中抽取接口并非总是可行的，因为你需要对服务的所有客户端进行修改，让它们使用接口。备选计划是将代理作为服务类的子类，这样代理就能继承服务的所有接口了。</li>
<li>创建代理类，其中必须包含一个存储指向服务的引用的成员变量。通常情况下，代理负责创建服务并对其整个生命周期进行管理。在一些特殊情况下，客户端会通过构造函数将服务传递给代理。</li>
<li>根据需求实现代理方法。在大部分情况下，代理在完成一些任务后应将工作委派给服务对象。</li>
<li>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法，也可以创建一个完整的工厂方法。 </li>
<li>可以考虑为服务对象实现延迟初始化。</li>
</ol>
<h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以在客户端毫无察觉的情况下控制服务对象</li>
<li>如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理</li>
<li>即使服务对象还未准备好或不存在，代理也可以正常工作</li>
<li>开闭原则。你可以在不对服务或客户端做出修改的情况下创建新代理  </li>
</ul>
<hr>
<ul>
<li>代码可能会变得复杂，因为需要新建许多类</li>
<li>服务响应可能会延迟</li>
</ul>
<h3 id="与其他模式的关系-6"><a href="#与其他模式的关系-6" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>适配器能为被封装对象提供不同的接口，代理能为对象提供相同的接口，装饰则能为对象提供加强的接口。</li>
<li>外观与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同。</li>
<li>装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/" rel="tag"># 开发进阶知识</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/16062.html" rel="next" title="设计模式-创建型模式">
                <i class="fa fa-chevron-left"></i> 设计模式-创建型模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/23570.html" rel="prev" title="设计模式-行为模式">
                设计模式-行为模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xzp314" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:seu_xuzhipeng@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5"><span class="nav-number">1.2.</span> <span class="nav-text">桥接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="nav-number">1.2.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">1.2.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="nav-number">1.2.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">1.3.</span> <span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.3.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.3.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-2"><span class="nav-number">1.3.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">1.3.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-2"><span class="nav-number">1.3.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0"><span class="nav-number">1.4.</span> <span class="nav-text">装饰</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-3"><span class="nav-number">1.4.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">1.4.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-3"><span class="nav-number">1.4.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="nav-number">1.4.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-3"><span class="nav-number">1.4.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E8%A7%82"><span class="nav-number">1.5.</span> <span class="nav-text">外观</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-4"><span class="nav-number">1.5.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">1.5.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-4"><span class="nav-number">1.5.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="nav-number">1.5.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-4"><span class="nav-number">1.5.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%AB%E5%85%83"><span class="nav-number">1.6.</span> <span class="nav-text">享元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-5"><span class="nav-number">1.6.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-5"><span class="nav-number">1.6.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">1.6.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-5"><span class="nav-number">1.6.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-5"><span class="nav-number">1.6.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-5"><span class="nav-number">1.6.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-6"><span class="nav-number">1.7.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-6"><span class="nav-number">1.7.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-6"><span class="nav-number">1.7.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="nav-number">1.7.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-6"><span class="nav-number">1.7.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-6"><span class="nav-number">1.7.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-6"><span class="nav-number">1.7.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Zhipeng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">243k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
