<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="开发进阶知识," />










<meta name="description" content="创建型模式提供创建对象的机制，提升已有代码的灵活性和可复用性">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式-创建型模式">
<meta property="og:url" content="http://example.com/posts/16062.html">
<meta property="og:site_name" content="主页">
<meta property="og:description" content="创建型模式提供创建对象的机制，提升已有代码的灵活性和可复用性">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/posts/16062/image-20240227191801052.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240227192127884.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240227192215616.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240227192253764.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240306185940396.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240228181453632.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240228182311775.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240228182424624.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240228182719053.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240228183848178.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240306184615376.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240306184805162.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240306184900394.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240306185309368.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240306185840793.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240311192308784.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240311193232360.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240311193454637.png">
<meta property="og:image" content="http://example.com/posts/16062/image-20240312180931884.png">
<meta property="article:published_time" content="2024-02-27T10:44:05.000Z">
<meta property="article:modified_time" content="2024-04-10T12:04:09.086Z">
<meta property="article:author" content="Xu Zhipeng">
<meta property="article:tag" content="开发进阶知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/posts/16062/image-20240227191801052.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/posts/16062.html"/>





  <title>设计模式-创建型模式 | 主页</title>
  








<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="主页" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">xzp个人小站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/16062.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式-创建型模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-02-27T18:44:05+08:00">
                2024-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  47
                </span>
              
            </div>
          

          
              <div class="post-description">
                  创建型模式提供创建对象的机制，提升已有代码的灵活性和可复用性
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式包括以下几种具体模式：</p>
<ol>
<li>工厂方法（<code>Factory Method</code>）：在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型</li>
<li>抽象工厂（<code>Abstract Factory</code>）：让你能创建一系列相关的对象，而无需指定其具体类</li>
<li>生成器（<code>Builder</code>）：使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象</li>
<li>原型（<code>Prototype</code>）：让你能够复制已有对象，而又无需使代码依赖它们所属的类  </li>
<li>单例（<code>Singleton</code>）：让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点</li>
</ol>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>虚拟构造函数、Virtual Constructor、Factory Method</p>
<p>工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你正在开发一款物流管理应用。最初版本只能处理卡车运输，因此大部分代码都在位于名为卡车的类中。一段时间后，这款应用变得极受欢迎。你每天都能收到十几次来自海运公司的请求，希望应用能够支持海上物流功能。</p>
<p>目前，大部分代码都与卡车类相关。因此，在程序中添加轮船类需要修改全部代码。更糟糕的是，如果你以后需要在程序中支持另外一种运输方式，很可能需要再次对这些代码进行大幅修改  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>工厂方法模式建议使用特殊的工厂方法代替对对象构造函数的直接调用（使用<code>new</code>运算符）。不用担心，对象仍将通过<code>new</code>运算符创建，只是该运算符改在工厂方法中调用罢了。工厂方法返回的对象通常被称作“产品”。</p>
<p><img src="/posts/16062/image-20240227191801052.png" alt="image-20240227191801052"></p>
<p>虽然只是改变了程序中调用构造函数的位置而已。但是，现在可以在子类中重写工厂方法，从而改变其创建产品的类型。需要注意的是，仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应将其返回类型声明为这一共有接口  </p>
<p><img src="/posts/16062/image-20240227192127884.png" alt="image-20240227192127884"></p>
<p>卡车<code>Truck</code>和 轮船<code>Ship</code>类都必须实现运输<code>Transport</code>接口， 该接口声明了一个名为<code>deliver</code>交 付 的 方 法。 每 个 类 都 将 以 不 同 的 方 式 实 现 该 方法： 卡 车 走 陆 路 交 付 货 物， 轮 船 走 海 路 交 付 货 物。陆路运输 <code>RoadLogistics</code> 类中的工厂方法返回卡车对象，而海路运输<code>SeaLogistics</code>类则返回轮船对象。</p>
<p><img src="/posts/16062/image-20240227192215616.png" alt="image-20240227192215616"></p>
<p>调用工厂方法的代码（通常被称为客户端代码）无需了解不同子类返回实际对象之间的差别。客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付 方法，但是并不关心其具体实现方式  </p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240227192253764.png" alt="image-20240227192253764"></p>
<ol>
<li><p><strong>产品</strong>（<code>Product</code>）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的</p>
</li>
<li><p><strong>具体产品</strong>（<code>Concrete Products</code>）是产品接口的不同实现</p>
</li>
<li><p><strong>创建者</strong>（<code>Creator</code>）类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配</p>
<p> 你可以将工厂方法声明为抽象方法，强制要求每个子类以不同方式实现该方法。或者，你也可以在基础工厂方法中返回默认产品类型。</p>
<p> 特别需要注意的是：尽管名字是创建者，但它最主要的职责并不是创建产品。一般来说，创建者类会包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。</p>
</li>
<li><p><strong>具体创建者</strong>（<code>Concrete Creators</code>） 将会重写基础工厂方法，使其返回不同类型的产品</p>
<p> 并不一定每次调用工厂方法都会创建新的实例，也可以返回缓存、对象池或其他来源的已有对象。</p>
</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>跨平台对话框示例  </p>
<p><img src="/posts/16062/image-20240306185940396.png" alt="image-20240306185940396"></p>
<p>基础对话框类使用不同的UI组件渲染窗口，上述只是其中一种组件，即按钮。在不同的操作系统下，这些组件外观或许略有不同，但其功能保持一致。</p>
<p>如果使用工厂方法，就不需要为每种操作系统重写对话框逻辑。如果我们声明了一个在基本对话框类中生成按钮的工厂方法，那么我们就可以创建一个对话框子类，并使其通过工厂方法返回Windows样式按钮。子类将继承对话框基础类的大部分代码，同时在屏幕上根据Windows样式渲染按钮。每向对话框中添加一个新的工厂方法，你就离抽象工厂模式更近一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供该方法的实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> is</span><br><span class="line">	<span class="comment">// 创建者还可提供一些工厂方法的默认实现。</span></span><br><span class="line">	<span class="keyword">abstract</span> method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建者的主要职责并非是创建产品，而是会包含一些核心业务</span></span><br><span class="line">  <span class="comment">// 这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span></span><br><span class="line">  <span class="comment">// 法并使其返回不同类型的产品来间接修改业务逻辑。</span></span><br><span class="line">  method <span class="title function_">render</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">// 调用工厂方法创建一个产品对象。</span></span><br><span class="line">    <span class="type">Button</span> <span class="variable">okButton</span> <span class="operator">=</span> createButton()</span><br><span class="line">    <span class="comment">// 现在使用产品。</span></span><br><span class="line">    okButton.onClick(closeDialog)</span><br><span class="line">    okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体创建者将重写工厂方法以改变其所返回的产品类型。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HTMLButton</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 产品接口中将声明所有具体产品都必须实现的操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">	method <span class="title function_">render</span><span class="params">()</span> <span class="comment">// 渲染</span></span><br><span class="line">	method <span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品需提供产品接口的各种实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line"> method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">	<span class="comment">// 根据 Windows 样式渲染按钮。</span></span><br><span class="line"> method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">	<span class="comment">// 绑定本地操作系统点击事件。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">HTMLButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">  <span class="comment">// 返回一个按钮的 HTML 表述。</span></span><br><span class="line">  method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">  <span class="comment">// 绑定网络浏览器的点击事件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line"> field dialog: Dialog</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 程序根据当前配置或环境设定选择创建者的类型。</span></span><br><span class="line"> method <span class="title function_">initialize</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line"> 	<span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line"> 		<span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsDialog</span>() <span class="comment">// 就是创建了一个dialog</span></span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Web&quot;</span>) <span class="type">then</span></span><br><span class="line">		<span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDialog</span>()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;错误！未知的操作系统。&quot;</span>)</span><br><span class="line">    <span class="comment">//当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子类传递给客户端。</span></span><br><span class="line">    </span><br><span class="line">	method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">		<span class="built_in">this</span>.initialize()</span><br><span class="line">		dialog.render()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p><strong>无法预知对象确切类别及其依赖关系时</strong></p>
<p> 工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码</p>
<blockquote>
<p>如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可  </p>
</blockquote>
</li>
<li><p><strong>需要用户能扩展你软件库或框架的内部组件</strong></p>
<p> 继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨识出该子类 </p>
<p> 解决方案是将各框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写</p>
<blockquote>
<p>假设你使用开源 UI 框架编写自己的应用。你希望在应用中使用圆形按钮，但是原框架仅支持矩形按钮。你可以使用圆形按钮<code>RoundButton</code>子类来继承标准的按钮<code>Button</code> 类。但是，你需要告诉UI框架<code>UIFramework</code>类使用新的子类按钮代替默认按钮</p>
<p>为了实现这个功能， 你可以根据基础框架类开发子类圆形按钮UI <code>UIWithRoundButtons</code>，并且重写其<code>createButton</code>创建按钮方法。基类中的该方法返回按钮对象，而你开发的子类返回圆形按钮 对象。现在，你就可以使用圆形按钮UI类代替UI框架类。</p>
</blockquote>
</li>
<li><p><strong>需要复用现有对象来节省系统资源，而不是每次都重新创建对象</strong></p>
<p> 复用现有对象需要（1）创建存储空间来存放所有已经创建的对象（2）当他人请求一个对象时，程序将在对象池中搜索可用对象，然后将其返回给客户端代码（3）如果没有可用对象，程序则创建一个新对象（并将其添加到对象池中）</p>
<p> 上述代码应该位于构造函数中，但是构造函数本身的定义应该始终返回新对象，因此就需要再抽象出一层既能够创建新对象，又可以重用现有对象的普通方法，其实就是工厂方法</p>
</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。</p>
</li>
<li><p>在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p>
</li>
<li><p>为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。</p>
</li>
<li><p>如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。</p>
<blockquote>
<p>设想你有以下一些层次结构的类。基类 邮件 及其子类 航空邮件 和 陆路邮件 ； 运输 及其子类 飞机 , 卡车和 火车 。 航空邮件 仅使用 飞机 对象，而 陆路邮件 则会同时使用 卡车 和 火车 对象。你可以编写一个新的子类（例如 火车邮件 ）来处理这两种情况，但是还有其他可选的方案。客户端代码可以给 陆路邮件 类传递一个参数，用于控制其希望获得的产品。</p>
</blockquote>
</li>
<li><p>如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。</p>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>可以<strong>避免</strong>创建者和具体产品之间的<strong>紧密耦合</strong></li>
<li><strong>单一职责原则</strong>。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护</li>
<li><strong>开闭原则</strong>。无需更改现有客户端代码，你就可以在程序中引入新的产品类型</li>
</ul>
<hr>
<ul>
<li>应用工厂方法模式需要引入许多新的子类，代码可能会因此变得<strong>更复杂</strong>。最好的情况是将该模式引入创建者类的现有层次结构中</li>
</ul>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用<a href="# 抽象工厂">抽象工厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>
<li>你可以同时使用工厂方法和迭代器来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。</li>
<li>原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承，但是它不需要初始化步骤。</li>
<li>工厂方法是<a href="# 模板">模板</a>方法的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。</li>
</ul>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>Abstract Factory</p>
<p>抽象工厂是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类</p>
<h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你正在开发一款家具商店模拟器，包括一些类，用于抽象：</p>
<ol>
<li>一系列相关产品， 例如椅子<code>Chair</code>、沙发<code>Sofa</code>和咖啡桌CoffeeTable</li>
<li>系列产品的不同变体。 例如， 你可以使用现代<code>Modern</code>、维多利亚 <code>Victorian</code>、装饰风艺术<code>ArtDeco</code>等风格生成椅子、沙发和咖啡桌 </li>
</ol>
<p><img src="/posts/16062/image-20240228181453632.png" alt="image-20240228181453632"></p>
<p>你需要设法单独生成每件家具对象，这样才能确保其风格一致。如果顾客收到的家具风格不一样，他们可不会开心。  </p>
<p>此外， 你也不希望在添加新产品或新风格时修改已有代码。家具供应商对于产品目录的更新非常频繁，你不会想在每次更新时都去修改核心代码的。  </p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先，抽象工厂模式建议为系列中的每件产品明确声明接口（例如椅子、沙发或咖啡桌）。然后，确保所有产品变体都继承这些接口。例如，所有风格的椅子都实现椅子接口；所有风格的咖啡桌都实现咖啡桌接口，以此类推</p>
<p><img src="/posts/16062/image-20240228182311775.png" alt="image-20240228182311775"></p>
<p>接下来，我们需要声明抽象工厂——包含系列中所有产品构造方法的接口。例如 <code>createChair</code> 创建椅子 、 <code>createSofa</code>创建沙发 和 <code>createCoffeeTable</code> 创建咖啡桌 。 这些方法必须返回抽象产品类型，即我们之前抽取的那些接口：椅子，沙发和咖啡桌等等  </p>
<p><img src="/posts/16062/image-20240228182424624.png" alt="image-20240228182424624"></p>
<p>那么该如何处理产品变体呢？对于系列产品的每个变体,我们都将基于抽象工厂接口创建不同的工厂类。每个工厂类都只能返回特定类别的产品，例如，现代家具工厂<code>ModernFurnitureFactory</code>只能创建现代椅子<code>ModernChair</code>，现代沙发<code>ModernSofa</code>和现代咖啡桌<code>ModernCoffeeTable</code>对象。</p>
<p>客户端代码可以通过相应的抽象接口调用工厂和产品类。你无需修改实际客户端代码，就能更改传递给客户端的工厂类，也能更改客户端代码接收的产品变体。  </p>
<p>假设客户端想要工厂创建一把椅子。客户端无需了解工厂类，也不用管工厂类创建出的椅子类型。无论是现代风格，还是维多利亚风格的椅子，对于客户端来说没有分别，它只需调用抽象椅子接口就可以了。这样一来，客户端只需知道椅子以某种方式实现了<code>sitOn</code>坐下方法就足够了。此外，无论工厂返回的是何种椅子变体，它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。  </p>
<p>最后一点说明：如果客户端仅接触抽象接口，那么谁来创建实际的工厂对象呢？一般情况下，应用程序会在初始化阶段创建具体工厂对象。而在此之前，应用程序必须根据配置文件或环境设定选择工厂类别。  </p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240228182719053.png" alt="image-20240228182719053"></p>
<ol>
<li><strong>抽象产品</strong>（<code>Abstract Product</code>）为构成系列产品的一组不同但相关的产品声明接口</li>
<li><strong>具体产品</strong>（<code>Concrete Product</code>）是抽象产品的多种不同类型实现。所有变体 (维多利亚/现代)都必须实现相应的抽象产品(椅子/沙发)</li>
<li><strong>抽象工厂</strong>（<code>Abstract Factory</code>）接口声明了一组创建各种抽象产品的方法</li>
<li><strong>具体工厂</strong>（<code>Concrete Factory</code>）实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体</li>
<li>尽管具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的抽象产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。客户端（Client）只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂/产品变体交互</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>跨平台 UI 类示例</p>
<p><img src="/posts/16062/image-20240228183848178.png" alt="image-20240228183848178"></p>
<p>应用程序启动后检测当前操作系统。根据该信息，应用程序通过与该操作系统对应的类创建工厂对象。其余代码使用该工厂对象创建UI元素。这样可以避免生成错误类型的元素。  </p>
<p>使用这种方法，客户端代码只需调用抽象接口，而无需了解具体工厂类和 UI元素。此外，客户端代码还支持未来添加新的工厂或UI元素 ，即每次在应用程序中添加新的UI元素变体时，你都无需修改客户端代码。你只需创建一个能够生成这些UI元素的工厂类，然后稍微修改应用程序的初始代码，使其能够选择合适的工厂类即可。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">	method <span class="title function_">createButton</span><span class="params">()</span> :Button</span><br><span class="line">	method <span class="title function_">createCheckbox</span><span class="params">()</span> :Checkbox</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进行实例化。</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>()</span><br><span class="line">  method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span> :Button is</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">  method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品由相应的具体工厂创建。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">// 根据windows样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">//根据macoS样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产品之间才能够正确地进行交互。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">//根据Windows样式渲染复选框。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">//根据macoS样式渲染复选框。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//客户端代码仅通过抽象类型（GUIFactory、Button 和Checkbox）使用工厂和产品，实现无需修改任何工厂或产品子类就能将其传递给客户端代码。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  <span class="keyword">private</span> field factory: GUIFactory</span><br><span class="line">  <span class="keyword">private</span> field button: Button</span><br><span class="line">  constructor <span class="title function_">Application</span><span class="params">(factory: GUIFactory)</span> is</span><br><span class="line">    <span class="built_in">this</span>.factory = factory</span><br><span class="line">  method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.button = factory.createButton()</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">    button.paint()  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初始化阶段）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">  method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">    <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(config.OS ==<span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">      <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WinFactory</span>()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Mac&quot;</span>) <span class="type">then</span></span><br><span class="line">      <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>（<span class="string">&quot;错误！未知的操作系统&quot;</span>）</span><br><span class="line">    </span><br><span class="line">    <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(factory)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p>如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂</p>
<blockquote>
<p>抽象工厂为你提供了一个接口，可用于创建每个系列产品的对象。只要代码通过该接口创建对象，那么你就不会生成与应用程序已生成的产品类型不一致的产品  </p>
</blockquote>
</li>
<li><p>如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式</p>
<blockquote>
<p>在设计良好的程序中，每个类仅负责一件事。如果一个类与多种类型产品交互，就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中 </p>
</blockquote>
</li>
</ol>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>以不同的产品类型与产品变体为维度绘制矩阵</li>
<li>为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口</li>
<li>声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法</li>
<li>为每种产品变体实现一个具体工厂类</li>
<li>在应用程序中开发初始化代码。该代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类</li>
<li>找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以确保同一工厂生成的产品相互匹配</li>
<li>你可以避免客户端和具体产品代码的耦合</li>
<li>单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护</li>
<li>开闭原则。向应用程序中引I入新产品变体时，你无需修改客户端代码</li>
</ul>
<hr>
<ul>
<li>由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂</li>
</ul>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且可以更方便地通过子类进行定制)，随后演化为使用<a href="# 抽象工厂">抽象工厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>(更灵活但更加复杂)。</li>
<li>生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。</li>
<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽象工厂来代替外观</li>
<li>你可以将抽象工厂和<a href="# 桥接">桥接</a>搭配使用。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性</li>
<li>抽象工厂、生成器和原型都可以用<a href="# 单例">单例</a>来实现  </li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote>
<p>建造者模式、Builder</p>
</blockquote>
<p><strong>生成器</strong>是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<h3 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设有这样一个复杂对象，在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中。甚至还有更糟糕的情况，那就是这些代码散落在客户端代码的多个位置。</p>
<p><img src="/posts/16062/image-20240306184615376.png" alt="image-20240306184615376"></p>
<p>例如，我们来思考如何创建一个 房屋<code>House</code>对象。建造一栋简单的房屋，首先你需要建造四面墙和地板，安装房门和一套窗户，然后再建造一个屋顶。但是如果你想要一栋更宽敞更明亮的房屋，还要有院子和其他设施（例如暖气、排水和供电设备），有如下两种简单的方法： </p>
<ol>
<li>最简单的方法是扩展 房屋 基类，然后<strong>创建一系列涵盖所有参数组合的子类</strong>。但最终你将面对相当数量的子类。任何新增的参数（例如门廊类型）都会让这个层次结构更加复杂。  </li>
<li>可以在 房屋 基类中创建一个包括所有可能参数的<strong>超级构造函数</strong>，并用它来控制房屋对象。这种方法确实可以避免生成子类，但它却会造成另外一个问题。  </li>
</ol>
<p><img src="/posts/16062/image-20240306184805162.png" alt="image-20240306184805162"></p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>生成器模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。  </p>
<p><img src="/posts/16062/image-20240306184900394.png" alt="image-20240306184900394"></p>
<p>该模式会将对象构造过程划分为一组步骤，比如<code>buildWalls</code>创建墙壁和 <code>buildDoor</code>创建房门等。每次创建对象时，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。 </p>
<p>当你需要创建不同形式的产品时，其中的一些构造步骤可能需要不同的实现。例如，木屋的房门可能需要使用木头制造，而城堡的房门则必须使用石头制造。</p>
<p>在这种情况下，你可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤。然后你就可以在创建过程中使用这些生成器（例如按顺序调用多个构造步骤）来生成不同类型的对象。  </p>
<p><strong>主管</strong></p>
<p>进一步可以将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。  </p>
<p>实际上，客户端代码可以直接以特定顺序调用创建步骤，但是主管的优势在于复用，即例行构造流程不需要每次都写一遍。并且，主管能够隐藏构造顺序。</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240306185309368.png" alt="image-20240306185309368"></p>
<ol>
<li><strong>生成器</strong>（Builder）接口声明在所有类型生成器中通用的产品构造步骤</li>
<li><strong>具体生成器</strong>（Concrete Builders）提供构造过程的不同实现。<br> 具体生成器也可以构造不遵循通用接口的产品</li>
<li><strong>产品</strong>（Products）是最终生成的对象。由不同生成器构造的<br> 产品无需属于同一类层次结构或接口</li>
<li><strong>主管</strong>（Director）类定义调用构造步骤的顺序，这样你就可以<br> 创建和复用特定的产品配置</li>
<li><strong>客户端</strong>（Client）必须将某个生成器对象与主管类关联。一<br> 般情况下，你只需通过主管类构造函数的参数进行一次性关<br> 联即可。此后主管类就能使用生成器对象完成后续所有的构<br> 造任务。但在客户端将生成器对象传递给主管类制造方法时<br> 还有另一种方式。在这种情况下，你在使用主管类生产产品<br> 时每次都可以使用不同的生成器</li>
</ol>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>分步骤制造汽车并制作对应型号用户使用手册的示例</p>
<p><img src="/posts/16062/image-20240306185840793.png" alt="image-20240306185840793"></p>
<p>汽车是一个复杂对象，有数百种不同的制造方法。我们没有在 汽车 类中塞入一个巨型构造函数，而是将汽车组装代码抽取到单独的汽车生成器类中。该类中有一组方法可用来配置汽车的各种部件  </p>
<p>如果客户端代码需要组装一辆与众不同、 精心调教的汽车，它可以直接调用生成器。或者，客户端可以将组装工作委托给主管类，因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个产品尽管没有同样的接口，但却相互关联。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> is</span><br><span class="line"><span class="comment">// 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车运动型轿车、SUV和敞篷车）可能会安装或启用不同的功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> is</span><br><span class="line">  <span class="comment">// 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 生成器接口声明了创建产品对象不同部件的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> is</span><br><span class="line">	method <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">  method <span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">  method <span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">  method <span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">  method <span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"><span class="comment">// 具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会有多个以不同方式实现的生成器变体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">  <span class="keyword">private</span> field car:Car</span><br><span class="line">  <span class="comment">// 一个新的生成器实例必须包含一个在后续组装过程中使用的空对象</span></span><br><span class="line">  constructor <span class="title function_">CarBuilder</span><span class="params">()</span> is</span><br><span class="line">  	<span class="built_in">this</span>.reset()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// reset（重置）方法可清除正在生成的对象。</span></span><br><span class="line">  method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 所有生成步骤都会与同一个产品实例进行交互。</span></span><br><span class="line">  method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 设置汽车座位的数量</span></span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 安装指定的引擎</span></span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 安装行车电脑</span></span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 安装GPS</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">  <span class="comment">// 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的准备。因此生成器实例通常会在 `getProduct（获取产品）`方法主体末尾调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确调用重置方法后再去处理之前的结果。</span></span><br><span class="line">  method <span class="title function_">getProduct</span><span class="params">()</span>:Car <span class="type">is</span></span><br><span class="line">    <span class="variable">product</span> <span class="operator">=</span> <span class="built_in">this</span>.car</span><br><span class="line">    <span class="built_in">this</span>.reset()</span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">  <span class="keyword">private</span> field manual:Manual</span><br><span class="line">  constructor <span class="title function_">CarManualBuilder</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.reset()</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.manual = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 添加关于汽车座椅功能的文档。</span></span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">		<span class="comment">// 添加关于引擎的介绍。</span></span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">		<span class="comment">// 添加关于行车电脑的介绍。</span></span><br><span class="line"></span><br><span class="line">	method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">		<span class="comment">// 添加关于 GPS 的介绍。</span></span><br><span class="line"></span><br><span class="line">	method <span class="title function_">getProduct</span><span class="params">()</span>:Manual is</span><br><span class="line">		<span class="comment">// 返回使用手册并重置生成器。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并不是必需的。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> is</span><br><span class="line">  <span class="keyword">private</span> field builder:Builder</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通过这种方式改变最新组装完毕的产品的最终类型。</span></span><br><span class="line">  method <span class="title function_">setBuilder</span><span class="params">(builder:Builder)</span></span><br><span class="line">    <span class="built_in">this</span>.builder = builder</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主管可使用同样的生成步骤创建多个产品变体</span></span><br><span class="line">  method <span class="title function_">constructSportsCar</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">    builder.reset()</span><br><span class="line">    builder.setSeats(<span class="number">2</span>)</span><br><span class="line">		builder.setEngine(<span class="keyword">new</span> <span class="title class_">SportEngine</span>())</span><br><span class="line">		builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">    builder.setGPS(<span class="literal">true</span>)</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">constructSUV</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果将需要从生成器对象中获取。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">makeCar</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line">  	<span class="type">CarBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">  	director.constructSportsCar(builder)</span><br><span class="line">  	<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> builder.getProduct()</span><br><span class="line">  	<span class="type">CarManualBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">  	director.constructSportsCar(builder)</span><br><span class="line">  	<span class="comment">// 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和产品的存在，也不会对其产生依赖。</span></span><br><span class="line">  	<span class="type">Manual</span> <span class="variable">manual</span> <span class="operator">=</span> builder.getProduct()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>使用生成器模式可避免重叠构造函数</strong></p>
<p>  假设你的构造函数中有十个可选参数，那么调用该函数会非常不方便；因此，你需要重载这个构造函数，新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数，传递一些默认数值来替代省略掉的参数。</p>
<p>  生成器模式让你可以分步骤生成对象，而且允许你仅使用必须的步骤。应用该模式后，你再也不需要将几十个参数塞进构造函数里了。</p>
</li>
<li><p><strong>使用代码创建不同形式的产品（例如石头或木头房</strong><br>  <strong>屋）时，可使用生成器模式</strong></p>
<p>  如果你需要创建的各种形式的产品，它们的制造过程相似且仅有细节上的差异，此时可使用生成器模式</p>
<p>  基本生成器接口中定义了所有可能的制造步骤，具体生成器将实现这些步骤来制造特定形式的产品。同时，主管类将负责管理制造步骤的顺序。</p>
</li>
<li><p><strong>使用生成器构造组合树或其他复杂对象</strong></p>
<p>  生成器模式让你能分步骤构造产品。你可以延迟执行某些步骤而不会影响最终产品。你甚至可以递归调用这些步骤，这在创建对象树时非常方便。</p>
<p>  生成器在执行制造步骤时，不能对外发布未完成的产品。这可以避免客户端代码获取到不完整结果对象的情况。</p>
</li>
</ul>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>清晰地定义通用步骤， 确保它们可以制造所有形式的产品。否则你将无法进一步实施该模式。</p>
</li>
<li><p>在基本生成器接口中声明这些步骤。</p>
</li>
<li><p>为每个形式的产品创建具体生成器类，并实现其构造步骤。</p>
<p> 不要忘记实现获取构造结果对象的方法。你不能在生成器接口中声明该方法，因为不同生成器构造的产品可能没有公共接口，因此你就不知道该方法返回的对象类型。但是，如果所有产品都位于单一类层次中，你就可以安全地在基本接口中添加获取生成对象的方法。  </p>
</li>
<li><p>考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。 </p>
</li>
<li><p>客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需调用主管类构造函数一次即可。主管类使用生成器对象完成后续所有制造任务。还有另一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。</p>
</li>
<li><p>只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则，客户端应当通过生成器获取构造结果。</p>
</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时，你可以复用相同的制造代码。</li>
<li>单一职责原则。你可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<hr>
<ul>
<li>由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。</li>
</ul>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且<br>  可以更方便地通过子类进行定制），随后演化为使用<a href="# 抽象工厂">抽象工<br>  厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>（更灵活但更加复杂）。</li>
<li>生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。</li>
<li>你可以在创建复杂<a href="# 组合">组合树</a>时使用生成器，因为这可使其构造步骤以递归的方式运行。</li>
<li>你可以结合使用生成器和<a href="# 桥接">桥接</a>模式： 主管类负责抽象工作，各种不同的生成器负责实现工作。  </li>
<li>抽象工厂、生成器和原型都可以用<a href="# 单例">单例</a>来实现。</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><blockquote>
<p>克隆、Clone、Prototype  </p>
</blockquote>
<p>原型是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类</p>
<h3 id="问题背景-3"><a href="#问题背景-3" class="headerlink" title="问题背景"></a>问题背景</h3><p>如果你有一个对象，并希望生成与其完全相同的一个复制品，你该如何实现呢？首先，你必须新建一个属于相同类的对象。然后，你必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。但是并非所有对象都能通过这种方式进行复制，因为有些对象可能拥有私有成员变量，它们在对象本身以外是不可见的。</p>
<p>此外，直接复制还有另外一个问题。因为你必须知道对象所属的类才能创建复制品，所以代码必须依赖该类。即使你可以接受额外的依赖性，那还有另外一个问题：有时你只知道对象所实现的接口，而不知道其所属的具体类，比如<strong>可向方法的某个参数传入实现了某个接口的任何对象（你只知道接口而不知道类）</strong>。  </p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个 克隆 方法。</p>
<p>所有的类对 克隆 方法的实现都非常相似。该方法会创建一个当前类的对象，然后将原始对象所有的成员变量值复制到新建的类中。你甚至可以复制私有成员变量，因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。  </p>
<p>支持克隆的对象即为原型。当你的对象有几十个成员变量和几百种类型时，对其进行克隆甚至可以代替子类的构造。  </p>
<p>其运作方式如下：创建一系列不同类型的对象并不同的方式对其进行配置。如果所需对象与预先配置的对象相同，那么你只需克隆原型即可，无需新建一个对象。  </p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><strong>基本实现</strong></p>
<p><img src="/posts/16062/image-20240311192308784.png" alt="image-20240311192308784" style="zoom:50%;"></p>
<ol>
<li><strong>原型</strong>（Prototype）接口将对克隆方法进行声明。在绝大多数情况下，其中只会有一个名为<code>clone</code>的方法</li>
<li><strong>具体原型</strong>（Concrete Prototype）类将实现克隆方法。除了将原始对象的数据复制到克隆体中之外，该方法有时还需处理克隆过程中的极端情况，例如克隆关联对象和梳理递归依赖等等。  </li>
<li><strong>客户端</strong>（Client）可以复制实现了原型接口的任何对象。  </li>
</ol>
<p><strong>原型注册表实现</strong></p>
<p><img src="/posts/16062/image-20240311193232360.png" alt="image-20240311193232360" style="zoom:50%;"></p>
<ol>
<li><strong>原型注册表</strong>（Prototype Registry）提供了一种访问常用原型的简单方法，其中存储了一系列可供随时复制的预生成对象。最简单的注册表原型是一个 名称 → 原型 的哈希表。 但如果需要使用名称以外的条件进行搜索，你可以创建更加完善的注册表版本。  </li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>原型模式能让你生成完全相同的几何对象副本，同时无需代码与对象所属类耦合</p>
<p><img src="/posts/16062/image-20240311193454637.png" alt="image-20240311193454637" style="zoom:50%;"></p>
<p>所有形状类都遵循同一个提供克隆方法的接口。在复制自身成员变量值到结果对象前，子类可调用其父类的克隆方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础原型。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> is</span><br><span class="line">	field X: <span class="type">int</span></span><br><span class="line">	field Y: <span class="type">int</span></span><br><span class="line">	field color: string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规构造函数。</span></span><br><span class="line">constructor <span class="title function_">Shape</span><span class="params">()</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="line">constructor <span class="title function_">Shape</span><span class="params">(source: Shape)</span> is</span><br><span class="line">  <span class="title function_">this</span><span class="params">()</span></span><br><span class="line">  <span class="built_in">this</span>.X = source.X</span><br><span class="line">  <span class="built_in">this</span>.Y = source.Y</span><br><span class="line">  <span class="built_in">this</span>.color = source.color</span><br><span class="line">  </span><br><span class="line"><span class="comment">// clone（克隆）操作会返回一个形状子类。</span></span><br><span class="line"><span class="keyword">abstract</span> method <span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span><br><span class="line">  <span class="comment">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span><br><span class="line">  <span class="comment">// 成的克隆对象。这可以保持克隆结果的一致。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">  field width: <span class="type">int</span></span><br><span class="line">  field height: <span class="type">int</span></span><br><span class="line">  	</span><br><span class="line">  constructor <span class="title function_">Rectangle</span><span class="params">(source: Rectangle)</span> is</span><br><span class="line">    <span class="comment">// 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span><br><span class="line">    <span class="built_in">super</span>(source)</span><br><span class="line">    <span class="built_in">this</span>.width = source.width</span><br><span class="line">    <span class="built_in">this</span>.height = source.height</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">	field radius: <span class="type">int</span></span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Circle</span><span class="params">(source: Circle)</span> is</span><br><span class="line">		<span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">		<span class="built_in">this</span>.radius = source.radius</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码中的某个位置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">	field shapes: array of Shape</span><br><span class="line">	constructor <span class="title function_">Application</span><span class="params">()</span> is</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>()</span><br><span class="line">		circle.X = <span class="number">10</span></span><br><span class="line">		circle.Y = <span class="number">10</span></span><br><span class="line">		circle.radius = <span class="number">20</span></span><br><span class="line">		shapes.add(circle)</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">anotherCircle</span> <span class="operator">=</span> circle.clone()</span><br><span class="line">		shapes.add(anotherCircle)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内容完全一样。</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>()</span><br><span class="line">    rectangle.width = <span class="number">10</span></span><br><span class="line">    rectangle.height = <span class="number">20</span></span><br><span class="line">    shapes.add(rectangle)</span><br><span class="line">    </span><br><span class="line">method <span class="title function_">businessLogic</span><span class="params">()</span> is</span><br><span class="line">	<span class="comment">// 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与其完全相同的复制品。</span></span><br><span class="line">	<span class="type">Array</span> <span class="variable">shapesCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span> of Shapes.</span><br><span class="line">  <span class="comment">// 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="line">  foreach (s in shapes) <span class="keyword">do</span></span><br><span class="line">  	shapesCopy.add(s.clone())</span><br><span class="line">  <span class="comment">// `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有子元素的复制品。</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式</p>
<p>  这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。即使不考虑代码耦合的情况，你的代码也不能依赖这些对象所属的具体类，因为你不知道它们的具体信息</p>
<p>  原型模式为客户端代码提供一个通用接口，客户端代码可通过这一接口与所有实现了克隆的对象进行交互，它也使得客户端代码与其所克隆的对象具体类独立开来。    </p>
</li>
<li><p>如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象</p>
<p>  在原型模式中，你可以使用一系列预生成的、各种类型的对象作为原型</p>
<p>  客户端不必根据需求对子类进行实例化，只需找到合适的原型并对其进行克隆即可</p>
</li>
</ul>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>创建原型接口，并在其中声明 克隆 方法。如果你已有类层次结构，则只需在其所有类中添加该方法即可</p>
</li>
<li><p>原型类必须另行定义一个以该类对象为参数的构造函数。构造函数必须复制参数对象中的所有成员变量值到新建实体中。如果你需要修改子类，则必须调用父类构造函数，让父类复制其私有成员变量值。</p>
<p> 如果编程语言不支持方法重载，那么你可能需要定义一个特殊方法来复制对象数据。在构造函数中进行此类处理比较方便，因为它在调用 <code>new</code> 运算符后会马上返回结果对象  </p>
</li>
<li><p>克隆方法通常只有一行代码：使用 <code>new</code> 运算符调用原型版本的构造函数。注意，每个类都必须显式重写克隆方法并使用自身类名调用 <code>new</code> 运算符。否则，克隆方法可能会生成父类的对象</p>
</li>
<li><p>你还可以创建一个中心化原型注册表，用于存储常用原型</p>
<p> 你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法。该方法必须能够根据客户端代码设定的条件进行搜索。搜索条件可以是简单的字符串，或者是一组复杂的搜索参数。找到合适的原型后，注册表应对原型进行克隆，并将复制生成的对象返回给客户端。</p>
<p> 最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</p>
</li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以克隆对象，而无需与它们所属的具体类相耦合</li>
<li>你可以克隆预生成原型，避免反复运行初始化代码</li>
<li>你可以更方便地生成复杂对象</li>
<li>你可以用继承以外的方式来处理复杂对象的不同配置</li>
</ul>
<hr>
<ul>
<li>克隆包含循环引用的复杂对象可能会非常麻烦</li>
</ul>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用<a href="￥ 抽象工厂">抽象工厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>
<li>原型可用于保存命令的历史记录。</li>
<li>大量使用组合和装饰的设计通常可从对于原型的使用中获益。</li>
<li>你可以通过该模式来复制复杂结构，而非从零开始重新构造。</li>
<li>原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承，但是它不需要初始化步骤。</li>
<li>有时候原型可以作为<a href="# 备忘录">备忘录</a>的一个简化版本，其条件是你需要在历史记录中存储的对象的状态比较简单，不需要链接其他外部资源，或者链接可以方便地重建。抽象工厂、生成器和原型都可以用单例来实现。</li>
</ul>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><blockquote>
<p>单件模式、Singleton</p>
</blockquote>
<p>单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<h3 id="问题背景-4"><a href="#问题背景-4" class="headerlink" title="问题背景"></a>问题背景</h3><ol>
<li><p><strong>保证一个类只有一个实例。</strong>为什么会有人想要控制一个类所<br> 拥有的实例数量？最常见的原因是控制某些共享资源（例如<br> 数据库或文件）的访问权限</p>
</li>
<li><p><strong>为该实例提供一个全局访问节点。</strong>还记得那些存储重要对象的全局变量吗？它们在使用上十分方便，但同时也非常不安全，因为任何代码都有可能覆盖掉那些变量的内容，从而引发程序崩溃</p>
<p> 和全局变量一样，单例模式也允许在程序的任何地方访问特定对象。但是它可以保护该实例不被其他代码覆盖。</p>
</li>
</ol>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>所有单例的实现都包含以下两个相同的步骤：  </p>
<ol>
<li>将默认构造函数设为私有， 防止其他对象使用单例类的 <code>new</code> 运算符。</li>
<li>新建一个静态构建方法作为构造函数。该函数会调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ol>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240312180931884.png" alt="image-20240312180931884"></p>
<ol>
<li><p><strong>单例</strong>（Singleton）类声明了一个名为 <code>getInstance</code> 获取实<br> 例 的静态方法来返回其所属类的一个相同实例。</p>
<p> 单例的构造函数必须对客户端（Client） 代码隐藏。 调用<br> 获取实例 方法必须是获取单例对象的唯一方式</p>
</li>
</ol>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>数据库连接类即是一个单例，该类不提供公有构造函数，因此获取该对象的唯一方式是调用 获取实例 方法。该方法将缓存首次生成的对象，并为所有后续调用返回该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处都能访问相同的数据库连接实例。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">  <span class="comment">// 保存单例实例的成员变量必须被声明为静态类型。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line">  <span class="comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构造方法。</span></span><br><span class="line">  <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">   <span class="comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于控制对单例实例的访问权限的静态方法。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">			<span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line"> 				<span class="comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span></span><br><span class="line"> 				<span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line"> 					Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line"> 		<span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span></span><br><span class="line">   <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">   <span class="comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以在这里添加限流或缓冲逻辑。</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">    <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">    foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">    bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">    <span class="comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</p>
<p>  单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。该方法可以创建一个新对象，但如果该对象已经被创建，则返回已有的对象</p>
</li>
<li><p>如果你需要更加严格地控制全局变量，可以使用单例模式</p>
<p>  单例模式与全局变量不同，它保证类只存在一个实例。除了单例类自己以外，无法通过任何方式替换缓存的实例</p>
<p>  请注意， 你可以随时调整限制并设定生成单例实例的数量，只需修改 获取实例 方法， 即 <code>getInstance</code> 中的代码即可实现</p>
</li>
</ul>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>在类中添加一个私有静态成员变量用于保存单例实例。</li>
<li>声明一个公有静态构建方法用于获取单例实例。</li>
<li>在静态方法中实现”延迟初始化”。该方法会在首次被调用时创建一个新对象，并将其存储在静态成员变量中。此后该方法每次被调用时都返回该实例。</li>
<li>将类的构造函数设为私有。类的静态方法仍能调用构造函数，但是其他对象不能调用。</li>
<li>检查客户端代码，将对单例的构造函数的调用替换为对其静态构建方法的调用。</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以保证一个类只有一个实例</li>
<li>你获得了一个指向该实例的全局访问节点</li>
<li>仅在首次请求单例对象时对其进行初始化</li>
</ul>
<hr>
<ul>
<li>违反了单一职责原则。该模式同时解决了两个问题（实例唯一、全局访问）。</li>
<li>单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。</li>
<li><strong>单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不编写测试代码，或者不使用单例模式。</strong></li>
</ul>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 外观">外观</a>类通常可以转换为<a href="# 单例">单例</a>类，因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个<a href="# 享元">享元</a>对象，那么享元就和单例类似了。但这两个模式有两个根本性的不同。<ul>
<li>只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。享元对象是不可变的。</li>
</ul>
</li>
<li><a href="# 抽象工厂">抽象工厂</a>、<a href="# 生成器">生成器</a>和<a href="# 原型">原型</a>都可以用单例来实现。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/" rel="tag"># 开发进阶知识</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/12321.html" rel="next" title="设计模式-SOLID原则">
                <i class="fa fa-chevron-left"></i> 设计模式-SOLID原则
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/18127.html" rel="prev" title="设计模式-结构型模式">
                设计模式-结构型模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            


            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xzp314" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:seu_xuzhipeng@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">工厂方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="nav-number">1.2.</span> <span class="nav-text">抽象工厂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="nav-number">1.2.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="nav-number">1.2.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-1"><span class="nav-number">1.2.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">1.3.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-2"><span class="nav-number">1.3.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.3.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-2"><span class="nav-number">1.3.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="nav-number">1.3.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-2"><span class="nav-number">1.3.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-3"><span class="nav-number">1.4.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-3"><span class="nav-number">1.4.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">1.4.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-3"><span class="nav-number">1.4.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-3"><span class="nav-number">1.4.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-3"><span class="nav-number">1.4.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B"><span class="nav-number">1.5.</span> <span class="nav-text">单例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84-4"><span class="nav-number">1.5.3.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81-4"><span class="nav-number">1.5.4.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">1.5.5.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-4"><span class="nav-number">1.5.6.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-4"><span class="nav-number">1.5.7.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB-4"><span class="nav-number">1.5.8.</span> <span class="nav-text">与其他模式的关系</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Zhipeng</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">221.7k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
