<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DBMS-体系结构</title>
    <url>/posts/97.html</url>
    <content><![CDATA[<h3 id="内部组成结构"><a href="#内部组成结构" class="headerlink" title="内部组成结构"></a>内部组成结构</h3><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核【只接受SQL语句】</p>
<p><img src="/posts/97/image-20220411102315878.png" alt="image-20220411102315878"></p>
<p>左<strong>：</strong>语句<strong>→</strong>语法树<strong>→</strong>权限检查<strong>→</strong>系统调用<strong>→</strong>I/O操作</p>
<p>右<strong>：</strong>操作结果返回</p>
<ul>
<li>编译器（语法分析器）</li>
<li>授权检查</li>
<li>语义分析和查询处理</li>
<li>访问管理、并发控制、恢复模块【物理层】<ul>
<li>实现了关系模型的各种概念</li>
<li>将对表、视图、元组、属性的操作转换为对文件的操作</li>
<li>直接和操作系统打交道，访问原语</li>
</ul>
</li>
</ul>
<p>UFI 提供给用户的即席访问接口</p>
<p>API 由数据库系统提供给数据库的各种使用方法</p>
<h3 id="运行状态下的进程结构"><a href="#运行状态下的进程结构" class="headerlink" title="运行状态下的进程结构"></a>运行状态下的进程结构</h3><h4 id="单进程结构"><a href="#单进程结构" class="headerlink" title="单进程结构"></a>单进程结构</h4><p><img src="/posts/97/image-20220322193544101.png" alt="image-20220322193544101" style="zoom:50%;"></p>
<p>把应用程序的代码和DBMS核心代码连接在一起，运行后就是一个单一的进程</p>
<h4 id="多进程结构"><a href="#多进程结构" class="headerlink" title="多进程结构"></a>多进程结构</h4><p>【满足多用户多任务】</p>
<p><img src="/posts/97/image-20220411102412196.png" alt="image-20220411102412196" style="zoom:50%;"></p>
<p>单机：pipe，网络环境：socket</p>
<ul>
<li><p>将DBMS核心进程和应用程序的进程分开，当应用进程要访问数据库时，应用程序的进程进程CONNECT时向系统发出请求，系统建立一个对应的DBMS核心进程，并在两个进程间建立通信的管道。</p>
<ul>
<li><p>问题：</p>
<ul>
<li>当系统访问的应用程序很多时，会导致由过多的DBMS核心进程，会导致电脑的性能变差</li>
</ul>
</li>
<li><p>为了解决此问题，创建线程</p>
<ul>
<li><p>轻量级进程，同一进程空间内运行多个线程，这些线程共享父进程的资源</p>
<p><strong>↓</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多线程结构"><a href="#多线程结构" class="headerlink" title="多线程结构"></a>多线程结构</h4><ul>
<li><p>DBMS进程的结构</p>
<p><img src="/posts/97/image-20220411102441049.png" alt="image-20220411102441049" style="zoom:50%;"></p>
</li>
<li><p>公共空间 共享</p>
<ul>
<li>DAEMON线程 守护<ul>
<li>监听数据库连接请求的端口号</li>
<li>为成功建立连接的应用程序建立DBMS核心线程</li>
</ul>
</li>
<li>catlog 目录<ul>
<li>关于数据的数据</li>
<li>查目录可以知道有没有这张表</li>
</ul>
</li>
<li>locktable 封锁表<ul>
<li>用来控制对锁的申请</li>
</ul>
</li>
<li>buffer 缓冲区<ul>
<li>查询优化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程-进程间通讯协议"><a href="#线程-进程间通讯协议" class="headerlink" title="线程/进程间通讯协议"></a>线程/进程间通讯协议</h4><p><img src="/posts/97/image-20220411102625234.png" alt="image-20220411102625234" style="zoom:50%;"></p>
<h5 id="阻抗不匹配问题"><a href="#阻抗不匹配问题" class="headerlink" title="阻抗不匹配问题"></a>阻抗不匹配问题</h5><ul>
<li><p>关系型数据库对数据的处理是以集合为单位的，基础是集合论</p>
</li>
<li><p>程序设计语言是以变量为单位的</p>
<p>那么集合如何转换为变量？</p>
<p>Cursor游标，循环处理查询结果</p>
</li>
</ul>
<h5 id="返回结果的格式"><a href="#返回结果的格式" class="headerlink" title="返回结果的格式"></a>返回结果的格式</h5><p><img src="/posts/97/image-20220411102751001.png" alt="image-20220411102751001" style="zoom:50%;"></p>
<p><img src="/posts/97/image-20220411102811522.png" alt="image-20220411102811522" style="zoom:50%;"></p>
<h4 id="分布式数据库管理系统核心"><a href="#分布式数据库管理系统核心" class="headerlink" title="分布式数据库管理系统核心"></a>分布式数据库管理系统核心</h4><p><img src="/posts/97/image-20220411102906379.png" alt="image-20220411102906379" style="zoom:50%;"></p>
<h5 id="查询优化示例"><a href="#查询优化示例" class="headerlink" title="查询优化示例"></a>查询优化示例</h5><p><img src="/posts/97/image-20220411102931004.png" alt="image-20220411102931004" style="zoom:50%;"></p>
<h4 id="分布式数据库的多线程结构"><a href="#分布式数据库的多线程结构" class="headerlink" title="分布式数据库的多线程结构"></a>分布式数据库的多线程结构</h4><p><img src="/posts/97/image-20220411103014322.png" alt="image-20220411103014322"></p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-引言</title>
    <url>/posts/57766.html</url>
    <content><![CDATA[<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>一个大规模集成的数据集合。</p>
<p>作用：</p>
<p>一个数据库是对现实生活中一个企业或一个单位在计算机中的建模结果</p>
<ul>
<li>实体</li>
<li>联系（实体间的关系）</li>
</ul>
<h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><p>DBMS——用来存储和管理数据库的一种系统软件。</p>
<h4 id="文件-vs-数据库"><a href="#文件-vs-数据库" class="headerlink" title="文件 vs 数据库"></a>文件 vs 数据库</h4><ul>
<li>数据库可以通过DBMS直接进行很多操作，而文件的话只提供了简单的操作。</li>
<li>用文件的话，要针对不同的文件结构编写不同的代码。</li>
<li>由于实际应用中并发同时访问导致数据访问不一致。【文件没有解决办法，需要在应用软件层解决，而DBMS中有】</li>
<li>故障处理【文件系统不具备这个能力，但DBMS会自动恢复】</li>
<li>安全和访问控制</li>
</ul>
<p>数据库系统建立在文件系统之上。</p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul>
<li>用来描述现实世界的一种符号</li>
<li>是信息存在的形式</li>
</ul>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><ul>
<li>用来描述数据的一组概念</li>
<li>用来描述现实世界的一种建模方法</li>
</ul>
<h4 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h4><ul>
<li>用一种给定的数据模型对一个特定的企业进行描述得到的结果就是数据模式</li>
</ul>
<p><strong>学生选课管理数据库</strong></p>
<ul>
<li>概念模式：<ul>
<li>学生（学号，名字，年龄，GPA）</li>
<li>课程（课程号，课程名）</li>
<li>选课关系（学号，课程号，成绩）</li>
</ul>
</li>
<li>物理模式：<ul>
<li>用堆文件形式存储这三张表</li>
<li>在学生的某项信息中建立索引</li>
</ul>
</li>
<li>外模式：<ul>
<li>课程信息表（课程号，选课人数）</li>
</ul>
</li>
</ul>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p><strong>1NF</strong> </p>
<p>第一范式</p>
<p>不支持表中套表</p>
<p>关系中的每一个元组必须是原子【即不可再分】</p>
<p><img src="/posts/57766/image-20220405201338202.png" alt="image-20220405201338202" style="zoom:33%;"></p>
<p>分解Address</p>
<p><strong>2NF</strong></p>
<p> 第二范式</p>
<p>数据库设计时，设计出来的表满足一范式，并且该表内不存在属性对主键的部分函数依赖</p>
<p>例子：</p>
<p>若属性由（学号、姓名、班级、课程号、成绩）五个属性组成，其中（学号，课程号）共同组成主键。</p>
<ul>
<li>此时不满足二范式。</li>
<li>其中的姓名和班级，只需要依赖主键中的学号而不需要课程号就可以得到</li>
</ul>
<p>不满足2范式容易出现的问题：</p>
<ul>
<li><p>插入异常</p>
<p>上例中，不能插入一个还未选课的学生的信息，逐渐不能为空</p>
</li>
<li><p>删除异常</p>
<p>上例中，如果一个学生申请休学，把选过的课退了，那么他的信息也会被删除</p>
</li>
<li><p>更新异常</p>
<p>更新中难以保持数据的一致性，上例的设计有大量的数据冗余</p>
<p>每次更新学生数据，每一个选课记录都得改</p>
</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>设计时，一事一地。<ul>
<li>一张表只管一件事情</li>
<li>可以分解为学号-课程号-成绩和学号-姓名-班级两张表</li>
</ul>
</li>
</ul>
<p><strong>3NF</strong> </p>
<p>第三范式</p>
<p>在满足二范式的前提下，不存在属性对主键的传递依赖。</p>
<p><strong>例子</strong></p>
<p>若属性由（职工编号、工资级别、工资）三个属性组成，其中（职工编号）为主键。</p>
<p><strong>分析</strong></p>
<p>工资取决于工资级别，工资级别取决于职工编号</p>
<p><strong>问题</strong></p>
<ul>
<li>插入异常：当一个人的工资级别还没定的时候，他对应的工资也没有</li>
<li>删除异常：3级工资的人只有一个，若删除，会把对应的工资级别信息也删除了</li>
<li>更新异常：数据内有大量的冗余，1级工资对应1000元，会重复很多次，修改也很麻烦</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>设计时，一事一地。<ul>
<li>一张表只管一件事情</li>
<li>一张职工编号-职工等级表，一张职工等级-工资表</li>
</ul>
</li>
</ul>
<p><strong>4NF</strong></p>
<ul>
<li>在满足三范式的前提下，消除多值依赖</li>
</ul>
<p><strong>5NF</strong></p>
<ul>
<li>在满足四范式的前提下，消除连接依赖</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-并发</title>
    <url>/posts/23083.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="并发效用"><a href="#并发效用" class="headerlink" title="并发效用"></a>并发效用</h4><p>并发就是在一个多任务系统中允许多事务同时访问数据库</p>
<ul>
<li><p>并发提高响应时间和系统资源利用率</p>
</li>
<li><p>不同事务可能会访问数据库的不同部分，完全可以并行运行</p>
<p>但是需要对事务的并发运行进行管理，防止出现以下问题：</p>
<ul>
<li>读写冲突</li>
<li>写写冲突</li>
</ul>
</li>
</ul>
<h4 id="任意并发后果"><a href="#任意并发后果" class="headerlink" title="任意并发后果"></a>任意并发后果</h4><ol>
<li><p>丢失更新(write-write 绝对杜绝)</p>
<p><img src="/posts/23083/image-20220401192646289.png" alt="image-20220401192646289" style="zoom:33%;"></p>
<p>按照如图所示的调度，最后$x$变成了$2x$，但是实际上要么应该是$2x+1$，要么是$2(x+1)$</p>
</li>
<li><p>读脏数据(write-read 可容忍)<a name="读脏数据"> </a></p>
<p><img src="/posts/23083/image-20220401192820847.png" alt="image-20220401192820847" style="zoom:33%;"></p>
<p>读完$t$数组$x$属性的数据后，对$t$进行了写操作，再读$y$属性，然后$T_1$rollback，导致的$t[y]$变成脏数据，和数据库内的数据不一致</p>
<p><strong>$x$和$y$属性的数据不是同一时刻的数据</strong></p>
<p>有可能出现恢复时的多米诺现象 <a name="多米诺"> </a></p>
<p><img src="/posts/23083/image-20230823153430481.png" alt="image-20230823153430481"></p>
<p>x y z都要滚回了</p>
</li>
</ol>
<ol>
<li><p>不可重复的读取(read-write 可容忍)<a name="不可重复读"> </a></p>
<p><img src="/posts/23083/image-20220401192908416.png" alt="image-20220401192908416" style="zoom:33%;"></p>
<p>前后读取x的数据不一致，能够感知到数据被修改了，$T_1$事务执行了两次读操作，数据不一样，而不是两个事务读，数据不一样，需要注意啥叫不可重复的读取</p>
</li>
</ol>
<h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>判断并发事务运行结果是否正确</p>
<ul>
<li>按照系统并行运行事务随机调度的运行结果和按照某种串行顺序的运行结果相同，那么说明是可串行化的。</li>
<li>如果调度是可串行化的，那么调度是正确的</li>
<li>也就是说$n$个事务的并发运行的正确结果有$n!$种，串行序列是其中一个，只要是其中一种就行，比如上面说的不管是$2x+1$还是$2(x+1)$都可以</li>
</ul>
<h4 id="等价-equivalent"><a href="#等价-equivalent" class="headerlink" title="等价(equivalent)"></a>等价(equivalent)</h4><h5 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h5><p>调度-表示执行并发事务指令的时间顺序的序列。</p>
<ul>
<li>一组事务的调度必须包括这些事务的所有指令</li>
<li>必须保持每个事务中指令出现的顺序</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="/posts/23083/image-20220511201803636.png" alt="image-20220511201803636" style="zoom: 50%;"><img src="/posts/23083/image-20220511202001401.png" alt="image-20220511202001401" style="zoom: 50%;"></p>
<p>$T_1$:从A转账50元给B</p>
<p>$T_2$:从A转账资产的10%给B</p>
<p>上述左边的调度先做$T_1$再做$T_2$，是串行调度；右边是并行调度</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ol>
<li><p>view equivalent</p>
<p>目标等价，$S$和$S’$是同一组事务的不同调度，如果执行完毕后两者对数据库的影响一致，那么就是目标等价</p>
</li>
<li><p>conflict equivalent</p>
<ul>
<li>冲突操作($R-W~W-W$)的顺序将影响执行的效果</li>
<li>非冲突操作<ul>
<li>$R-R$</li>
<li>即使有写操作，所操作的数据项不同。如$R_i(x)$和$W_j(y),i$事务对$x$做读操作，$j$事务对$y$做写操作</li>
</ul>
</li>
</ul>
<p>冲突等价，如果一个调度$S$可以通过一系列非冲突相邻操作的交换而转化为一个调度$S’$，我们说$S$和$S’$是冲突等价的。</p>
</li>
</ol>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ol>
<li><p>$S$和$S’$是冲突等价，那么必然是目标等价，反之不一定<a name="目标冲突"></a></p>
</li>
<li><p>串行化可以分为目标可串行化和冲突可串行化</p>
<p>一组并发运行的事务是和该组事务的某个串行执行序列是目标等价的，那么就是目标序列化，同理，冲突可串行化也是如此</p>
<p>假设有$\{T_1,T_2,T_3\}$三个事务</p>
<p>$s = R_2(x)W_3(x)R_1(y)W_2(y) → R_1(y)R_2(x)W_2(y)W_3(x) = s’$</p>
<p>$R_1(y)$和$W_3(x)$交换得到$R_2(x)R_1(y)W_3(x)W_2(y)$</p>
<p>$W_3(x)$和$W_2(y)$交换得到$R_2(x)R_1(y)W_2(y)W_3(x)$</p>
<p>$R_2(x)$和$R_1(y)$交换得到$R_1(y)R_2(x)W_2(y)W_3(x)$</p>
</li>
</ol>
<p>   冲突可串行化，因为$s’$是一个串行执行序列</p>
<p>   <strong>目标等价不一定是冲突等价的示例</strong></p>
<pre><code>$s = R_1(x)W_2(x)W_1(x)W_3(x)$
</code></pre><p>   两两之间都是冲突，交换不了，不是冲突可串行化</p>
<p>   但是与$s’ = R_1(x)W_1(x)W_2(x)W_3(x)$是目标等价</p>
<p>   最后都是读了一开始的x，更新也是以$W_3$为准，目标可串行化</p>
<p>目标等价的测试算法是一个NP问题，而冲突序列化涵盖了可序列化事务的大多数实例，所以我们在后面的部分所说的序列化如果没有特别说明，就会指向冲突序列化。</p>
<h4 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>判断是否是可串行化的调度</p>
<p>$G=<V,E>$，有向图</V,E></p>
<ol>
<li>$V$-节点集合，包括所有的事务</li>
<li>$E$-边集合，通过分析冲突操作来定义，只要满足以下条件之一，就构建$T_i→T_j$:<ol>
<li>$R_i(x)$在$W_j(x)$之前</li>
<li>$W_i(x)$在$R_j(x)$之前</li>
<li>$W_i(x)$在$W_j(x)$之前</li>
</ol>
</li>
</ol>
<p>检查前序图中是否存在环，有环则不可串行化</p>
<h5 id="寻找串行化调度"><a href="#寻找串行化调度" class="headerlink" title="寻找串行化调度"></a>寻找串行化调度</h5><p>拓扑排序的思路</p>
<ol>
<li>如果没有环路，说明肯定存在节点入度为0，将这些节点放入队列，删除这些节点以及对应的出边</li>
<li>更新图的入度，重复1，将新的入度为0的节点删除</li>
<li>直到所有节点都被纳入队列</li>
</ol>
<p>队列就是等价的串行队列</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>事务： ${T_1,T_2,T_3,T_4}$</p>
<p>语句：$s = W<br>_3(y)R_1(x)R_2(y)W_3(x)W_2(x)W_3(z)R_4(z)W_4(x)$</p>
<p>$W_3(y) → R_2(y)=&gt;3→2$</p>
<p>$R_1(x) → W_3(x)=&gt;1→3$</p>
<p>$R_1(x) → W_2(x)=&gt;1→2$</p>
<p>$R_1(x) → W_4(x)=&gt;1→4$</p>
<p>$W_3(z)→R_4(z)=&gt;3→4$</p>
<p>$W_2(x)→W_4(x)=&gt;2→4$</p>
<p><img src="/posts/23083/image-20220515194142560.png" alt="image-20220515194142560"></p>
<p>并发控制的任务是执行可序列化的事务中执行的并发事务。</p>
<p>实际数据库系统对系统产生的调度加以控制，使其一定是可串行化的，阻止产生不可串行化的调度，并不是随便让其并行，看一下是不是可串行化的。最常见的就是加锁协议</p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="核心想法"><a href="#核心想法" class="headerlink" title="核心想法"></a>核心想法</h4><p>要求某个事务对数据进行读写操作时要先申请一个锁，按照抢到锁的先后次序执行</p>
<h4 id="两段加锁协议"><a href="#两段加锁协议" class="headerlink" title="两段加锁协议"></a>两段加锁协议</h4><p><strong>Two Phase Locking 2PL</strong></p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>定义一：在一个事务里，如果所有的<strong>锁申请操作</strong>都在所有的<strong>锁释放</strong>之前，就是<strong>两段加锁协议</strong>，就是<strong>两阶段事务</strong>。</p>
<p>两段加锁协议  <a name="两段加锁协议"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK A // 申请锁</span><br><span class="line">LOCK B</span><br><span class="line">LOCK C</span><br><span class="line">…… // 读写操作</span><br><span class="line">UNLOCK A</span><br><span class="line">UNLOCK B</span><br><span class="line">UNLOCK C</span><br></pre></td></tr></table></figure>
<p>就是要的锁一起申请完，然后一起释放</p>
<p>定义二：如果在申请锁之后再访问数据就是well-formed,如果未申请锁就直接访问数据不是well-formed.</p>
<h5 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h5><ul>
<li>N个并发事务，任意一个都是<strong>well-fromed</strong>+<strong>2PL</strong>=&gt;可串行化的</li>
<li>N个并发事务，任意一个都是<strong>well-fromed</strong>+<strong>2PL</strong>+<strong>更新操作的锁推迟到事务结束commit再释放，确保出问题回滚前锁没有被释放</strong>=&gt;可串行化的+在恢复时不会出现<a href="#多米诺">多米诺现象 </a>——仅仅加锁无法解决多米诺现象</li>
<li><p>N个并发事务，任意一个都是<strong>well-fromed</strong>+<strong>2PL</strong>+<strong>所有的锁推迟到事务结束再释放</strong>=&gt;严格的两段加锁协议=&gt;在多粒度锁之前认为是最安全的</p>
</li>
<li><p>封锁法是保证可串行化的方法之一，不是唯一的方法</p>
</li>
</ul>
<h4 id="锁协议"><a href="#锁协议" class="headerlink" title="锁协议"></a>锁协议</h4><h5 id="X锁协议"><a href="#X锁协议" class="headerlink" title="X锁协议"></a>X锁协议</h5><ul>
<li><p>整个系统只有一种锁，排他锁</p>
</li>
<li><p>把并发运行的事务强行串行化</p>
</li>
</ul>
<p>NL-no lock X-X lock</p>
<p>Y-compatible N-imcompatible</p>
<p>该矩阵表示某事务申请锁的时候能否申请到</p>
<p>行-表示某一个数据对象上已经有的锁</p>
<p>列-表示某一个事务想要申请的锁</p>
<p><strong>相容矩阵</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>NL</strong></th>
<th><strong>X</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NL</strong></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<p><strong>实现效果</strong></p>
<p><img src="/posts/23083/image-20220401202046628.png" alt="image-20220401202046628" style="zoom: 50%;"></p>
<p>不加控制，要么读到脏数据，要么存在不可重复读的问题</p>
<p>假设A抢到了对封锁表的操作权限，查到关系R上面暂时没有锁，就可以获取锁，更新封锁表，然后A先更新，更新完释放数据，$T_B$才能开始读，不管读几次都不会出现不可重复读的问题，也不会出现先读的某属性和后读的某属性不是同一时间的（更新操作在两次读之间发生）</p>
<p>封锁表:锁ID,数据对象ID,拥有锁的事务,…</p>
<p>$X,R,T_B$:$T_B$事务拥有了对关系$R$的$X$锁</p>
<h5 id="S-X-锁协议"><a href="#S-X-锁协议" class="headerlink" title="(S,X)锁协议"></a>(S,X)锁协议</h5><ul>
<li>S是共享锁：允许同时进行的读操作【提高效率】</li>
<li>X是排它锁：更新数据</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>NL</strong></th>
<th><strong>S</strong></th>
<th><strong>X</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NL</strong></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>Y</td>
<td><strong>Y</strong></td>
<td>N</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<h5 id="S-U-X-锁协议"><a href="#S-U-X-锁协议" class="headerlink" title="(S,U,X)锁协议"></a>(S,U,X)锁协议</h5><ul>
<li>尽量减少排它锁的使用场景，更新操作，不是直接改数据库的数据，需要将旧值读进内存做修改，事务提交时再写到数据库，真正修改的只有最后那一段，在前面那一段时间，数据库里面的数据没有动，可以允许其他事务见缝插针对数据进行读取，进一步提高系统运行的并行度</li>
<li>要对数据更新操作时先申请U锁，U锁时仍可读，直到要写数据时把U锁升级成X锁</li>
<li>把排他锁尽量后写【可以和数据库的<a href="#jump">A.I→DB after commit </a>策略配合使用】</li>
<li>进一步提高运行效率</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>NL</strong></th>
<th><strong>S</strong></th>
<th><strong>U</strong></th>
<th><strong>X</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NL</strong></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><strong>S($R$)</strong></td>
<td>Y</td>
<td>Y</td>
<td><strong>Y</strong></td>
<td>N</td>
</tr>
<tr>
<td><strong>U($W_1$)</strong></td>
<td>Y</td>
<td><strong>Y</strong></td>
<td><strong>N</strong></td>
<td>N</td>
</tr>
<tr>
<td><strong>X($W_2$)</strong></td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<h3 id="死锁与活锁"><a href="#死锁与活锁" class="headerlink" title="死锁与活锁"></a>死锁与活锁</h3><ul>
<li><p>死锁：等待锁关系之间出现循环等待</p>
<p><img src="/posts/23083/image-20220402103100850.png" alt="image-20220402103100850" style="zoom: 50%;"></p>
<p>解决办法</p>
<ol>
<li>防止出现死锁——死锁预防</li>
<li>找出牺牲者，解决死锁——死锁检测</li>
</ol>
</li>
<li><p>活锁：某个时候等待相当长时间仍然申请不到锁。【饥饿现象】</p>
<p><img src="/posts/23083/image-20220517185624440.png" alt="image-20220517185624440" style="zoom: 50%;"></p>
<p>解决方法：</p>
<ul>
<li>按先进先出排个队</li>
</ul>
</li>
</ul>
<h4 id="死锁检测与死锁预防"><a href="#死锁检测与死锁预防" class="headerlink" title="死锁检测与死锁预防"></a>死锁检测与死锁预防</h4><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><ul>
<li><p>Timeout——超时法：设定一个等待时限，<strong>时限比较难以确定</strong></p>
<p>某事务等待资源超过这个时限就认为是死锁了，自己中止并释放拥有的资源</p>
</li>
<li><p>构造等待图：顶点集合就是参与的事务，等待关系$T_i$等待$T_j$就是边$T_i-T_j$</p>
<p>一旦等待图出现<strong>环路</strong>，那么就是出现<strong>死锁</strong>了</p>
<p>检查环路的时机</p>
<ul>
<li>出现一条新边，新的等待关系：新事务等待某个被占用的资源</li>
<li>安排一个后台线程，周期性检查</li>
</ul>
<p>解决死锁</p>
<ul>
<li>选择牺牲者，最年轻的事务？最小终止开销的事务（拥有最少锁的事务）？</li>
<li>终止这个牺牲者，释放它所拥有的资源和锁</li>
<li>等待相应资源的事务开始运行</li>
<li>重启牺牲者，自动 or 手动（向用户报错，用户重新执行刚刚的事务）</li>
</ul>
</li>
</ul>
<h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><ol>
<li><p>事务初始化时一次性申请所有锁<strong>（×）</strong></p>
<p>动态SQL，根据用户输入临时决定执行什么语句，不能在初始化时就确定锁</p>
<p>即便是单粒度，对表加锁，运行之前就把所有需要访问的表都确定不现实</p>
</li>
<li><p>给锁排序，只能按照某个顺序申请锁<strong>（×）</strong></p>
<p>即便是单粒度，这么多表，新建表、删除表，动态变化，难以排序</p>
<p>元组粒度，如何排序？</p>
</li>
<li><p>一旦冲突就终止<strong>（×）</strong></p>
</li>
<li><p>事务重置</p>
</li>
</ol>
<ul>
<li>给每个事务安排时间戳 TimeStamp<ul>
<li>时间戳的作用：<ul>
<li>TID 事务的标识符ID</li>
<li>比较两个事务的年龄</li>
</ul>
</li>
<li>Wait-die（等待死亡法）：当$T_A$要申请的锁被$T_B$占有了，比较两者时间戳，如果自己年龄更小，就杀了自己sleep一会再自动运行重新申请（时间戳不变），自己年龄更大，就等待。<ul>
<li>等待关系单方面（年老事务等待年轻的事务），不会出现死锁</li>
<li>比自己年老的肯定有限，比自己年轻的虽然无限，但是只要比自己年老的都结束了，那就可以运行了，不会出现活锁</li>
</ul>
</li>
<li>Wound-wait（积伤等待法）：当$T_A$要申请的锁被$T_B$占有了，比较两者时间戳，如果自己年轻，就等待，自己年龄大，就杀了$T_B$，抢占他的资源进行自己的事务，$T_B$sleep一会再运行（时间戳不变）。<ul>
<li>只会有年轻事务等待年老事务</li>
<li>自己年老就会杀掉年轻的，就算有无限的年轻的，也会被kill掉；自己年轻，那比自己年老的，能kill自己的是有限的，自己总会变成老的，能kill别人了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><p><strong>Lock Granularities</strong></p>
<h4 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h4><p><strong>Locking in multi granularities</strong></p>
<h5 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h5><ul>
<li><p>为了提高事务的并发度，锁粒度应该越小越好</p>
<p>比如某事务$T_1$想查询张三学生的电话号码，另外一个事务$T_2$修改李四的家庭地址，如果加锁在学生信息表上，那么$T_1$需要申请S锁，$T_2$需要申请X锁，就需要竞争。</p>
<p>如果以元组为单位，并发度显著提高</p>
</li>
<li><p>为了减少锁的开销，锁粒度应该越大越好</p>
<p>如果统一加锁到元组，那么也会出现问题</p>
<p>新的事务$T_3$想要计算所有男生的平均年龄，此时如果以元组为锁粒度，就得把4w个学生都得上锁，开销太大</p>
<p>此时把粒度限制在表级别显然更合适</p>
</li>
</ul>
<h5 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h5><p>DB-&gt;File-&gt;Record-&gt;Field</p>
<p>数据库-&gt;表（关系、文件）-&gt;记录（元组）-&gt;列（属性）</p>
<p>在这种情况下，如果一个事务在某个级别的数据对象上获得了一个锁，那么它就会在该数据对象的每个子代上隐含地获得相同的锁——有点windows文件系统设置文件夹属性的意思</p>
<p>两种锁——显式锁和隐含锁</p>
<p>隐含(Implicit)锁和显式(Explicit)锁的冲突问题</p>
<p>刚刚$T_3$对表加了S锁，隐含在每条记录上加了S锁，现在有事务$T_2$想要修改某学生的家庭地址，需要申请X锁，如何知道这个冲突？如何避免一个一个元组加锁，还能够告诉别的事务，我在某条元组上加锁了？在封锁表里面看到的都是显式的锁</p>
<p>$T_3,Student,S$</p>
<p>$T_2$去查，发现找不到$T_3,Record_{李四},S$，但是实际上还是不能申请到X 锁的</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p><strong>Intention lock</strong></p>
<p>插旗子的警告作用</p>
<h5 id="新的锁"><a href="#新的锁" class="headerlink" title="新的锁"></a>新的锁</h5><ol>
<li><p>意向共享锁</p>
<p>Intension share lock</p>
</li>
<li><p>意向排它锁</p>
<p>Intension exclusive lock</p>
</li>
<li><p>复合锁</p>
<p>S+IX</p>
</li>
</ol>
<p><img src="/posts/23083/image-20220518185724806.png" alt="image-20220518185724806"></p>
<p>如果一个事务在某个低级别的数据对象<strong>(Record)</strong>上加了一个<strong>S(X)锁</strong>，那么所有包含它的高级别的数据对象<strong>(DB、File)</strong>都应该加一个<strong>IS(IX)锁</strong>以警告。如果另一个事务以后想在更高层次的数据对象上加一个<strong>X锁</strong>，它可以通过<strong>IS锁</strong>找到隐含的冲突。</p>
<p><strong>SIX锁</strong>对应<strong>Update</strong>语句，更新操作寻找满足修改条件的记录时需要做全表扫描，这个时候需要在全表上加<strong>S锁</strong>，但是找到了满足条件的记录后只需要在这几条记录上加<strong>X锁</strong>，也就应该对所在的表加上<strong>IX锁</strong>，结合之前加的<strong>S锁</strong>，就是<strong>SIX锁</strong></p>
<h5 id="发现冲突"><a href="#发现冲突" class="headerlink" title="发现冲突"></a>发现冲突</h5><p><img src="/posts/23083/image-20220518191302484.png" alt="image-20220518191302484" style="zoom:150%;"></p>
<h5 id="相容矩阵"><a href="#相容矩阵" class="headerlink" title="相容矩阵"></a>相容矩阵</h5><p><img src="/posts/23083/image-20220519160452246.png" alt="image-20220519160452246"></p>
<p><img src="/posts/23083/image-20220518195716029.png" alt="image-20220518195716029" style="zoom:67%;"></p>
<p>按照No个数进行排他性排序</p>
<p><strong>具有强排他性的锁可以在锁定时替代弱排他性的锁</strong></p>
<h5 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h5><p><img src="/posts/23083/image-20220518200328555.png" alt="image-20220518200328555" style="zoom:33%;"></p>
<p>加锁从根向叶子加，但是释放锁时需要从叶子往根释放</p>
<p><strong>示例</strong></p>
<p><img src="/posts/23083/image-20220518201928010.png" alt="image-20220518201928010"></p>
<p>理论上，$T_1$事务要读取某个元组，要加S锁，然后往上加file的IS锁和DB的IS锁，<strong>这种申请顺序会出现什么问题</strong>？</p>
<p>实际上，是按照DB的IS锁-&gt;file的IS锁-&gt;record的S锁，查询相容矩阵来进行申请的</p>
<p><strong>如果一直到record才发现申请不到锁，是不是要把之前的锁释放掉？</strong></p>
<p>释放锁反过来</p>
<p>数据库申请IX锁，然后到表申请SIX锁，最后到满足条件的记录上申请X锁，最后修改，反过来释放</p>
<h3 id="索引加锁"><a href="#索引加锁" class="headerlink" title="索引加锁"></a>索引加锁</h3><p>索引针对关系建立，事务插入、删除、更新会涉及到索引的维护更新</p>
<p>传统数据库不支持多粒度封锁，不会同时有两个事务维护索引，不会出问题</p>
<p>但是现在支持多粒度封锁后，事务也会并发的访问索引，并进行搜索、插入、删除等操作，因此也需要并发控制</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="/posts/23083/image-20220519182841882.png" alt="image-20220519182841882"></p>
<p>如何有效地锁定一个特定的叶子索引项？</p>
<h4 id="暴力方法"><a href="#暴力方法" class="headerlink" title="暴力方法"></a>暴力方法</h4><p>忽略树状结构，只是在遍历树状结构时锁定，遵循两段加锁协议，就是遍历到树的哪个节点，就在哪个节点上加一个锁</p>
<p><strong>问题</strong></p>
<p>低效——根节点（和许多更高层次的节点）成为瓶颈，因为每个树的访问都是从根开始的，全部都会卡在树根这个地方</p>
<h4 id="有效方法"><a href="#有效方法" class="headerlink" title="有效方法"></a>有效方法</h4><h5 id="B-树特征"><a href="#B-树特征" class="headerlink" title="B+树特征"></a>B+树特征</h5><ol>
<li>对B+树的每一次访问都是从根部到叶子节点的访问。只有叶子才有数据的详细信息，如TID，而中间节点只是起到路标作用</li>
<li>一个节点一般占用一个block，所以B+树的锁单位是block。不需要多粒度的锁，只需要block的S、X锁即可</li>
<li>B+树是被频繁访问的关键资源，容易成为系统的瓶颈。在索引并发控制中，性能是非常重要的。</li>
<li>如果在遍历树的过程中发生冲突，丢弃所有已经申请的锁，延迟一段时间后再从根部搜索，重新申请锁。避免因等待而导致的死锁，使得整个系统的死锁问题复杂化</li>
<li>最初，<strong>索引上的锁只是用来保持索引本身的一致性</strong>。并发事务操作数据的正确性是由2PL负责的。 从这个意义上说，索引上的锁不需要保持到事务结束，索引的操作（搜索、更新、删除）<strong>结束后可以立即释放</strong>。但是后续<a href="#幽灵现象">幽灵现象</a>表明，在支持多粒度封锁的情况下，即使是严格的2PL也会有漏洞。在这种情况下，<strong>B+树的叶子上的锁应该保持到EOT</strong>，以弥补这个漏洞，而树上其他节点的锁可以在<strong>搜索</strong>结束后释放</li>
</ol>
<h5 id="索引加锁算法"><a href="#索引加锁算法" class="headerlink" title="索引加锁算法"></a>索引加锁算法</h5><h6 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h6><p>在遍历过程中，首先对根节点施加S锁，然后对所选的子节点施加S锁。一旦得到子节点的S锁，父节点的S锁就可以被释放，因为遍历不能返回，直到到达叶子节点。遍历之后，只剩下目标叶子上的S锁，保持这个S锁直到EOT。</p>
<h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><p>在插入新的索引项时，首先遍历，找到应该插入新项的叶子节点，在这个叶子节点上加上X锁，接下来进行插入操作：</p>
<ol>
<li>如果它没有满，直接插入</li>
<li>如果它是满的，根据B+树的规则分割节点。在拆分时，父节点需要增加新的指针，因此除了原来的叶子，新的叶子和它们的父本也要添加X锁。如果父节点也是满的，分裂将继续进行，同样也要向上加锁</li>
</ol>
<p>注意</p>
<ol>
<li>在每次拆分中，必须在每个要改变的节点上应用X锁，这些X锁可以在更新完成后释放</li>
<li>在叶子节点的插入过程完成后，叶子节点上的X锁被改变为S锁并保持到EOT</li>
</ol>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p>当从树上删除一个索引项时，其过程与插入相似。删除可能会导致B+树中节点的组合，其父节点也要删除一个指针。因此同样遵循被改变的节点必须先被X锁，完成改变后释放X锁的原则。叶子节点上的X锁也被改变为S锁，并保持到EOT</p>
<h3 id="幽灵现象及其预防"><a href="#幽灵现象及其预防" class="headerlink" title="幽灵现象及其预防 "></a>幽灵现象及其预防<a name="幽灵现象"> </a></h3><h4 id="本质"><a href="#本质" class="headerlink" title="本质 "></a>本质<a name="幽灵现象"> </a></h4><p>在允许多粒度锁的情况下，数据库是一个稳定的、可靠的数据集合的假设（隔离性——感受不到其他事务的存在，因此如果当前事务自身没有修改更新数据库的数据，那么读取时，读到的数据应该就是稳定可靠的，不应该经常变化）是不正确的。即使是严格的<a href="#两段加锁协议">两段加锁协议</a>也无法保证这种现象不会发生，这种现象就是<strong>幽灵现象</strong>。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>没有一致的数据库状态支持T1的正确性</p>
<p><img src="/posts/23083/image-20220519193228836.png" alt="image-20220519193228836"></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>T1隐含地假设它已经锁定了所有等级=1的水手记录集，这个问题其实是多粒度封锁造成的，如果没有多粒度封锁，T1想要查询就得申请获取S锁，T2想要插入就要申请X锁，T1有了S锁，T2申请不到X锁，不会出现上述幽灵现象</p>
<p>或者 即使有多粒度封锁，但是T1需要全表扫描，并在表上设置S锁，那么也不会出现该问题，例如</p>
<p>select s#, average(grade) from SC group by s#;</p>
<ol>
<li>只有在T1执行时没有添加水手记录的情况下，该假设才成立。</li>
<li>需要一些机制来强制执行这个假设。 (索引锁定和谓词锁定)</li>
</ol>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="索引锁"><a href="#索引锁" class="headerlink" title="索引锁  "></a>索引锁 <a name="索引锁"> </a></h5><p><strong>索引上加的锁保留到EOT</strong></p>
<p>现在T1找到了所有rating=1的水手，对应的索引项上就会被S锁 锁住，并且事务结束前不会被释放</p>
<p><strong>如果没有rating=1的记录，T1必须锁定这样的数据条目所在的索引节点，如果它存在的话。</strong></p>
<p>T2在插入新的记录前，需要维护这个索引，需要申请级别为1的水手的索引项上的X锁，本身已经有了S锁，不会申请成功，也就难以实现新记录的插入，避免了幽灵现象，返回T2执行前的正确结果</p>
<p><strong>如果没有合适的索引，T1必须全表扫描才能确定哪些是等级为1的水手，而这需要锁定整个表(S锁)，在T1提交之前当然不能增加新的记录。</strong></p>
<h5 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h5><p>了解即可</p>
<p>对所有满足某些逻辑前提的记录授予锁，例如，年龄&gt;2*工资，将满足这个条件的记录锁起来</p>
<p><strong>索引锁是谓词锁的一个特例，对它来说，索引支持谓词锁的有效实现</strong></p>
<p>谓词：ranking = 1</p>
<p>涉及到语句的语义，和业务规则相关，想要实现谓词锁的代价太大</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>从SQL-92开始增加了对事务隔离级别的支持，允许用户编程时根据应用需要通过语句去设定当前事务的隔离级别。每个事务都有一个访问模式，一个诊断大小，和一个隔离级别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORACLE</span><br><span class="line"></span><br><span class="line">SET TRANSACTION READ ONLY // 只读事务</span><br><span class="line">ISOLATION LEVEL REPEATABLE READ;// 隔离级别</span><br><span class="line">/-----------------------------/</span><br><span class="line"></span><br><span class="line">Sql Server</span><br><span class="line"></span><br><span class="line">SET TRANSACTION ISOLATION LEVEL </span><br><span class="line">&#123;   READ COMMITTED |</span><br><span class="line">    READ UNCOMMITTED | </span><br><span class="line">    REPEATABLE READ | </span><br><span class="line">    SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隔离级别：</p>
<p><img src="/posts/23083/image-20220520134837181.png" alt="image-20220520134837181"></p>
<p>读写冲突可以放松，写写冲突是不可接受的底线</p>
<ol>
<li><p>Read Uncommitted</p>
<ul>
<li><p>影响</p>
<p>实际应用中，发现用户在查询数据库时能容忍读脏数据，对数据一致性要求不高，此时就可以利用上述语句将当前事务的隔离级别设置成read uncommitted，此时也就意味着也能允许不可重复读和幽灵现象的发生</p>
<p>比如楼层经理，每天商场快关门时，查询一下今天营业额，只需要一个大概的数据，和昨天比多了还是少了，现在还有一个人还在付钱，这一笔数据正在录入，但是可以忽略，不影响整体的收入，就可以设置为当前级别</p>
</li>
<li><p>锁命令</p>
<p>该事务读取数据时不申请锁；<strong>写时上X锁，保持到EOT</strong></p>
</li>
<li><p>说明</p>
<p>可以插队，效率很高，但是不申请锁也限制不了别的事务的写操作，如果别的事务需要进行写操作，就会发生<a href="#读脏数据">读脏数据</a>、<a href="#不可重复读">不可重复读</a>等问题；</p>
<p>如果别的事务进行插入操作，没有申请锁，也不会对索引上锁，会发生<a href="#幽灵现象">幽灵现象</a></p>
</li>
</ul>
</li>
<li><p>Read Committed</p>
<ul>
<li><p>影响</p>
<p>不能容忍读脏数据，但是可以容忍不可重复读和幽灵现象</p>
</li>
<li><p>锁命令</p>
<p>读取时申请S锁，读完就释放；<strong>写时上X锁，保持到EOT</strong></p>
</li>
<li><p>说明</p>
<p>之前脏数据示例中，$T_2$读申请S，然后释放，$T_1$写申请X，$T_2$再读申请不到S，无法读，$T_1$事务结束前回滚了，然后释放X，$T_2$再读，读到的也是回滚后的干净数据，避免<a href="#读脏数据">读脏数据</a>）</p>
<p>正因为读后释放，$T_1$读完释放，$T_2$改写，$T_1$再读，两次读取的结果不一样，会发生<a href="#不可重复读">不可重复读</a>的问题；同理，读后释放也难以避免会发生<a href="#幽灵现象">幽灵现象</a></p>
</li>
</ul>
</li>
<li><p>Repeatable Reads</p>
<ul>
<li><p>影响</p>
<p>不能容忍读脏数据、不可重复读，但是可以容忍幽灵现象</p>
</li>
<li><p>锁命令</p>
<p>遵循严格的2PL(两段加锁协议)</p>
</li>
<li><p>说明</p>
<p>前面两种自然都可以避免了，但是<a href="#幽灵现象">幽灵现象</a>依然无法避免，因为没有对索引加锁直到EOT</p>
</li>
</ul>
</li>
<li><p>Serializable</p>
<ul>
<li><p>影响</p>
<p>均不能容忍</p>
</li>
<li><p>锁命令</p>
<p>严格的两段加锁协议并且保持索引结构叶子节点的S锁直到EOT</p>
</li>
<li><p>说明</p>
<p><a href="#索引锁">索引锁</a></p>
</li>
</ul>
</li>
</ol>
<h3 id="OODBMS的锁机制"><a href="#OODBMS的锁机制" class="headerlink" title="OODBMS的锁机制"></a>OODBMS的锁机制</h3><p>面向对象数据库管理系统的锁机制</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ol>
<li><p>锁粒度</p>
<p>DB-Class-Object</p>
<p><strong>除了锁粒度这个层次外，类之间存在继承关系的层次结构，如何加锁？</strong></p>
</li>
<li><p>单层加锁</p>
<p>锁粒度限制在对象Object一级，只用S或X锁锁定所操作的对象。适用于面向CAD这样以单个复杂对象为主的机械制造类的应用，不适合用于经常有关联查询的应用场合</p>
</li>
<li><p>多粒度加锁</p>
<p>OLTP应用（联机事务处理），使用上一节介绍的S、X、IS、IX、SIX锁，可以实现联想查询（Select），涉及到大量记录</p>
<p>但是无法应对级联查询和更新</p>
</li>
<li><p>复杂多粒度加锁</p>
<p>添加两种类层次锁，解决级联查询和更新的问题</p>
</li>
<li><p>锁定复杂的对象</p>
<p><strong>职工-所在单位（复杂对象）</strong></p>
<p><strong>所在单位-领导（复杂对象）</strong></p>
<p><strong>领导-毕业院校-毕业时间</strong></p>
<p>只在访问时锁定所指对象（根据一般的多粒度锁协议）</p>
</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>新问题：</strong>多粒度锁中的类级锁只能锁定直接属于这个类的对象，不能包括其子类中的对象。所以不适合用于<strong>对继承树的级联查询或模式更新（对这个类及其子类的所有对象做查询或者做更新）</strong></p>
<h5 id="级联查询示例"><a href="#级联查询示例" class="headerlink" title="级联查询示例"></a>级联查询示例</h5><p><img src="/posts/23083/image-20220520141205882.png" alt="image-20220520141205882"></p>
<h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>RL-如果在该类上添加了RL锁，相当于在该类和其子类上都添加了S锁</p>
<p>WL-如果在该类上添加了WL锁，相当于在该类和其子类上都添加了X锁</p>
<p>相容矩阵</p>
<h4 id="加锁方法"><a href="#加锁方法" class="headerlink" title="加锁方法"></a>加锁方法</h4><p>真正申请锁还是先从根开始，释放从叶子开始</p>
<p>如果需要对某个类申请RL(WL)锁</p>
<ol>
<li><p>在该类的任何超类链上添加IS(IX)锁，包括DB</p>
</li>
<li><p>在该类上申请RL(WL)锁</p>
</li>
<li><p>自上而下检查该类的子类上是否有与RL(WL)冲突的锁。</p>
<ol>
<li><p>如果没有冲突，在有多个父母的子类上添加一个RL(WL)锁</p>
<p>多个父母说明有可能有涉及到其他父母的事务需要申请锁，会发生冲突，添加这个锁避免出现问题</p>
</li>
</ol>
</li>
</ol>
<ol>
<li>上述任何一个环节如果发现有冲突，则锁申请失败，需要等待（等待的时候，之前申请的锁需要释放吗？）</li>
</ol>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><p><img src="/posts/23083/image-20220520144012281.png" alt="image-20220520144012281"></p>
<h3 id="时间戳法"><a href="#时间戳法" class="headerlink" title="时间戳法"></a>时间戳法</h3><p>并发控制——保证并发事务调度的可串行化，前面可以利用锁机制，强行按照抢到锁的先后顺序执行，但是加锁并不是唯一方法——&gt;时间戳法</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>系统中运行的每一个事务拥有一个时间戳 T.S（begin transaction时赋予，TID作用，表征事务年龄）</p>
<p>要求一组并发运行的事务按照时间戳从小到大的顺序执行，系统将强制要求并发事务以一种等价于<strong>基于时间戳的串行序列的顺序</strong>执行</p>
<p>给数据库的每一个数据对象赋予时间戳</p>
<ol>
<li><p>read time(tr)</p>
<p>已经读取该对象，并且拥有最高T.S的事务</p>
</li>
<li><p>write time(tw)</p>
<p>已经更新该对象，并且拥有最高T.S的事务</p>
</li>
</ol>
<p>通过<strong>数据对象的时间戳</strong>以及<strong>事务的时间戳</strong>就可以判断<strong>并行事务的执行顺序是否符合基于时间戳的串行序列的顺序</strong></p>
<p>违反的，abort掉，重新赋予时间戳，重新执行</p>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p><img src="/posts/23083/image-20220520151222496.png" alt="image-20220520151222496"></p>
<p><img src="/posts/23083/image-20220520152858573.png" alt="image-20220520152858573"></p>
<p><a href="#目标冲突">冲突可串行化-&gt;目标可串行化</a></p>
<p>do nothing就是目标等价，但不是冲突等价</p>
<h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><p>优势：无需加锁，不存在死锁</p>
<p>劣势：</p>
<ol>
<li><p>每个事务和每个数据对象都要维持时间戳，每次操作都要更新数据对象的两个时间戳，系统维护开销比较大</p>
<p>解决办法</p>
<ol>
<li><p>扩大数据对象加时间戳的粒度（低并发度）</p>
<p>加锁粒度粗，存储、更新开销小，并发度低，效率低<br>加锁粒度细，存储、更新开销大，并发度大，效率高</p>
</li>
<li><p>数据对象的T.S实际上并不需要存储在非易失性存储器中，而是存储在内存中（缓冲信息表）</p>
<p>事务需要访问某个数据对象时，就将其时间戳纳入内存，并且视为0，读写操作时再更新对应时间戳。如果后续经过较长时间（新进来的事务的时间戳都会增加这么久的时间），都没有运行的事务访问这个数据对象（数据对象的tr和tw不会变大），确保系统中正在运行的事务的时间戳t都比该数据对象的tr、tw大，那么其时间戳就可以从内存中删掉，没有必要存起来了，肯定都比它大。</p>
<p>其它事务正在执行的条件</p>
<p>读——t&gt;=tw</p>
<p>写——t&gt;=tr and t&gt;=tw</p>
</li>
</ol>
</li>
<li><p>系统运行效率较低</p>
<p>锁：互相竞争，n!种正确的串行序列</p>
<p>时间戳：只接受一种正确的串行序列</p>
</li>
</ol>
<h3 id="乐观法"><a href="#乐观法" class="headerlink" title="乐观法"></a>乐观法</h3><p><img src="/posts/23083/image-20220523190002851.png" alt="image-20220523190002851"></p>
<h4 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h4><p>假定在并发事务执行时很少有冲突。</p>
<p>在事务执行时不做任何检查，读取操作任意执行，但是更新操作并不直接写入数据库，而是存储在内存中，当一个事务结束时，检查事务的调度是否可串行化。如果它是可串行化的，就把内存中的更新副本写进DB；否则，就中止事务并重试。</p>
<h4 id="事务执行"><a href="#事务执行" class="headerlink" title="事务执行"></a>事务执行</h4><h5 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h5><ol>
<li><p>读阶段</p>
<p>从数据库中读取数据并执行各种处理，但更新操作只在内存中形成更新副本</p>
</li>
<li><p>检验阶段</p>
<p>检查事务的调度是否可串行化</p>
</li>
<li><p>写阶段</p>
<p>如果成功通过检查，将内存中的更新副本写入DB并提交事务；或者丢弃内存中的更新副本并中止事务</p>
</li>
</ol>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ol>
<li><p>read set</p>
<p>读集合——该事务读过哪些数据对象</p>
</li>
<li><p>write set</p>
<p>写集合——该事务写过哪些数据对象</p>
</li>
<li><p>start/end time</p>
<p>每个事务每种阶段的开始结束时间，即什么时候开始读/结束读，开始检查/结束检查，开始写/结束写</p>
</li>
</ol>
<h5 id="可串行化检验"><a href="#可串行化检验" class="headerlink" title="可串行化检验"></a>可串行化检验</h5><p>检查对象：进入检查阶段的事务$T_i$，只需要检查$T_i$和已经提交的事务以及其他依然处于检查阶段的事务之间是否存在冲突，处于读取阶段的事务无需考虑</p>
<p>$T_i$当前正在检查的事务，$T_j$是某个提交或者处于检查阶段的事务，说明$T_j$的任何操作其实都比$T_i$先完成，满足以下条件，$T_i$即可通过检查，进入写阶段，均等价于$T_j→T_i$的串行化序列</p>
<p><img src="/posts/23083/image-20220524112352819.png" alt="image-20220524112352819"></p>
<ol>
<li><p>$T_i,T_j$之间不存在任何访问对象的冲突，即不会访问同一个对象</p>
<p>读写都没有任何交集，自然不冲突</p>
</li>
<li><p>不管有啥交集，如果满足$T_i$开始读阶段之前，$T_j$已经完成了写阶段，$T_j→T_i$</p>
<p>在此情况下，$T_j$在$T_i$开始前已结束，无任何冲突</p>
</li>
<li><p>$T_i$的读对象和$T_j$的写对象不存在交集，并且$T_i$在$T_j$完成写阶段后开始写阶段</p>
<p>读写不相交，第一种冲突不会发生</p>
<p>（即便写写对象有交集）由于$T_i$在$T_j$完成写阶段后才开始写阶段，自然等价于$T_j$先写，$T_i$后写，即$T_j→T_i$，第三种冲突不会发生</p>
<p>（即便写读对象有交集）由于$T_i$在$T_j$完成写阶段后才开始写阶段，$T_j$的读肯定比$T_i$的写先完成，此时写读不冲突，等价于$T_j$先读，$T_i$在写，第二种冲突不会发生。两个读操作谁先完成不影响</p>
</li>
</ol>
<ol>
<li><p>$T_i$的读写对象和$T_j$的写对象交集为空</p>
<p>首先排除第一、第三种冲突，唯一需要考虑的是$T_i、T_j$的写读冲突，但是$T_i$开始检验时，$T_j$至少进入了检验阶段，表明读阶段已经完成，而$T_i$还没开始写阶段，相当于$T_j$先读，$T_i$后写的串行化序列，即$T_j→T_i$，不冲突</p>
</li>
</ol>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>实现比较复杂</p>
<p>以读为主，更新较少的使用场景——人口统计数据库，10年一次大更新，平时少量小修改，主要是读取数据</p>
<h3 id="分布式数据库加锁"><a href="#分布式数据库加锁" class="headerlink" title="分布式数据库加锁"></a>分布式数据库加锁</h3><p>开销分析基于n个副本</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ol>
<li>多副本，如何发现全局冲突</li>
<li>网络通讯开销</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>前三种类似</p>
<h5 id="write-lock-all-read-lock-one"><a href="#write-lock-all-read-lock-one" class="headerlink" title="write lock all, read lock one"></a>write lock all, read lock one</h5><p>读R时，只在R的这个副本上加S锁</p>
<p>写R时，需要在R的所有副本上加X锁</p>
<p>锁保持到EOT</p>
<p><strong>通讯开销分析</strong></p>
<p><img src="/posts/23083/image-20220523193319195.png" alt="image-20220523193319195" style="zoom:50%;"></p>
<p><img src="/posts/23083/image-20220523193425727.png" alt="image-20220523193425727" style="zoom:50%;"></p>
<h5 id="Majority-locking"><a href="#Majority-locking" class="headerlink" title="Majority locking"></a>Majority locking</h5><p>读R时，在R的大部分（$\left \lceil \frac{n+1}{2} \right \rceil$）副本上加S锁</p>
<p>写R时，在R的大部分（$\left \lceil \frac{n+1}{2} \right \rceil$）副本上加X锁</p>
<p>锁保持到EOT</p>
<p><strong>通讯开销分析</strong></p>
<p><img src="/posts/23083/image-20220523193940924.png" alt="image-20220523193940924"></p>
<p>比第1种，在避免死锁方面有一定优越性</p>
<p>在前面那种方法中，如果有两个事务争夺更新的X锁，也许每个人都能得到一部分，但没有人能够得到全部的X锁。死锁就很容易发生。<strong>比如有三个副本，事务1获取了1个副本的锁，事务2获取了2个副本的锁，都要等待。</strong></p>
<p><strong>在当前方法中，只要n是奇数，那么肯定有一个事务能获取多的锁，多的就可以成功，另外一个事务因为获取不到超过半数副本的锁，就要等待，</strong>这样就避免了这种死锁的发生。</p>
<h5 id="k-out-of-n-locking"><a href="#k-out-of-n-locking" class="headerlink" title="k-out-of-n locking"></a>k-out-of-n locking</h5><p>读R时，在R的大部分n-k+1个副本上加S锁</p>
<p>写R时，在R的大部分k个副本上加X锁，n=&gt;k&gt;n/2</p>
<p>k=n时就是第一种方法</p>
<p>k=(n+1)/2就是第二种方法</p>
<p>锁保持到EOT</p>
<p>对<strong>读写冲突</strong>而言，写操作需要对至少k个副本上X锁，读操作需要至少n-k+1个副本上S锁，k+n-k+1=n+1&gt;n，总有一个事务申请不到足够数量的锁，无法执行</p>
<p>对<strong>写写冲突</strong>而言，k+k&gt;n，总是有一个事务拿不到足够数量的锁，无法执行</p>
<p><strong>k越大，读取性能越优越</strong></p>
<h5 id="primary-Copy-Method"><a href="#primary-Copy-Method" class="headerlink" title="primary Copy Method"></a>primary Copy Method</h5><p>与<a href="#主副本">主副本的更新策略</a>配合使用</p>
<p>将锁住R的责任分配给一个给定的节点，这个站点被称为R的主节点</p>
<p><img src="/posts/23083/image-20220523195525405.png" alt="image-20220523195525405"></p>
<p>主节点会成为系统的瓶颈，如果崩溃了，那整个系统对关系R的操作都不能更新</p>
<p>它是有效的，但容易失败，所以有许多改进版本。 它经常与初级复制更新策略一起使用</p>
<h4 id="全局死锁-Global-Deadlock"><a href="#全局死锁-Global-Deadlock" class="headerlink" title="全局死锁(Global Deadlock)"></a>全局死锁(Global Deadlock)</h4><p><img src="/posts/23083/image-20220523200654977.png" alt="image-20220523200654977"></p>
<p>红色等待关系是显式等待关系，绿色的是隐式等待关系</p>
<p>单一节点均不存在死锁，但是存在全局死锁</p>
<h5 id="全局等待图-Global-wait-for-graph"><a href="#全局等待图-Global-wait-for-graph" class="headerlink" title="全局等待图(Global wait-for graph)"></a>全局等待图(Global wait-for graph)</h5><p>根据一般的<a href="#等待图">等待图</a>添加EXT节点。如果事务T是一个分布式事务，并且在其他节点有子事务，并且T是当前站点等待链的头，则将EXT→T加入图中；如果T是当前站点等待链的尾，则将T→EXT加入图中。</p>
<p>如果某个节点存在$EXT→T_i→T_j→ ┅  →T_k→EXT$这样的等待图</p>
<ol>
<li><p>检查其他节点是否存在，假设存在$EXT→T_k→T_l→ ┅ →T_x→EXT$，内部肯定不存在相同的，否则就已经死锁了</p>
</li>
<li><p>检查事务</p>
<ol>
<li><p>如果$T_x$和前面的($T_i→T_k$)任何一个事务相同，则死锁发生</p>
</li>
<li><p>否则，可以拼接起来</p>
<p>$EXT→T_i→T_j→ ┅ →T_k →T_l→ ┅ →T_x→EXT$</p>
</li>
</ol>
</li>
<li><p>重复上述操作都一直没有检测到死锁，那么就没有发生全局死锁</p>
</li>
</ol>
<p>比如刚刚那个</p>
<p>EXT-&gt;<strong>T1</strong>-&gt;T2-&gt;EXT</p>
<p>EXT-&gt;T2-&gt;<strong>T1</strong>-&gt;EXT</p>
<p>EXT-&gt;<strong>T1</strong>-&gt;T2-&gt;T2-&gt;<strong>T1</strong>-&gt;EXT</p>
<h3 id="分布式数据库时间戳法"><a href="#分布式数据库时间戳法" class="headerlink" title="分布式数据库时间戳法"></a>分布式数据库时间戳法</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p><strong>全局时间戳</strong></p>
<ol>
<li>单机环境下时间戳能够保证事务的唯一性，但是分布式环境下不能保证唯一性</li>
<li>节点的系统时钟不一致。节点2的操作实际先做，但是时间偏快（时间戳大），导致时间戳表现出来还是后做的，逻辑上就会出问题</li>
</ol>
<p><strong>多副本</strong></p>
<p>检查数据对象每个副本你的tr和tw，只要任何一个违反都要终止</p>
<h4 id="全局时间戳-global-time-stamp"><a href="#全局时间戳-global-time-stamp" class="headerlink" title="全局时间戳(global time stamp)"></a>全局时间戳(global time stamp)</h4><p><strong>唯一性——Global T.S = Local T.S + Site ID</strong></p>
<p><strong>时钟不一致——接收时间&gt;=发送时间</strong></p>
<p>不需要通讯的话，不一致不影响；受影响的是需要通讯的程序，需要保证发送时间在接收时间前</p>
<p>$t_1$接收节点，$t_2$是发送节点，接收的时间置为两者较大值</p>
<p>$t_{at~receipt~site}:= max(t_1, t_2)$</p>
<p>$t_1=current~T.S~at~receipt~site$</p>
<p>$t_2=T.S~of~MSG$</p>
<h4 id="多副本的读写操作"><a href="#多副本的读写操作" class="headerlink" title="多副本的读写操作"></a>多副本的读写操作</h4><p><strong>需要保证至少在一个副本上检查出时间戳的冲突</strong></p>
<p>写——更新所有副本的tw，检查冲突时需要检验所有副本的T.S(tw tr)，任意不满足（t&lt;tr or t&lt;tw）都需要终止</p>
<p>读——更新读的那个副本的tr，检查当前副本的T.S，如果t&lt;tw就终止，因为只有对当前副本的写操作会对读的结果造成影响，所以只需要检查当前读的副本的T.S</p>
<p><strong>前驱图</strong></p>
<p>多个前驱图也要拼起来，看看有没有环路</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-恢复</title>
    <url>/posts/26000.html</url>
    <content><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>数据库最基本的运行单位</li>
<li>如果不自己定义事务，那么系统默认一条SQL语句当作一条事务</li>
</ul>
<h4 id="ACID准则"><a href="#ACID准则" class="headerlink" title="ACID准则"></a>ACID准则</h4><ul>
<li>Atomic（原子性）：要么全部完成（commit），要么什么都不做(rollback)</li>
<li>Consistency preservation（保持一致性）：数据库本身状态一致，经过一个事务后，数据库保持另一个状态一致</li>
<li>Isolation（隔离性）：事务之间不能干扰</li>
<li>Durability（持久性）：一个事务只要成功完成，那么其对数据库的影响会永久存在，并且能够在故障后恢复</li>
</ul>
<p>如银行转账问题，把转账看出一个事务，如从A的账户转前给B账户</p>
<p><img src="/posts/26000/image-20220331143007828.png" alt="image-20220331143007828" style="zoom:33%;"></p>
<p><strong>如果不显式创建事务，那么提交的每一条sql语句都是事务</strong></p>
<p>上述的转账就必须显式声明事务，否则两个update语句分别是单独的事务</p>
<p>A和B两个账号被排它锁锁住了，no read no update until commit</p>
<p><strong>主要目的</strong></p>
<ul>
<li>能够从故障中恢复</li>
<li>尽可能地减少系统发生故障的可能</li>
</ul>
<p>在一些故障后将数据库恢复到一致的状态。</p>
<p><strong>要求</strong></p>
<ul>
<li>冗余【数据备份】是必要的，与数据库设计的冗余是不一样的</li>
<li>恢复机制要能够<strong>检测</strong>到所有故障</li>
</ul>
<p><strong>常用恢复方法</strong></p>
<h3 id="周期性转储"><a href="#周期性转储" class="headerlink" title="周期性转储"></a>周期性转储</h3><p><img src="/posts/26000/image-20220330193742407.png" alt="image-20220330193742407" style="zoom:33%;"></p>
<p>改进</p>
<p><img src="/posts/26000/image-20220330193816326.png" alt="image-20220330193816326" style="zoom:33%;"></p>
<h3 id="备份-增量转储"><a href="#备份-增量转储" class="headerlink" title="备份+增量转储"></a>备份+增量转储</h3><ol>
<li>长时间整个备份，短时间备份变化的部分</li>
<li>恢复丢失的信息较少，但是依然会有部分更新内容丢失</li>
<li>实现简单、开销小，但是依然会有更新丢失，适用于文件系统或者小型数据库管理系统</li>
</ol>
<h3 id="备份-日志"><a href="#备份-日志" class="headerlink" title="备份+日志"></a>备份+日志</h3><p>日志记录自上次备份以来数据库的所有改变</p>
<ul>
<li><p>日志记录如下内容：</p>
<ul>
<li><p>before image:B.I 旧的值 前项</p>
</li>
<li><p>after image:A.I 新的值 后项</p>
<p><img src="/posts/26000/image-20220330194506255.png" alt="image-20220330194506255" style="zoom:33%;"></p>
<p><img src="/posts/26000/image-20220330194520063.png" alt="image-20220330194520063" style="zoom:33%;"></p>
<p>相当于通过日志重演数据库的所有变化不会丢失信息，保证数据库数据的一致性，不会产生丢失更新</p>
</li>
<li><p>没做完的事务，用B.I进行恢复(undo)</p>
</li>
<li><p>做完但是没有写入到数据库的数据，用A.I进行恢复(redo)</p>
</li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li><p>日志的可靠性要求比一般的数据要高</p>
</li>
<li><p>如果两次转储的间隔时间太长，可能会因为Log的积累而出现（日志）存储空间不足的情况，解决办法：</p>
<ol>
<li>提交后释放空间</li>
</ol>
<p>事务一旦成功，不会回退，一般用不到日志，但是万一出现磁盘介质故障，数据损坏，需要从最近的备份+日志进行恢复，即重演一遍，但是日志没了。</p>
<ol>
<li><p>日志定期转储到磁盘</p>
</li>
<li><p>日志压缩</p>
<ol>
<li>不必为中止的事务存储日志信息</li>
<li>已提交的事务不需要B.I，只需要A.I进行redo</li>
<li>更改可以合并，只保留最新的A.I</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="多副本"><a href="#多副本" class="headerlink" title="多副本"></a>多副本</h3><p>针对分布式环境，每个数据对象都有多个副本。当故障发生时，与其他副本一起恢复。系统不会因为某些副本的失败而崩溃。</p>
<p>优势</p>
<ol>
<li>提高可靠性</li>
<li>恢复很容易</li>
</ol>
<p>缺陷</p>
<ol>
<li><p>在集中式数据库系统中很难获得独立的故障模式（当前副本的故障不会影响其他节点）。</p>
<p>集中式环境下，出了问题，数据的多个副本要坏一起坏</p>
</li>
<li><p>存储空间的浪费</p>
</li>
</ol>
<p>不适用于传统集中式数据库</p>
<p><strong>相关数据结构</strong></p>
<p>恢复信息必须存储在非挥发存储器【不会因为断电就丢失信息】</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><h4 id="Commit-list"><a href="#Commit-list" class="headerlink" title="Commit list"></a>Commit list</h4><p>所有已经提交的事务的列表，存储TID（事务的ID）</p>
<h4 id="Active-list"><a href="#Active-list" class="headerlink" title="Active list"></a>Active list</h4><p>当前正在运行的事务的列表，存储TID</p>
<h4 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h4><p><img src="/posts/26000/image-20220331143544299.png" alt="image-20220331143544299" style="zoom:33%;"></p>
<p>Before image：修改前的数据存储的block，BID是物理地址，碰到问题就用这个block去这个物理地址做覆盖</p>
<p>After image同理</p>
<h3 id="提交规则"><a href="#提交规则" class="headerlink" title="提交规则"></a>提交规则</h3><p>当事务提交之前要把所有的更新后项【新值 A.I】写到持久存储（硬盘）上，写到日志也行，不一定非要写在数据库里面，所以可能没写到数据库里</p>
<h3 id="先记后写规则"><a href="#先记后写规则" class="headerlink" title="先记后写规则"></a>先记后写规则</h3><p>如果直接修改数据库，在更新之前要把被修改数据的老值 B.I 先写到日志中，要不然旧的值就没了</p>
<h3 id="undo-amp-redo-amp-idempotent"><a href="#undo-amp-redo-amp-idempotent" class="headerlink" title="undo&amp;redo&amp;idempotent"></a>undo&amp;redo&amp;idempotent</h3><p>满足幂等性，做n次和做1次的效果相同</p>
<p><img src="/posts/26000/image-20220331144159907.png" alt="image-20220331144159907" style="zoom:33%;"></p>
<h3 id="故障重启动恢复模块"><a href="#故障重启动恢复模块" class="headerlink" title="故障重启动恢复模块"></a>故障重启动恢复模块</h3><p>检查点check point</p>
<p>自动周期性的设置检查点，在检查点时，检查自从上一个检查点以来运行的事务的TID在active list和commit list两个列表中的存在情况:</p>
<ol>
<li>那些已经提交的事务的TID，是否已经反映到数据库里面了</li>
<li>那些回滚的事务的TID，对数据库产生的影响是否已经消除</li>
</ol>
<h3 id="A-I→DB-before-commit"><a href="#A-I→DB-before-commit" class="headerlink" title="A.I→DB before commit"></a>A.I→DB before commit</h3><p>直接改数据库的</p>
<p>在commit 之前A.I直接写入DB[需要undo,不需要redo]</p>
<p><strong>事务执行流程</strong></p>
<ol>
<li>TID写入active list</li>
<li><strong>B.I写入日志</strong></li>
<li><strong>A.I写入DB</strong></li>
<li>重复2,3直到所有语句完成，遇到commit</li>
<li>commit命令后将事务的TID写入commit list</li>
<li>从active list删掉事务的TID</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Commit list</th>
<th>Active list</th>
<th>Period</th>
<th>Explain</th>
<th>Error process</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>√</td>
<td>1结束5没结束</td>
<td>部分更新了，部分没更新（更新的部分有B.I）</td>
<td>用日志记录的B.I进行undo, 然后delete TID from active list</td>
</tr>
<tr>
<td>√</td>
<td>√</td>
<td>5结束6没结束</td>
<td>事情是做完了，但是没删而已</td>
<td>delete TID from active list</td>
</tr>
<tr>
<td>√</td>
<td></td>
<td>6结束</td>
<td>没事</td>
<td>nothing to do</td>
</tr>
</tbody>
</table>
</div>
<h3 id="A-I→DB-after-commit-148"><a href="#A-I→DB-after-commit-148" class="headerlink" title="A.I→DB after commit(148)"></a>A.I→DB after commit(148)</h3><p>先把新值存到Log， 遇到commit 命令后再将改动的数据写入DB【比第一种更新策略效率高，并发度，只要没到commit就不动数据库，数据库是不受干扰的】【需要redo,不需要undo】</p>
<ol>
<li>把TID写入active list</li>
<li><strong>A.I写入Log</strong></li>
<li>循环2直到所有语句执行完</li>
<li>遇到commit 命令后把TID写入commit list</li>
<li>将改动的数据A.I写入DB</li>
<li>把TID从active list中删除</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Commit list</th>
<th>Active list</th>
<th>Period</th>
<th>Explain</th>
<th>Error process</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>√</td>
<td>1结束4没结束</td>
<td>虽然是部分更新，部分未更新，但是数据库没变（日志有数据？）</td>
<td>delete TID from active list</td>
</tr>
<tr>
<td>√</td>
<td>√</td>
<td>4结束6没结束 正在搬数据</td>
<td>log里面有所有的新的数据，数据库不一致（有新有旧，改了多少不允许，反正redo）</td>
<td>根据Log中的A.I进行redo, 再delete TID from active list</td>
</tr>
<tr>
<td>√</td>
<td></td>
<td>6结束</td>
<td>没事</td>
<td>nothing to do</td>
</tr>
</tbody>
</table>
</div>
<p>和SUX锁协议相匹配，事务运行的并发度较高</p>
<h3 id="A-I→DB-concurrently-with-commit"><a href="#A-I→DB-concurrently-with-commit" class="headerlink" title="A.I→DB concurrently with commit"></a>A.I→DB concurrently with commit</h3><p>在第2种的基础上改进，充分利用系统资源（CPU和I/O）</p>
<p>AI写入DB和commit命令并发执行【可能需要redo ,也可能需要undo】</p>
<ol>
<li>把TID写入active list</li>
<li><strong>A.I 和B.I都写入Log</strong></li>
<li>利用磁盘空闲时用后台线程把A.I（B.I已经记录Log）写入DB，有可能没写完</li>
<li>循环2,3直到语句执行完遇到commit 命令后把TID写入commit list。</li>
<li>确保A.I完全写入DB</li>
<li>把TID从active list中删除</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Commit list</th>
<th>Active list</th>
<th>Period</th>
<th>Explain</th>
<th>Error process</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>√</td>
<td>1结束4没结束</td>
<td>数据库有可能动过，去Log找B.I做undo</td>
<td>undo, delete TID from active list</td>
</tr>
<tr>
<td>√</td>
<td>√</td>
<td>4结束6没结束 正在搬数据</td>
<td>B.I和A.I肯定记录完了，但是A.I可能没有完全更新过去</td>
<td>redo, delete TID from active list</td>
</tr>
<tr>
<td>√</td>
<td></td>
<td>6结束</td>
<td>没事</td>
<td>nothing to do</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Update-Out-of-Place"><a href="#Update-Out-of-Place" class="headerlink" title="Update Out of Place"></a>Update Out of Place</h3><p>异地更新策略，每个物理块保持两个副本（交替使用）和一个页表（Page Table，指针数组，每一项指向当前激活的物理块，现在有1000个物理块，就有1000个指针，每个指针指向这个物理块当前有效的副本的地址）</p>
<p>更新时，就是修改物理块，老的物理块（目前生效的？）不动，新的副本那边做修改，提交时，拨指针，将新的副本作为生效的物理块。</p>
<p>拨指针成功了就是新的一致状态，没成功就是旧的一致状态</p>
<p><img src="/posts/26000/image-20220427150732147.png" alt="image-20220427150732147" style="zoom:67%;"></p>
<p>拨指针的动作需要保证原子性</p>
<h4 id="lorie’s-approach"><a href="#lorie’s-approach" class="headerlink" title="lorie’s approach"></a>lorie’s approach</h4><p><img src="/posts/26000/image-20220427152808527.png" alt="image-20220427152808527" style="zoom:67%;"></p>
<h3 id="恢复过程"><a href="#恢复过程" class="headerlink" title="恢复过程"></a>恢复过程</h3><p><strong>故障类型</strong></p>
<ol>
<li><p>事务故障(Transaction failure):由于某些超出预期的原因 导致该事务不得不中止。</p>
<p>代码写错了，逻辑错误，事务必须滚回</p>
</li>
<li><p>系统故障(System failure):操作系统崩溃了，但磁盘上的数据库没有损坏。如突然断电。</p>
</li>
<li><p>介质故障(Media failure):磁盘故障，数据库被损坏了</p>
</li>
</ol>
<p><strong>解决措施</strong></p>
<ol>
<li>事务故障一定发生在事务提交之前，只需要<ol>
<li>undo</li>
<li>delete TID from active list</li>
</ol>
</li>
<li>系统故障<ol>
<li>重启</li>
<li>根据需求进行undo or redo</li>
</ol>
</li>
<li>介质故障<ol>
<li>换或者修磁盘</li>
<li>装载最近的备份</li>
<li>根据日志做重演(redo)——A.I不能轻易删除</li>
</ol>
</li>
</ol>
<h4 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h4><p><strong>启动类型</strong></p>
<h5 id="emergency-restart"><a href="#emergency-restart" class="headerlink" title="emergency restart"></a>emergency restart</h5><p>在系统或媒体故障后启动。启动前需要恢复。</p>
<h5 id="warm-start"><a href="#warm-start" class="headerlink" title="warm start"></a>warm start</h5><p>正常关机后启动，不需要恢复</p>
<h5 id="cold-start"><a href="#cold-start" class="headerlink" title="cold start"></a>cold start</h5><p>从头开始启动系统。在灾难性故障后启动或启动一个新的数据库。</p>
<h3 id="两段提交协议"><a href="#两段提交协议" class="headerlink" title="两段提交协议"></a>两段提交协议</h3><p><strong>判断是否支持分布式数据库管理的依据</strong></p>
<p>前文的恢复都是基于集中式数据库的</p>
<ul>
<li><p>DDBMS中的事务是<strong>分布式事务</strong>，分布式事务管理的关键是如何保证所有子事务一起提交或一起中止。</p>
<p>银行转账，事务T减钱加钱，分布式环境下，A账户存储在节点1，B账户存储在节点2，T1和T2两个子事务属于事务T，分别在两个节点处理两个账户</p>
</li>
<li><p>实现子交易之间的协同依赖于通信，而通信是不可靠的。</p>
</li>
<li><p>两将军悖论：不存在有限长的可靠协议</p>
<p>Two general paradox，A、B将军攻城，A发信要进攻，但是需要收到B的确认回信才会进攻，否则信丢了A动B不动，而B收到信后回信了，也不可靠，因为他知道A要收到自己的回信才会进攻，信丢了，B动A不动，最后没完没了的通信</p>
</li>
<li><p>解决方法：对信息进行编号，稳扎稳打，步步为营，先走一点点，确保收到回信了，再走一点点<img src="/posts/26000/image-20220428201808001.png" alt="image-20220428201808001"></p>
</li>
<li><p>多将军问题</p>
<p><img src="/posts/26000/image-20220428202220790.png" alt="image-20220428202220790"></p>
<p>coordinator需要确保每个参与者都协调了，必须所有将军都走了一点点了，才能继续下一步</p>
</li>
</ul>
<p><strong>强制写入指不写入就不能继续后续操作</strong></p>
<p><img src="/posts/26000/image-20220428202323672.png" alt="image-20220428202323672" style="zoom:50%;"></p>
<p>一个<strong>子事务</strong>为协调者，其余为参与者，参与者之间不通讯，假定通过日志来进行恢复，那么理想的提交协议应该满足</p>
<ol>
<li>协调者广播一条prepare命令</li>
<li>等待接收参与者的OK 或者 not OK命令</li>
<li>所有都收到后，检查结果</li>
<li>如果都是OK，返回Commit，此时协调者开始进行事务提交了</li>
<li>如果有至少一条NOT OK，返回Abort</li>
<li>等待接收所有参与者的Ack，否则会重发commit或者abort</li>
<li>最后才能结束事务</li>
</ol>
<p>每个参与者，回答OK之前，具备自主权，转账例子上，余额不够的话，先把A账号的子事务Abort，回答not OK即可，一旦回答OK之后，就丧失了自主权，存在<a name="阻塞"><strong>阻塞问题</strong></a></p>
<p>如果协调者在参与者回答OK后出现故障，没办法把Commit/Abort发出去，那么参与者必须等待，并处于阻塞状态。</p>
<p><strong>后续内容已经有点涉及到Presumed Abort的意思</strong></p>
<p><strong>prepare</strong></p>
<p>对于协调者而言</p>
<ol>
<li><p>协调者广播一条prepare命令，告诉大家要开始commit了</p>
</li>
<li><p>每个参与者会回复OK or not OK</p>
<ol>
<li>所有参与者都回复OK</li>
<li>至少收到了一条not OK</li>
</ol>
<p>上述两个条件满足其一即可进入commit阶段</p>
</li>
</ol>
<p>对于参与者而言</p>
<ol>
<li><p>接收到prepare，根据自身情况看是否可以commit</p>
<ol>
<li><p>同意commit</p>
<ol>
<li>强制写入一个prepare的日志记录</li>
<li>返回ok给协调者</li>
<li>进入准备状态，等待协调者发布最终处理结果</li>
</ol>
</li>
<li><p>拒绝commit</p>
<ol>
<li><p>强制写入一个abort的日志记录</p>
</li>
<li><p>返回not ok给协调者</p>
</li>
<li><p>在本地终止事务，释放所有锁，并 “忘记 “它。</p>
<p>这是安全的，因为只要自己返回了 not ok，协调者只能abort</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>commit</strong></p>
<p><strong>如果有至少一个not OK，此时可能还有参与者未回复，但是协调者已经可以进行后续操作</strong></p>
<ol>
<li><p>强制写入一个abort记录到日志</p>
</li>
<li><p>给<strong>所有处于准备状态的参与者</strong>以及<strong>还未回应OK还是not OK的参与者</strong>都回复Abort</p>
<p>回应了not OK的不用发送abort了，因为他们本地已经Abort了</p>
</li>
<li><p>等待接收来自步骤2接收Abort信息的参与者返回的ACK消息</p>
<p>同理，也不需要等待接收那些not OK的参与者</p>
</li>
<li><p>写入一个end记录，忘记该事务</p>
</li>
</ol>
<p><strong>如果全部都是OK，那么协调者</strong></p>
<ol>
<li>强制写入一个commit记录到日志，事务到达提交点，用户可以被告知事务完成被提交了</li>
<li>发送commit命令给<strong>所有参与者</strong></li>
<li>等待接收来自所有参与者的Ack</li>
<li>写入end记录，忘记该事务</li>
</ol>
<p>Ack用于确保每个参与者都能得知并且执行最终的决定</p>
<p><strong>只有回复了OK的参与者会进入commit阶段，接收到commit命令</strong></p>
<ol>
<li>强制写入commit记录</li>
<li>返回Ack</li>
<li>提交事务，并且忘记</li>
</ol>
<p>收到Abort命令</p>
<ol>
<li>强制写入abort记录</li>
<li>返回ack</li>
<li>终止事务，并且忘记</li>
</ol>
<p>发送ACK前要求参与者写入commit或者abort，确保参与者收到commit和abort命令后，不需要询问协调者最终的结果就可以进行故障恢复</p>
<p><strong>故障处理</strong></p>
<p>假设每个节点都设置故障恢复模块，它处理来自其他节点恢复进程的所有消息，并处理在该节点最后一次故障时正在执行提交协议的所有事务</p>
<p>对于故障发生时执行的每一个事务，恢复进程依据不同情况作不同处理</p>
<ol>
<li><p><strong>没有任何形式的2PC协议记录</strong></p>
<p><strong>基于undo记录撤销、并终止该事务，记录abort，忘记它</strong></p>
</li>
<li><p>或者协调者收集所有参与者的日志信息发现有事务处于提交或中止状态</p>
<p>定期尝试向所有尚未发送ack的参与者发送commit或者abort命令，直到收到所有回复，记下end，忘记该事务</p>
</li>
<li><p>或者（某个特定）事务处于准备状态（等待结果决定）</p>
<p>定期尝试联系协调者，确认应该如何处理，收到commit或者abort后做出相应处理</p>
</li>
</ol>
<p>当一个恢复进程收到来自准备状态的参与者节点的查询信息时，它会查看它有哪些关于该事务的信息。如果已知该事务处于中止或提交状态，那么它将发送对应的响应。</p>
<p>如果没有发现关于该事务的任何信息时，又该如何处理呢？</p>
<p>由于COMMITS和ABORTS都被确认，所以在协调者忘记事务前，参与者发送查询信息是由于参与者没有收到并且处理commit或者abort</p>
<ol>
<li>协调者发送prepares</li>
<li>在收到所有投票并决定commit/abort前崩溃了</li>
<li>重启时，abort命名没有通知给参与者</li>
</ol>
<h3 id="R-事务处理管理"><a href="#R-事务处理管理" class="headerlink" title="R*事务处理管理"></a>R*事务处理管理</h3><p>事务——是执行的一个原子的可持续的单元，由一个或多个SQL语句构成，语句封闭在一个begin-transaction和一个end-transaction中，并且给事务赋予唯一的事务处理标识符，由地点标识符和顺序号码构成。</p>
<p><strong>并发控制</strong></p>
<p>并发控制通过两段加锁协议实现，事务持有数据对象的锁直到事物结束或者异常终止</p>
<p>当检测到死锁时，由异常来终止 等待循环内的 一个事务的来消除死锁，一般终止完成极少工作的事务</p>
<p><strong>优化的两阶段提交协议</strong></p>
<p>目的是改进信息交换和重演日志上的操作的性能</p>
<p>force a log表示将运行记录拷贝到硬盘的操作</p>
<p>write a log表示将运行记录写进内存的操作</p>
<p>问题：在将记录拷贝到硬盘前，系统故障可能导致日志丢失</p>
<p>两阶段提交协议在接收Prepare后，可以发送abort终止事务，掌握了自主权；但是一旦回复了OK，那么就丧失自主权了。</p>
<h3 id="假定异常终止协议"><a href="#假定异常终止协议" class="headerlink" title="假定异常终止协议"></a>假定异常终止协议</h3><p>只要有一个not OK 那么就可以进入commit阶段了</p>
<p><strong>如果有至少一个not OK，此时可能还有参与者未回复，但是协调者已经可以进行后续操作</strong></p>
<ol>
<li><p>强制写入一个abort记录到日志</p>
</li>
<li><p>给<strong>所有处于准备状态的参与者</strong>以及<strong>还未回应OK还是not OK的参与者</strong>都回复Abort</p>
<p>回应了not OK的不用发送abort了，因为他们本地已经Abort了</p>
</li>
<li><p>等待接收来自步骤2接收Abort信息的参与者返回的ACK消息</p>
<p>同理，也不需要等待接收那些not OK的参与者</p>
</li>
<li><p>写入一个end记录，忘记该事务</p>
</li>
</ol>
<p>当恢复机构没有事务的标识符时，就假定该事务已经被异常终止了</p>
<p>在决定中止事务后，协调者立即 “忘记 “该交易（第一次收到NO）并写下中止记录是安全的操作，有以下意义</p>
<ol>
<li><p>abort记录不需要强制写入，没有相当于也是终止</p>
<p>强制写入指不写入就不能继续后续操作</p>
</li>
<li><p>参与者无需为终止返回ACK</p>
</li>
<li><p>协调者无需在终止记录中记下每个参与者的名字，也不需要记录end</p>
</li>
<li><p><strong>如果协调者在发送abort命令时，发现某个参与者有问题，不需要反馈给恢复进程，而是让参与者通过参与者的恢复进程发出查询得知需要进行终止即可</strong></p>
</li>
</ol>
<p>如果我们利用完全或部分只读事务的优势，我们可以做得更好。部分只读事务是指一个或多个参与的进程不执行任何更新，但其他进程执行更新。我们不需要事先知道只读的状态。除了基本协议中的OK和NOT OK之外，我们还增加了一个READ</p>
<ol>
<li>如果一个参与者收到一个prepare，并且它没有做任何更新，它就会发送一个READ，释放它的锁，并且 “忘记 “这个事务。没有日志记录被写入—对它来说，事务被中止或提交没有区别</li>
<li>协调者不向发送READ的参与者发送任何COMMIT或ABORT消息</li>
</ol>
<p>如果协调者本身只读的，并且只接收到READ，相当于完全只读，那么协议就不会有第二阶段，协调人也不写日志记录。</p>
<h3 id="假定提交协议"><a href="#假定提交协议" class="headerlink" title="假定提交协议"></a>假定提交协议</h3><p>由于大多数事务都要提交，那么能否通过要求对ABORTS的ACK，取消COMMITS的ACK来使提交成本降低。</p>
<p>要求ABORTS被确认，而COMMITS不需要，同时要求abort记录被强制执行，而commit记录不需要由参与者执行。其结果是，在没有信息的情况下，当参与者查询时，恢复过程会以COMMIT来响应。然而，这种方法有一个问题：</p>
<p>考虑一个已经发出PREPARE消息的协调者，仍然在等待所有的反馈回来。其中一个下属发送了一个OK，并进入了准备状态。然后协调者崩溃了。此时，协调者没有写任何日志记录。因此，当协调者的节点恢复时，它将发现没有关于该事务的信息，因此中止并 “忘记 “它。但是当参与者恢复进程查询时，在发现没有信息时，它将被发送一个COMMIT消息，导致不一致。</p>
<p>为了解决这个问题，协调者需要在发送任何PREPARE消息之前安全地记录其参与者的名字。它通过强行写入一个收集记录来做到这一点。这样，当协调者在恢复时中止，它将知道该通知谁（并获得ACK）进行中止。</p>
<p>协调者改进如下</p>
<ol>
<li>在发送prepare之前强制写入收集表信息，包含参与者的名称</li>
<li>强制写入abort命令</li>
<li>abort需要返回ack，commit不需要</li>
<li>只在abort后写入end</li>
</ol>
<p>参与者改进如下</p>
<p>参与者只强制写中止记录，而不写提交记录。他们只 ACK ABORTs，而不是 COMMITs</p>
<p>在重启时，如果恢复进程发现某个事务有收集记录但没有后续记录，它就会遵循中止协议。在没有信息的情况下，它用一个COMMIT来响应查询。</p>
<h3 id="PA-VS-PC-VS-2P"><a href="#PA-VS-PC-VS-2P" class="headerlink" title="PA VS PC VS 2P"></a>PA VS PC VS 2P</h3><ol>
<li>在所有情况下，PA都优于或等于2P。</li>
<li>在完全只读事务的情况下，PA比PC好</li>
<li>在部分只读事务，并且只有协调者做更新的情况下，PA也比PC好。</li>
<li>在事务只有一个参与者更新的情况下，PA和PC在日志记录方面等效，但是PC比PA能够节省一条ACK信息</li>
<li>对于一个有n&gt;1个更新参与者的事务，PA和PC都需要写相同数量的记录，但是PA会强制写n-1次，而PC不会。PA也将发送n个额外的ACK消息</li>
<li>对于参与者而言，PC比PA有效地多，因为PC能成功地完成更新事务，因为其不需要ack和提交记录的人工转移</li>
<li>对于只读事务的参与者而言，PA比PC有效，因为记录参与者标识的收集（存在硬盘）不需要人工运输到协调者去</li>
<li>R*中可以为单独的事务设置提交协议，PA为只读事务准备，PC为其他事务准备。</li>
</ol>
<h3 id="三段提交协议"><a href="#三段提交协议" class="headerlink" title="三段提交协议"></a>三段提交协议</h3><p>解决两段提交协议的阻塞问题</p>
<p><img src="/posts/26000/image-20220428203122464.png" alt="image-20220428203122464" style="zoom:67%;"></p>
<ol>
<li><p>广播预备提交信息</p>
</li>
<li><p>回答 Ready 或者 Abort</p>
<ol>
<li><p>参与者收到回信后，全部都是Ready，就会回复prepare to commit的消息</p>
<p>这个消息会被参与者记到磁盘上，回答OK</p>
</li>
<li><p>如果有Abort，那么就直接发送Abort。此时，磁盘上也不会存prepare to commit</p>
</li>
</ol>
</li>
<li><p>正常会得到所有的OK后，回复Commit 或者 Abort的命令</p>
</li>
<li><p>参与者回复ACK</p>
</li>
</ol>
<p>如果协调者不出错，阶段二无效</p>
<p>如果协调者在参与者回答OK后出现故障，超时，参与者互相通信选出一个新的协调者。</p>
<p>协调者会检查所有参与者是否存储了prepare to commit的信息，如果所有参与者上都有这个消息，就发出Commit命令，否则Abort，存储下这个操作能够告诉给原来的协调者做了啥命令</p>
<p>如果协调者在发出Abort之前G了，自己已经Abort，prepare to commit也不会发送出去，新的协调者也会Abort，还是一致状态</p>
<p>两阶段，协调者在故障前可能已经Commit或者Abort了（难以保持一致），但是命令没发出去</p>
<p>三阶段发出的是消息，可以反悔，协调者时间上还没有做操作，其实就是加了一层记录到磁盘的操作</p>
<p>很少用三段，效率低，绝大部分用不到阶段2</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-数据分布</title>
    <url>/posts/33675.html</url>
    <content><![CDATA[<h3 id="数据分布策略"><a href="#数据分布策略" class="headerlink" title="数据分布策略"></a>数据分布策略</h3><ol>
<li><p>集中式分布</p>
<p>虽然是分布式系统，但是数据仍然是集中式存储的，一个节点上，最简单的存储方式，但是没有利用到分布式存储的优势</p>
</li>
<li><p>划分分布</p>
<p>数据划分开进行分区分布，没有副本，节点存储的数据没有交集，逻辑上集中存储，物理上分区分布</p>
</li>
<li><p>复制分布</p>
<p>在每个节点上都复制一份数据库原始数据，适用于以查询为主的系统（人口普查、比特币区块链），更新不频繁</p>
</li>
<li><p>混合型</p>
<p>综合上述3种分布策略，最灵活、最复杂，每个节点根据自己的需求选择合适自己的分布策略</p>
</li>
</ol>
<p><img src="/posts/33675/image-20220411163341118.png" alt="image-20220411163341118" style="zoom:50%;"></p>
<h3 id="数据分布单位"><a href="#数据分布单位" class="headerlink" title="数据分布单位"></a>数据分布单位</h3><p>以什么单位进行数据分布</p>
<ol>
<li><p>以关系（文件）为单位，对关系不做更细的划分</p>
<p>学生基本信息表很多地方都要用，只放在一个地方，很难使用，比如计算机学院只需要计算机系的学生，其他的学生不用存在我这里，只需要将计算机系学生存到我这里就行</p>
<p>教务处只需要访问学生的学号、姓名、年龄这几条属性，其他的不管</p>
<p>学生处需要家庭住址、籍贯等其他信息</p>
<p>也不需要整个表放到这几个地方</p>
</li>
<li><p>分页</p>
<p>按照裂片进行划分</p>
<ol>
<li><p>水平分割(Horizontal fragmentation)</p>
<p>学生基本信息表按照院系进行划分</p>
</li>
<li><p>垂直划分(Vertical fragmentation)</p>
<p>学生基本信息表按照属性进行切割</p>
</li>
<li><p>混合分割(Mixed fragmentation)</p>
<p>先水平分割再垂直分割或者反过来</p>
</li>
</ol>
</li>
</ol>
<h3 id="数据分割准则"><a href="#数据分割准则" class="headerlink" title="数据分割准则"></a>数据分割准则</h3><ol>
<li>完整性(Completeness)：分割的时候不能丢失信息，每一条元祖或者某一条属性必须能够在某个地方存在</li>
<li>重构性(Reconstruction)：分割后能够重构</li>
<li>不相交性(Disjointness)：针对水平分割，某元组水平分割后只能属于一个裂片</li>
</ol>
<h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><p>选择操作，重构时采用并（union）操作</p>
<p><img src="/posts/33675/image-20220411164156959.png" alt="image-20220411164156959" style="zoom:50%;"></p>
<p>任意两个谓词的与为空集，不能相交</p>
<p>所有谓词的或是永增的，能够重构</p>
<h3 id="导出分割"><a href="#导出分割" class="headerlink" title="导出分割"></a>导出分割</h3><p>关系不是根据自己的属性值进行分割，而是按照另外一个关系的水平分割来对自己做水平分割</p>
<p><strong>示例</strong></p>
<p>TEACHER(TNAME, DEPT): 教师表，教室名称（无重名）和所属院系</p>
<p>COURSE(CNAME, TNAME): 课程表，课程名称和授课教师名字</p>
<p>假设 TEACHER这张表已经根据所属院系进行了水平分割，我们想要课程表也能据此进行分割，即便没有院系这个属性，理论上通过授课教师姓名就能分割，这就叫导出分割<br><a name="Semi join">Semi join</a>: $R⋉S = \Pi_R(R⋈S)$</p>
<p>R和S的半连接就是R和S的自然连接再投影到R的属性上，实际上就是把关系R里面满足连接条件的元组拿出来而不被关系S的属性“污染”</p>
<p>比如</p>
<p>$TEACHER⋉COURSE = \Pi_{TEACHER}(TEACHER⋈COURSE)$</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TEACHER9 <span class="operator">=</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TEACHER <span class="keyword">WHERE</span> DEPT<span class="operator">=</span>‘<span class="number">9</span>th’;</span><br><span class="line"></span><br><span class="line">COURSE9<span class="operator">=</span>COURSE⋉TEACHER9</span><br></pre></td></tr></table></figure>
<p>这样就能把COURSE表里面符合“9th”的教师姓名相等的连接条件的元组提取出来</p>
<h3 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h3><p>投影操作($\Pi $)，join操作进行重构</p>
<ul>
<li><p>完整性：每个属性需要至少出现在一个裂片</p>
</li>
<li><p>重构：需要满足无损连接分解，关系分解后，再连接，完美还原原始数据，才能叫无损连接分解</p>
<p>$SPJ(供应商,零件,工程)是否等于SP⋈PJ⋈SJ$</p>
<p>相等，也就是无损连接分解，成立的条件是：某供应商如果能够生产某零件，那么某工程只要需要该零件，就必须去这个供应商采购（非平凡的连接依赖）</p>
<p>满足下述两个条件之一即可满足重构性</p>
<ol>
<li><p>每个裂片都需要拥有原始关系的<a name="重构性">主键</a></p>
<p>(学号,姓名,年龄)→(学号,姓名) and(学号,年龄)</p>
<p>但是有的表的主键太多了，这样垂直分割就无意义了</p>
</li>
<li><p>每个裂片都拓展TID的唯一属性，自增序号，不重复，其实也是主键了</p>
</li>
</ol>
</li>
</ul>
<h3 id="混合分割"><a href="#混合分割" class="headerlink" title="混合分割"></a>混合分割</h3><p><img src="/posts/33675/image-20220411170915837.png" alt="image-20220411170915837" style="zoom:67%;"></p>
<p>先水平后垂直</p>
<h3 id="数据透明级别"><a href="#数据透明级别" class="headerlink" title="数据透明级别"></a>数据透明级别</h3><p>通过<strong>目录管理</strong>来实现</p>
<p>分布的透明性级别，级别越小越牛逼</p>
<p>透明性：用于信息隐藏，透明性屏蔽底层的复杂的技术细节，简化问题，网络协议的底层对上一层就是黑盒</p>
<h4 id="level-1-裂片透明性"><a href="#level-1-裂片透明性" class="headerlink" title="level 1-裂片透明性"></a>level 1-裂片透明性</h4><p>数据在物理上是分布的，但是在逻辑上是集中式的，用户看到的就是逻辑上的关系，感知不到分布式数据</p>
<h4 id="level-2-位置透明性"><a href="#level-2-位置透明性" class="headerlink" title="level 2-位置透明性"></a>level 2-位置透明性</h4><p>用户需要知道关系是如何分割的，但是不需要关心数据裂片存储在哪里（物理存储在哪？有没有副本？）</p>
<h4 id="level-3-局部映射透明性"><a href="#level-3-局部映射透明性" class="headerlink" title="level 3-局部映射透明性"></a>level 3-局部映射透明性</h4><p>只能屏蔽局部数据库的异构性</p>
<p>用户需要知道关系是如何分割的以及它们是如何分布的。但他不需要担心每个本地的数据库由什么样的DBMS管理，可能是异构的（ORACLE、MYSql等等），使用什么样的DML等等。</p>
<p>写程序都得根据节点使用的DBMS来调整代码</p>
<p>自然最后一个就是<strong>没有透明性</strong>，简单搭了一个分布式数据库</p>
<h3 id="分布式数据库设计"><a href="#分布式数据库设计" class="headerlink" title="分布式数据库设计"></a>分布式数据库设计</h3><p><strong>设计问题</strong></p>
<ol>
<li><p>裂片设计</p>
<p>水平、垂直、按照什么条件进行分割</p>
</li>
<li><p>裂片分布方案设计</p>
<p>每个裂片应该存放在哪个节点，是否需要副本</p>
</li>
</ol>
<p><strong>设计依据</strong></p>
<p>用户需求</p>
<ol>
<li><p>可能发生某种业务（登记成绩、选课等等）的节点是哪些？</p>
</li>
<li><p>这种业务的发生频率如何</p>
<p>两种业务需求的分布方案冲突，以频率高的业务需求为主</p>
</li>
<li><p>这个业务需要访问哪些数据对象</p>
</li>
</ol>
<p><strong>设计流程</strong></p>
<p><a href="D:\Cloud\东南大学-研究生\OneDrive - 东南大学\同步盘\数据库管理系统及其实现\本科\Design Of Database.md">集中式数据库设计流程</a></p>
<p><strong>集中式</strong></p>
<p><img src="/posts/33675/image-20220406145943349.png" alt="image-20220406145943349" style="zoom: 33%;"></p>
<ol>
<li><p>Requirement Analysis</p>
<p>需求分析，与用户交流确定需求</p>
<ol>
<li><p>Information requirement</p>
<p>每一项业务需要涉及到哪些信息</p>
</li>
<li><p>Process requirement</p>
<p>每一项业务需要对这些数据做什么处理（增删改查）</p>
</li>
<li><p>Requirement indication</p>
<p>结果是得到需求分析报告，需要和用户反复讨论、确认</p>
</li>
</ol>
</li>
<li><p>Concept Design</p>
<p>概念设计，与用户讨论，分析数据之间的关系（实体）、实体及实体间的逻辑，利用ER图来进行描述，和用什么数据库系统实现无关</p>
<p>得到DBMS independent data schema</p>
<p>确保用户的所有业务都能在我们设计的schema基础上顺利执行</p>
</li>
<li><p>Logic Design</p>
<p>逻辑设计，看采用哪一种数据库系统，生成全局模式（基表的属性、属性类型等等）【<strong>concept schema</strong>】，定义视图【<strong>outer schema</strong>】</p>
</li>
<li><p>Physical Design</p>
<p>物理设计，考虑数据在磁盘上到底如何存储，默认都是堆文件，但是比如学生基本信息表比较适合用簇集，而在某些属性上是否应该添加B+树索引</p>
<p>得到【<strong>inner schema</strong>】</p>
</li>
</ol>
<p><strong>分布式</strong></p>
<p><img src="/posts/33675/image-20220412121337660.png" alt="image-20220412121337660"></p>
<h4 id="裂片设计"><a href="#裂片设计" class="headerlink" title="裂片设计"></a>裂片设计</h4><p><strong>示例</strong></p>
<p>业务1：记录查询（每天&gt;30次）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> GRADE <span class="keyword">FROM</span> STUDENT </span><br><span class="line"><span class="keyword">WHERE</span> DEPT<span class="operator">=</span>‘<span class="number">9</span>th’ <span class="keyword">AND</span> AGE<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>按照院系水平分割，数据置于本地直接查询比较合适</p>
<p>业务2：统计查询（一学期几次查询）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> STUDENT </span><br><span class="line"><span class="keyword">WHERE</span> SEX<span class="operator">=</span>‘Male’;</span><br></pre></td></tr></table></figure>
<p>按照院系水平分割，再做统计查询就很难使用</p>
<p>这两个应用谁更重要，更为频繁，发现业务1更为频繁，所以还是要做水平分割</p>
<p><strong>原则</strong></p>
<ol>
<li><p>选择一些重要、典型频繁发生的业务作为首要考虑点</p>
</li>
<li><p>分析这些业务对数据访问是否具备局部性（计算机学院只关心本院的学生）</p>
</li>
<li><p>如果有局部性需求，那么需要进行分割操作</p>
<ol>
<li><p>水平分割</p>
<ol>
<li><p>选择合适的谓词将全局关系分割成合适的裂片，如果存在分割冲突（院系分还是籍贯分），则优先考虑更为重要、频繁的业务</p>
</li>
<li><p>分析连接操作，决定是否有必要做导出分割以减少跨节点连接操作的开销</p>
<p>$R→R_1,R_2,…,R_n$<br>$S→S_1,S_2,…,S_m$</p>
<p>用户要做一个查询，需要R和S的分布式连接（两两连接再做并集，代价很大）</p>
<p>$R⋈S=∪_{i=1,j=1}^{i=n,j=m}R_i⋈S_j$</p>
<p>Join Graph</p>
<p>Distributed Join</p>
<p><img src="/posts/33675/image-20220412153606215.png" alt="image-20220412153606215" style="zoom:67%;"></p>
<p>如果能够化简为simple join，那么只要把对应的R和S存储到一个节点做连接，最后结果做一次交集即可大大减少时间开销</p>
<p>如果关系$R$已经决定分割成$R_1,R_2,…,R_n$这$n$个裂片</p>
<p>并且实际应用中发现关系$R$和关系$S$的连接非常频繁</p>
<p>则需要将关系$S$按照关系$R$做导出分割，使得$S_i=S⋉R_i$→<a href="#Semi join">Semi join</a></p>
<p>把关系$R$和$S$的对应裂片存放到同一个节点</p>
<p>连接时就可以按照simple join来执行</p>
</li>
</ol>
</li>
<li><p>垂直分割</p>
<ol>
<li>分析属性之间的亲密度，哪些属性经常同时访问（在同一条sql里面出现），决定垂直分割的方案<ul>
<li>考虑如何节省空间开销（重复存储好几个属性组成的主键→<a href="#重构性">重构性</a>）和I/O开销</li>
<li>考虑安全性，一些属性不应该被用户看到</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>分布式设计</p>
<p>通过开销预估，决定每个裂片的存储节点</p>
<ol>
<li><p>水平分割</p>
<ol>
<li><p>无副本方案</p>
<p>对$R_i$，计算$B_{i,j}=\sum_{r_fre_in_j_to_i}+\sum_{w_fre_in_j_to_i}$(将裂片$i$存放到节点$j$能够得到的好处，在节点$j$对裂片$i$的所有读、写操作的频率)</p>
<p>找到最大的$B_{i,j}$</p>
</li>
<li><p>有副本方案</p>
<p>在$j$上放一个$i$的副本，依然要计算$B_{i,j}=\sum_{good}-\sum_{bad}$，有利因素和刚刚那个一样，不利因素是除了节点$j$以外，其他节点要对$i$做写操作，因为一旦要修改$i$，那么就得过来更新这边的副本，如果频繁更新，那么不利因素就很大</p>
<p>大于0，可以放置一个副本</p>
</li>
</ol>
</li>
<li><p>垂直分割</p>
<p>原始的算法采用穷举的方法（穷举切在哪里，穷举切完后怎么放置），混合考虑裂片设计和裂片分布设计</p>
<p>考虑属性是否要切一刀，前面放一个节点，后面放在另外一个节点</p>
<p><img src="/posts/33675/image-20220412160728313.png" alt="image-20220412160728313"></p>
<p>再次计算$B_{ist}=\sum_{good}-\sum_{bad}$</p>
<p>good: 对节点s上只需要访问$R_s$这部分属性的业务是有利的，对节点t上面只需要访问$R_t$这部分属性的业务也是有利的</p>
<p>bad: 对其他节点需要同时访问$R_s$和$R_t$这部分属性的业务是不利的，其他节点需要对$R_i$进行更新操作的业务也是不利的，因为一旦要更新，也得访问这块内容</p>
<p>同样是大于0就可以这样切一刀</p>
<p>改进，考虑了属性的亲密性，先做分割，再考虑分布</p>
</li>
</ol>
</li>
</ol>
<h3 id="并行数据库设计"><a href="#并行数据库设计" class="headerlink" title="并行数据库设计"></a>并行数据库设计</h3><h4 id="PDB定义"><a href="#PDB定义" class="headerlink" title="PDB定义"></a>PDB定义</h4><p>并行计算机系统</p>
<ol>
<li>早期一台计算机多个CPU共享一个内存、一块硬盘</li>
<li>后来一台计算机多个CPU各自附带内存但是依然共享硬盘</li>
<li>后来一台计算机多个CPU各自附带内存、硬盘（Share Nothing Structure, SN结构）</li>
</ol>
<p>针对并行计算机系统结构进行底层优化的数据库系统就叫并行数据库</p>
<h4 id="垂直并行"><a href="#垂直并行" class="headerlink" title="垂直并行"></a>垂直并行</h4><p>计算步骤上面的并行处理，只要某些步骤没有绝对的先后执行要求，就可以同时执行，任何一个并行计算机系统都能支持垂直并行，<strong>所以不需要针对垂直并行特别设计数据库系统</strong>。</p>
<h4 id="水平并行"><a href="#水平并行" class="headerlink" title="水平并行"></a>水平并行</h4><p>典型的比如数据库的扫描操作（选择），被扫描的关系如果事先被划分成多个裂片存储在SN结构计算机的多个硬盘上（<strong>前提→并行数据库的设计问题</strong>），那么这个扫描进程就可以在这些硬盘上并行执行。</p>
<p><strong>示例</strong></p>
<p><img src="/posts/33675/image-20220413101759867.png" alt="image-20220413101759867" style="zoom:50%;"></p>
<h4 id="DDB-with-PDB"><a href="#DDB-with-PDB" class="headerlink" title="DDB with PDB"></a>DDB with PDB</h4><p><img src="/posts/33675/image-20220413102734697.png" alt="image-20220413102734697" style="zoom:67%;"></p>
<p><img src="/posts/33675/image-20220524203626920.png" alt="image-20220524203626920"></p>
<h4 id="PDB数据裂片模式"><a href="#PDB数据裂片模式" class="headerlink" title="PDB数据裂片模式"></a>PDB数据裂片模式</h4><ol>
<li><p>任意分割</p>
<p>以任意模式对关系R进行分割处理（平均、随便分、哈希等等），然后将这些碎片存储在不同处理器的磁盘上。</p>
</li>
<li><p>基于表达式</p>
<p>基于若干个谓词进行选择分割，适用于基于条件的查询</p>
</li>
</ol>
<h4 id="PDB-VS-DDB"><a href="#PDB-VS-DDB" class="headerlink" title="PDB VS DDB"></a>PDB VS DDB</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>PDB</th>
<th>DDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>裂片和分布的目标</td>
<td>提高并行度，尽可能利用并行系统的高并发度</td>
<td>提高数据访问的局部性，减少网络上的数据传输</td>
</tr>
<tr>
<td>数据分割依据</td>
<td>考虑并行计算机系统的特征，结合应用需求</td>
<td>应用需求，结合考虑分布式系统特性</td>
</tr>
<tr>
<td>分布模式</td>
<td>在一台计算机的多个硬盘上分布</td>
<td>在网络上的多个节点上分布</td>
</tr>
</tbody>
</table>
</div>
<h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><p><img src="/posts/33675/image-20220413103842538.png" alt="image-20220413103842538"></p>
<h3 id="联邦式数据库设计"><a href="#联邦式数据库设计" class="headerlink" title="联邦式数据库设计"></a>联邦式数据库设计</h3><p><strong>基本概念</strong></p>
<p><strong>需求：</strong>整合许多现存的、分布式和异构的数据库</p>
<p><strong>定义：</strong>联邦数据库的每个数据库都是自治的，能够在协商的基础上相互协作</p>
<p><strong>特性：</strong></p>
<ol>
<li>在联邦数据库中不存在全局模式（schema），每个成员都拥有自己的数据模式</li>
<li>每个成员互相协商以确定自己的输入（拿过来）和输出（分享出去）模式，最终建立数据的共享模式</li>
</ol>
<p><strong>示意图</strong></p>
<p><img src="/posts/33675/image-20220415153926892.png" alt="image-20220415153926892" style="zoom:67%;"></p>
<p>$FS_i=CS_i+IS_i$</p>
<p>$FS_i$是节点1的用户所能使用的数据总和，针对$FS_i$进行查询</p>
<p>$IS_i$是节点1通过协商从别的节点的$ES_j$上能够获取到的数据</p>
<p>在$FS_i$的查询=&gt;在$CS_i$和$IS_i$上的子查询=&gt;在相应$ES_j$上的子查询</p>
<p>从$ES_j$上获取的结果=&gt;结果需要转换成$IS_i$上的形式，并且和在$CS_i$上的查询结果相结合，最后整合为$FS_i$的最终结果，反馈给用户</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-数据库访问管理</title>
    <url>/posts/27905.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>对任何数据库的访问，最终都是转换成在操作系统层对文件的操作</p>
<p>没有任何一种文件组织结构适用于所有的数据访问类型</p>
<h3 id="访问类型"><a href="#访问类型" class="headerlink" title="访问类型"></a>访问类型</h3><ol>
<li>查询一个文件（表）的大部分元组<ul>
<li>判定标准：查询设计的元组数占该关系总元组数的15%以上</li>
<li>以15%为标准的原因：硬盘是块设备，数据库存储在硬盘上，以物理块（1024byte 10个元组）为单位读写（每次I/O），当占了15%，那么要访问该关系的全部的物理块。</li>
</ul>
</li>
<li>查找某条\某几条特定元组</li>
<li>查找若干条元组【不超过15%】</li>
<li>范围查询 查询结果不好确定</li>
<li>更新</li>
</ol>
<h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><h4 id="堆文件"><a href="#堆文件" class="headerlink" title="堆文件"></a>堆文件</h4><p>随着数据写入不停向文件尾部写</p>
<ul>
<li>最常见、最基础的文件组织方式</li>
<li>访问方式：顺序扫描</li>
<li>适用于查询一个文件的大部分元组，不适应于特定记录的查询</li>
</ul>
<h4 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h4><p>对特定属性值建立Hash函数，将Hash值相同的数据的存储地址散列到同一个Direct File去</p>
<ul>
<li>用户在根据哈希属性进行查询某条或者若干条数据时效率更快</li>
<li>如果查询不是针对哈希属性，那么效率较低</li>
</ul>
<h4 id="堆文件-B-树索引"><a href="#堆文件-B-树索引" class="headerlink" title="堆文件+B+树索引"></a>堆文件+B+树索引</h4><p>将关系存为堆文件上，在多个属性（更新较少，查询较多）上加上B+树索引，叶子节点保存数据在磁盘的存储位置</p>
<ul>
<li>需要全表扫描，就利用堆文件存储</li>
<li>需要按照某属性进行搜索，就按照对应的B+树索引</li>
</ul>
<h4 id="RAW-DISK机制-Clustering"><a href="#RAW-DISK机制-Clustering" class="headerlink" title="RAW DISK机制/Clustering"></a>RAW DISK机制/Clustering</h4><p>DBMS借助RAW DISK机制一次性向操作系统申请一大块空间，自己做一个文件管理，可以将某张表按照某个属性从小到大进行存储（如学号），这种存储组织方式就叫簇集</p>
<ul>
<li>比文件管理更底层的一套管理数据存储的机制</li>
<li>允许用户自己控制数据在磁盘上如何存储（簇集便于寻找），平时是操作系统决定如何存储（逻辑顺序和物理顺序不一致）</li>
</ul>
<h4 id="动态哈希"><a href="#动态哈希" class="headerlink" title="动态哈希"></a>动态哈希</h4><p>静态哈希的映射空间是固定的，因此频繁的数据更新使得静态Hash不适用于数据库系统，动态哈希应运而生，桶的树木可以动态变化</p>
<p>线性散列的基本思想是让桶的数量随着溢出的增加而逐步增加，随着桶的负载减少而逐步减少</p>
<h4 id="栅格结构文件"><a href="#栅格结构文件" class="headerlink" title="栅格结构文件"></a>栅格结构文件</h4><ul>
<li>多维数组，可以把满足同样属性条件的元组簇集存放</li>
<li>适用于按照多个属性值（性别、出生年）进行查询</li>
<li>不按照这几个属性查询，效率就较低</li>
</ul>
<h3 id="索引技术"><a href="#索引技术" class="headerlink" title="索引技术"></a>索引技术</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>【常用】</p>
<ol>
<li>树根到叶子的中间节点均为索引（某属性的具体值，路标作用），只有叶节点存储数据的地址信息</li>
<li>叶节点自左向右有小到大排列</li>
<li>叶节点间通过双向链表连接，便于范围查找</li>
</ol>
<p><img src="/posts/27905/image-20220411151042892.png" alt="image-20220411151042892" style="zoom:50%;"></p>
<h4 id="簇集索引"><a href="#簇集索引" class="headerlink" title="簇集索引"></a>簇集索引</h4><p>【常用】</p>
<p>是一种文件组织方式，本身是有序的</p>
<p>大部分时间按学号查询学生，那么就按照学号对学生进行簇集存储，在非簇集的属性上加索引也能方便针对其他属性的查询</p>
<h4 id="倒排文件"><a href="#倒排文件" class="headerlink" title="倒排文件"></a>倒排文件</h4><p> 文献检索系统</p>
<h4 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h4><p>常用于 数据仓库</p>
<p>位图索引的维护代价非常大，经常的删改不适用于位图索引</p>
<p>位图索引，用于数据仓库，适用于按列做数据统计、分析</p>
<p>索引本身即是数据</p>
<p><img src="/posts/27905/image-20220411151517861.png" alt="image-20220411151517861" style="zoom:67%;"></p>
<p>每个索引表对应原表的一个属性，以Sales、State、Class三个属性所建立的索引表为例</p>
<p><img src="/posts/27905/image-20220411151603108.png" alt="image-20220411151603108" style="zoom:67%;"><img src="/posts/27905/image-20220411151641326.png" alt="image-20220411151641326" style="zoom:67%;"><img src="/posts/27905/image-20220411151658536.png" alt="image-20220411151658536" style="zoom:67%;"></p>
<p><strong>Sales</strong></p>
<p>如下图所示，为Sales建立索引，每一行代表一条记录的Sales值，约定不可能超过16万，所以最大就是8bit，第一行就是$4×1+2×1=6$</p>
<p><strong>State</strong></p>
<p>每一列都是某一个州，如果属于该州，那么就标记为1，第一行属于NY州，那么在NY这里就是1，其余地方是0</p>
<p><strong>Class</strong></p>
<p>类别，类似于州，第一行属于A类，A就是1</p>
<p><strong>查询示例</strong></p>
<ol>
<li><p>销售总额是多少？</p>
<p>遍历Sales的每一列，将每一列的列属性和列值相乘再相加</p>
<p>8有4个，4有4个，…</p>
<p>$4×8+4×4+4×2+6×1=62$</p>
</li>
<li><p>有多少A类型的商店位于NY？</p>
<p>将State的NY列和Class的A列做<strong>按位与</strong>，结果是1的就是位于NY的A类型的商店</p>
<p>| <strong>NY</strong>     | <strong>1 0 1 0 1 0 0 1</strong> |<br>| ————— | —————————- |<br>| <strong>A</strong>      | <strong>1 1 0 1 1 0 0 1</strong> |<br>| <strong>NY &amp; A</strong> | <strong>1 0 0 0 1 0 0 1</strong> |</p>
</li>
<li><p>这些NY的A类型的商店的销售总额是多少？</p>
<p>将 NY&amp;A得到的结果与Sales的每一列做按位与，两个（8bit这位为例）都是1，说明是在NY、类型为A、商店销售额有8w的商店，比如1 0 0 0 1 0 0 1</p>
<p>| <strong>NY &amp; A</strong> | <strong>1 0 0 0 1 0 0 1</strong> |<br>| ————— | —————————- |<br>| <strong>8bit</strong>   | <strong>0 1 0 1 1 0 0 1</strong> |<br>| <strong>result</strong> | <strong>0 0 0 0 1 0 0 1</strong> |<br>| <strong>含义</strong>   | <strong>2个8w的店</strong>       |</p>
<p>$2×8+2×4+1×2+1×1=27$</p>
</li>
<li><p>有多少数量商店在CT？</p>
<p>CT这一列的1相加即可，2个商店</p>
</li>
<li><p>连接操作如何实现</p>
<p>基本原理也是基于按位与</p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-查询优化</title>
    <url>/posts/19931.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>本质</strong></p>
<ol>
<li>代数优化-把用户提交的查询语言进行重写（结果等价、效率更高的形式）</li>
<li>操作优化-根据查询涉及到的数据对象在磁盘上的具体物理存储、所能使用的访问路径决定最高效的操作策略来获取结果</li>
</ol>
<p><strong>目标</strong></p>
<p>以最小的代价在短时间内获取用户查询的结果</p>
<h3 id="分布式系统查询优化"><a href="#分布式系统查询优化" class="headerlink" title="分布式系统查询优化"></a>分布式系统查询优化</h3><p><strong>分类</strong></p>
<ol>
<li><p>Global Query</p>
<p>针对全局关系的查询</p>
</li>
<li><p>Fragment Query</p>
<p>针对裂片的查询</p>
</li>
</ol>
<p><strong>流程</strong></p>
<p><img src="/posts/19931/image-20220417130625432-1692774513967-50.png" alt="image-20220417130625432" style="zoom:67%;"></p>
<h4 id="示例-集中式"><a href="#示例-集中式" class="headerlink" title="示例-集中式"></a>示例-集中式</h4><p><img src="/posts/19931/image-20220328152757242-1692775610159-1.png" alt="image-20220328152757242" style="zoom: 33%;"></p>
<p>最初查询树(Query tree)</p>
<ol>
<li>按照where进行笛卡尔乘积</li>
<li>投影</li>
</ol>
<p>小优化后得到如下查询树</p>
<p><img src="/posts/19931/image-20220328153018869-1692774513967-51.png" alt="image-20220328153018869" style="zoom:33%;"></p>
<ol>
<li>对S进行查询，筛选出位于Nanjing的供应商$S_1$</li>
<li>对供应关系进行查询，筛选出供应量&gt;1000的供应关系$SP_1$</li>
<li>通过供应商编号SNUM将$S_1$和${SP}_1$进行连接，得到$S1-SP_1$</li>
<li>对零件进行查询，筛选出名称为‘Bolt’的零件$P_1$</li>
<li>通过零件编号PNUM将$S1-SP_1$与$P_1$连接</li>
<li>投影SNAME即可</li>
</ol>
<p>再次优化得到如下查询树</p>
<p><img src="/posts/19931/image-20220328154656381-1692774513967-52.png" alt="image-20220328154656381" style="zoom:33%;"></p>
<ol>
<li>对供应商进行筛选再投影，不需要城市这个属性了</li>
<li>对供应关系进行筛选再投影，不需要供应量这个属性了</li>
<li>对零件进行筛选再投影，不需要零件名称这个属性了</li>
<li>连接，再连接，投影</li>
</ol>
<p><strong>连接操作优化</strong></p>
<ol>
<li><p>两次连接的顺序</p>
<p>上面有S和SP的连接，接着有S-SP与P的连接</p>
</li>
<li><p>每个连接的实现方法R与S连接</p>
<ol>
<li>嵌套循环，R内循环，S外循环</li>
<li>嵌套循环，S内循环，R外循环</li>
<li>嵌套循环，利用某关系上的索引提高效率</li>
<li>归并扫描</li>
<li>哈希连接</li>
</ol>
</li>
</ol>
<h4 id="示例-分布式"><a href="#示例-分布式" class="headerlink" title="示例-分布式"></a>示例-分布式</h4><p><strong>关系背景</strong></p>
<p><img src="/posts/19931/image-20220417130700539-1692774513967-53.png" alt="image-20220417130700539" style="zoom:67%;"></p>
<p>SP1和SP2是导出分割的结果，分别表示南京和上海的供货情况</p>
<p><strong>查询</strong></p>
<p><img src="/posts/19931/image-20220417130829183-1692774513967-54.png" alt="image-20220417130829183" style="zoom:67%;"></p>
<p>查询某供应商的名字，该供应商需要位于南京，且供应零件Bolt的数量超过1000</p>
<p><strong>初始语法树</strong></p>
<p>叶子结点表示关系，中间结点表示一个操作，从叶结点到根的顺序就是一个执行顺序</p>
<p><img src="/posts/19931/image-20220417132246542-1692774513967-55.png" alt="image-20220417132246542" style="zoom:67%;"></p>
<h5 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h5><p>rewrite-把用户提交的初始查询改写成<strong>等价的</strong>效率更高的形式</p>
<p>DBMS内部会用关系代数表达查询，通过分析器生成查询树。</p>
<p>代数优化对原来生成的查询树进行变化，<strong>把一元操作尽量往叶端下压</strong>，从而减小二元操作（例如连接）的规模</p>
<p><img src="/posts/19931/image-20220417132524957-1692774513968-58.png" alt="image-20220417132524957" style="zoom:67%;"></p>
<p>最终得到可以在不同节点上局部运行的子查询</p>
<p><img src="/posts/19931/image-20220417132800705-1692774513968-57.png" alt="image-20220417132800705" style="zoom:67%;"></p>
<p>前面对语法树的优化都是<strong>代数优化</strong>，现在到了<strong>操作优化</strong>阶段，考虑如下问题</p>
<h5 id="操作优化"><a href="#操作优化" class="headerlink" title="操作优化"></a>操作优化</h5><ol>
<li><p>首先考虑分布式连接操作</p>
<ol>
<li><p>$(S1’⋃ S2’) ⋈  (SP1’ ⋃ SP2’)$</p>
<p>并集后左边50+50=100条记录</p>
<p>并集后右边50+50=100条记录</p>
<p>连接的检验次数=100*100</p>
</li>
<li><p>Distributed Join</p>
<p>(S1’⋈SP1’)U(S2’⋈SP2’)</p>
<p>裂片两两Join，中间结果Union</p>
<p>左边连接数量为50<em>50，右边也是50\</em>50，</p>
</li>
</ol>
</li>
<li><p>节点选择问题，数据可能存在副本，在哪个节点上运算</p>
</li>
<li><p>每次连接操作怎么实现</p>
<p><img src="/posts/19931/image-20220417133200970-1692774513968-59.png" alt="image-20220417133200970" style="zoom:67%;"></p>
<p>先把节点$j$上所有记录的连接条件的属性投影出来送给节点$i$，节点$i$根据这个对$R$做$semi-join$，得到满足连接条件的$R$的所有记录，再把这个东西传回去给$S$，再做一次连接，即可得到$R⋈S$</p>
</li>
</ol>
<h4 id="关系代数等价变换规则"><a href="#关系代数等价变换规则" class="headerlink" title="关系代数等价变换规则"></a>关系代数等价变换规则</h4><ol>
<li><p>连接和笛卡尔乘积的交换律</p>
<p>代数优化的时候连接或笛卡尔乘积操作的左右子树可以交换</p>
<p><img src="/posts/19931/image-20220328160944596-1692774513968-61.png" alt="image-20220328160944596" style="zoom:33%;"></p>
</li>
<li><p>连接和笛卡尔乘积的结合律</p>
<p>代数优化的时候连接或笛卡尔乘积操作时可以旋转，查询树可以旋转，连接顺序问题</p>
</li>
</ol>
<p><img src="/posts/19931/image-20220328161003008-1692774513968-60.png" alt="image-20220328161003008" style="zoom:33%;"></p>
<ol>
<li><p>投影操作的串接律</p>
<p>$A_1-A_n$是$B_1-B_m$的子集→先进行$B_1-B_m$的投影再进行$A_1-A_n$的投影等价于直接进行$A_1-A_n$的投影</p>
<p><img src="/posts/19931/image-20220328161045501-1692774513968-62.png" alt="image-20220328161045501" style="zoom:33%;">→<img src="/posts/19931/image-20220328161101907-1692775640310-1.png" alt="image-20220328161101907" style="zoom:33%;"></p>
</li>
<li><p>选择操作的串接律</p>
<p><img src="/posts/19931/image-20220328161247604-1692774513968-63.png" alt="image-20220328161247604" style="zoom:33%;"></p>
</li>
<li><p>选择与投影操作的交换律，右侧肯定能运行，左侧执行的条件是：F中的条件只能属于$A_1-A_n$，</p>
<p><img src="/posts/19931/image-20220328161301410-1692774513968-65.png" alt="image-20220328161301410" style="zoom: 33%;"></p>
<p>如果F中存在某些条件（属性）$B_1-B_m$不属于$A_1-A_n$，那么只能</p>
<p><img src="/posts/19931/image-20220328161653603-1692774513968-66.png" alt="image-20220328161653603" style="zoom:33%;"></p>
<p>也就是需要补全哪些缺失的属性，才能让后续的选择操作正常执行</p>
</li>
<li><p>选择的条件与表的关系</p>
<ul>
<li>选择的条件只与单个表(E1)有关，可以把选择的操作压到连接操作的下面，即先选择再连接，减少连接的记录数</li>
</ul>
<p><img src="/posts/19931/image-20220328162052117-1692774513968-67.png" alt="image-20220328162052117" style="zoom:33%;"></p>
<ul>
<li><p>如果选择的条件F是两个子条件F1、F2的交集，并且F1的属性只在E1中，F2的属性也只在E2中，那么</p>
<p><img src="/posts/19931/image-20220328162604410-1692774513968-68.png" alt="image-20220328162604410" style="zoom:33%;"></p>
</li>
</ul>
</li>
</ol>
<pre><code> &lt;img src=&quot;DBMS-查询优化/image-20220328163626557-1692774513968-70.png&quot; alt=&quot;image-20220328163626557&quot; style=&quot;zoom:50%;&quot; /&gt;
</code></pre><ul>
<li><p>如果选择的条件F是两个子条件F1、F2的交集，并且F1的属性只在E1中，F2的属性在E1和E2中都有，那么</p>
<p><img src="/posts/19931/image-20220328163705756-1692774513968-69.png" alt="image-20220328163705756" style="zoom:33%;"></p>
<p><img src="/posts/19931/image-20220328164100902-1692774513968-71.png" alt="image-20220328164100902" style="zoom:50%;"></p>
<p>F2条件有两个关系的，所以压不下来，但是依然可以先进行F1条件的选择</p>
</li>
</ul>
<ol>
<li><p>符合并兼容的可以压下去</p>
<p><img src="/posts/19931/image-20220328165721837-1692774513968-72.png" alt="image-20220328165721837"></p>
<p>属性集合完全一致，且属性的取值范围一致</p>
<p><img src="/posts/19931/image-20220328164318264-1692774513968-74.png" alt="image-20220328164318264" style="zoom:33%;"></p>
</li>
<li><p>集合差</p>
<p><img src="/posts/19931/image-20220328164545961-1692774513968-73.png" alt="image-20220328164545961" style="zoom:33%;"></p>
</li>
<li><p>投影操作的下压，假设$A_1-A_m$是一系列属性，在这其中$B_1-B_m= {E_1}.{attr}\and C_1-C_k= {E_2}.{attr}$，注意这里不是$\in$而是$=$，意味着$A_1-A_m\in B_1-B_m+C_1-C_k$那么</p>
<p><img src="/posts/19931/image-20220328164632140-1692774513968-75.png" alt="image-20220328164632140" style="zoom:33%;"></p>
<p>即先投影，再连接</p>
</li>
<li><p>先并再投影等价于先投影再并</p>
<p><img src="/posts/19931/image-20220328165256902-1692774513968-77.png" alt="image-20220328165256902" style="zoom:33%;"></p>
<p>满足并兼容</p>
</li>
</ol>
<p>示例1</p>
<p><img src="/posts/19931/image-20220329151359539-1692774513968-76.png" alt="image-20220329151359539" style="zoom:33%;"></p>
<p>查询预定了103号船的水手的姓名</p>
<ol>
<li>连接，再选择和投影 效率比较高</li>
<li>嵌套查询，先找到预订103号船水手的集合，然后看哪个水手的编号在里面</li>
<li>关联嵌套，按照该逻辑进行查询，效率不高。因为要把外层的水手表里面的每个水手的编号带入到嵌套查询，每次换S.sid就得执行一遍</li>
</ol>
<p>示例2</p>
<p>DEPT：部门，编号，名称，所在地区（北方）</p>
<p>SUPPLY：供应商，编号，名称，所属部门编号</p>
<p>查询属于<strong>位于北方地区部门管理</strong>的供应商的编号</p>
<p><img src="/posts/19931/image-20220328155629137-1692774513968-79.png" alt="image-20220328155629137" style="zoom:33%;"></p>
<p><img src="/posts/19931/image-20220328160650442-16484548113911-1692774513968-78.png" alt="image-20220328160650442" style="zoom:33%;"></p>
<p>连接→选择→投影，优化后</p>
<p><img src="/posts/19931/image-20220329152052113-1692774513968-80.png" alt="image-20220329152052113" style="zoom:33%;"></p>
<ol>
<li>投影，删掉Supply无用属性</li>
<li>选择+投影，删掉DEPT无用属性和不符合条件的记录</li>
<li>连接+投影，得到结果</li>
</ol>
<h4 id="全局查询→裂片查询"><a href="#全局查询→裂片查询" class="headerlink" title="全局查询→裂片查询"></a>全局查询→裂片查询</h4><p><strong>方法</strong></p>
<ol>
<li><p>水平分割</p>
<p>$R→R1 ⋃ R2 ⋃ … ⋃ Rn$</p>
</li>
<li><p>垂直分割</p>
<p>$S →S1 ⋈ S2 ⋈ … ⋈ Sn$</p>
</li>
</ol>
<p><strong>原则</strong></p>
<ul>
<li><p>运用等价变换规则把一元操作尽量往叶端下压</p>
</li>
<li><p>寻找并且合并公共子表达式 with子句</p>
<p><strong>公共子表达式</strong>：在同一查询表达式中出现多次的子表达式。找到这种子表达式并只计算一次，将提高查询效率</p>
<p><strong>识别方法</strong></p>
<ol>
<li><p>将查询树的相同叶子节点合并</p>
</li>
<li><p>将操作数和操作都相同的中间节点也合并起来</p>
<p><strong>示例</strong></p>
<p>两张表 emp雇员表和dept部门表，mgrnum是部门经理的编号，sal是薪资</p>
<p>$\Pi_{emp.name}(emp⋈(\sigma_{mgrnum=373} dept)–(\sigma_{sal&gt;35000}emp) ⋈ (sigma_{mgrnum=373} dept))$</p>
<p>筛选出在某部门工并且工资不高于35000的雇员，这个部门指的经理编号为373的部门</p>
</li>
</ol>
</li>
</ul>
<pre><code> **初始查询树**

 &lt;img src=&quot;DBMS-查询优化/image-20220418195151899-1692774513968-81.png&quot; alt=&quot;image-20220418195151899&quot; style=&quot;zoom:50%;&quot; /&gt;

 **优化过程**

 &lt;img src=&quot;DBMS-查询优化/image-20220418200109895-1692774513968-82.png&quot; alt=&quot;image-20220418200109895&quot; style=&quot;zoom:67%;&quot; /&gt;

 **结果**

 &lt;img src=&quot;DBMS-查询优化/image-20220418200440554-1692774513968-83.png&quot; alt=&quot;image-20220418200440554&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;img src=&quot;../../../cloud/OneDrive - 东南大学/同步盘/面试/数据库/笔记/DBMS.assets/image-20220418200600363.png&quot; alt=&quot;image-20220418200600363&quot; style=&quot;zoom:67%;&quot; /&gt;

 公共子表达式=$emp ⋈ (\sigma_&#123;mgrnum&#125;=373 dept)$

 按照绿色的公式，sal&gt;35000就转变为sal≤35000，得到如下左图，再将条件下沉得到右图

 &lt;img src=&quot;DBMS-查询优化/image-20220418200809696-1692774513968-85.png&quot; alt=&quot;image-20220418200809696&quot; style=&quot;zoom:67%;&quot; /&gt;

 其实就是$\Pi_&#123;emp.name&#125;((\sigma_&#123;sal≤35000&#125;emp) ⋈ (sigma_&#123;mgrnum=373&#125; dept))$

 在sql语言上体现如下

 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.name </span><br><span class="line"><span class="keyword">FROM</span> emp, dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptnum<span class="operator">=</span>dept.deptnum </span><br><span class="line">	<span class="keyword">AND</span> dept.mgrnum<span class="operator">=</span><span class="number">373</span></span><br><span class="line"><span class="keyword">EXCEPT</span>(<span class="keyword">or</span> MINUS) </span><br><span class="line">	<span class="keyword">SELECT</span> emp.name </span><br><span class="line">	<span class="keyword">FROM</span> emp, dept</span><br><span class="line">	<span class="keyword">WHERE</span> emp.deptnum<span class="operator">=</span>dept.deptnum</span><br><span class="line">		<span class="keyword">AND</span> dept.mgrnum<span class="operator">=</span><span class="number">373</span></span><br><span class="line">		<span class="keyword">AND</span> emp.sal<span class="operator">&gt;</span><span class="number">35000</span>;</span><br></pre></td></tr></table></figure>

 专家写的

 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.name </span><br><span class="line"><span class="keyword">FROM</span> emp, dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptnum<span class="operator">=</span>dept.deptnum </span><br><span class="line">    <span class="keyword">AND</span> dept.mgrnum<span class="operator">=</span><span class="number">373</span> </span><br><span class="line">    <span class="keyword">AND</span> emp.sal<span class="operator">&lt;=</span><span class="number">35000</span>;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>找到并消除空子表达式</p>
<p><img src="/posts/19931/image-20220418201450656-1692774513968-86.png" alt="image-20220418201450656" style="zoom:50%;"></p>
<p>找到部门编号为1的部门，直接针对裂片1进行选择即可，另外两个都是空的</p>
</li>
<li><p>消除无用的垂直裂片</p>
<p><img src="/posts/19931/image-20220418201534435-1692774513968-87.png" alt="image-20220418201534435" style="zoom:50%;"></p>
<p>F涉及到的属性和投影的属性都是在R1里面的，那么说明R2里面的属性就是没有用的，直接丢掉就好了</p>
</li>
</ol>
<h3 id="查询分解"><a href="#查询分解" class="headerlink" title="查询分解"></a>查询分解</h3><p><strong>代数优化→操作优化</strong></p>
<p>考虑到存储片段的站点，需要将查询分解成几个子查询，这些子查询可以在不同的站点上本地执行。</p>
<p><img src="/posts/19931/image-20220420191150345-1692774513968-88.png" alt="image-20220420191150345"></p>
<p>下标表示裂片，上标表示存放节点</p>
<p><strong>分解方法</strong></p>
<p>按后序（左→右→中）遍历查询树，直到存放的节点发生变化，即变成2，然后得到第一个子树，该子树就是可以在原节点上进行的子查询。其余的可以通过继续遍历来生成，所以我们可以得到所有的子树。</p>
<p><img src="/posts/19931/image-20220420191704877-1692774513968-89.png" alt="image-20220420191704877" style="zoom:50%;"></p>
<p>开始遍历，碰到右边$R_3^1$时停止，此时得到的就是如图的左子树，右边的U虽然进去了，但是实际上按照后序是没有访问的，所以不算。</p>
<p><img src="/posts/19931/image-20220420191948312-1692774513968-90.png" alt="image-20220420191948312" style="zoom:50%;"></p>
<p>继续遍历，碰到$R_6^3$停止，得到第二个子树</p>
<p><img src="/posts/19931/image-20220420192103841-1692774513968-91.png" alt="image-20220420192103841" style="zoom:50%;"></p>
<p>继续遍历，碰到根节点，结束，得到最后一个子树。</p>
<p>最终得到如图的<strong>总装树</strong></p>
<h4 id="总装树"><a href="#总装树" class="headerlink" title="总装树"></a>总装树</h4><p><img src="/posts/19931/image-20220420192304381-1692774513968-92.png" alt="image-20220420192304381" style="zoom:50%;"></p>
<h3 id="操作优化-1"><a href="#操作优化-1" class="headerlink" title="操作优化"></a>操作优化</h3><p>找到最有效的计算方法实现操作</p>
<p>单机环境下，一元操作的计算相对简单，根据数据的存储情况选择相应的搜索策略（哈希、顺序扫描、索引），分布式环境下，一元操作变成子查询，是由局部库实现，和单机没什么差别。二元操作是影响效率的瓶颈，其中，最重要的是连接操作（代价太大了 ×）</p>
<h4 id="集中式环境"><a href="#集中式环境" class="headerlink" title="集中式环境"></a>集中式环境</h4><h5 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h5><p><strong>背景：磁盘物理上不是连续存储的，那么1次I/O（寻道时间）只能拿1个物理块</strong></p>
<p><strong>前提：两个关系R(m)和S(n)连接，以堆文件的形式存储</strong></p>
<p>一次I/O取一条记录需要n*m次I/O，内外循环，效率非常低，需要以物理块为单位进行优化</p>
<p><strong>优化策略</strong></p>
<ul>
<li>基于磁盘是块访问，由于CPU运算速度比I/O存取速度块的多。【减少读盘次数，空间换时间】</li>
<li>每次I/O取一个物理块，用块的内容和块的内容在内存中进行逐条对比</li>
<li>申请两个缓冲区分别给内外循环，每次I/O取外循环的一个物理块到缓冲区，由这个物理块去扫描内循环，每次I/O也取内循环的一个物理块到缓冲区，但是最后在内存还是一个一个比较</li>
</ul>
<p>减少了I/O开销，其实减少的是内循环的I/O次数</p>
<p><strong>示例</strong></p>
<p>假设记录数都是12</p>
<p>完全没有缓冲区，一条记录一条记录对照，那么12+12*12=13*12=156次I/O</p>
<p>如果2个缓冲区，物理块能够存2条记录，那么内外循环的物理块的数量都为12/2=6，6+6*6=7*6=42</p>
<p>如果外循环给2个缓冲区，内循环1个缓冲区，物理块能够存2条记录，那么外循环的物理块的数量为12/4=3，内循环为12/2=6，3+6*3=21</p>
<p>极端情况，外循环给了6个缓冲区，物理块只需要1块，那么</p>
<p>1+1*6=7</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>无缓冲区</strong></th>
<th><strong>144</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1个缓冲区</strong></td>
<td><strong>36</strong></td>
</tr>
<tr>
<td><strong>2个缓冲区</strong></td>
<td><strong>18</strong></td>
</tr>
<tr>
<td><strong>6个缓冲区</strong></td>
<td><strong>6</strong></td>
</tr>
</tbody>
</table>
</div>
<p><strong>公式</strong></p>
<p>假设$b_R$是外循环的物理块数量，$b_S$是内循环的物理块数量，$n_B&gt;=2$是缓冲区的总数量，其中$n_B-1$给外循环，剩下那个给内循环。<strong>为什么只给内循环1个物理块，给1个物理块：1次I/O拿出1个物理块的内容，给2个物理块也是需要两次I/O才能拿出两个物理块的内容，而在内存里面有两个内循环的物理块2次I/O完成的任务和之前一样</strong></p>
<script type="math/tex; mode=display">b_R+\lceil b_R/(n_B-1)\rceil\times b_S</script><p>第一个$b_R$无法避免，肯定要扫描完外循环的所有物理块的，有几个物理块就肯定要这么多次I/O的</p>
<p>外循环每次换，内循环都得遍历一遍整个内循环的所有物理块，每次需要$b_S$次I/O</p>
<p>内循环到底需要多少次全盘扫描呢，也就是$b_S$次I/O，那要看外循环借助缓冲区能够几次搞完，$\lceil b_R/(n_B-1)\rceil$就是次数，也就是说<strong>外循环增加缓冲区其实是降低了这个次数，内外循环到底有多少个物理块是固定的，对应的I/O次数也是固定的</strong>。</p>
<h5 id="归并扫描"><a href="#归并扫描" class="headerlink" title="归并扫描"></a>归并扫描</h5><p>两个关系事先做好外排序后挨个比较</p>
<ul>
<li>比较次数为m+n</li>
<li>I/O次数为$b_R+b_S$</li>
</ul>
<h5 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h5><p><strong>使用最多</strong></p>
<ul>
<li>在某个属性上建立了B+树所索引，让有索引的作为内关系，没有索引的作为外关系</li>
<li>再用嵌套循环的思想，外循环取一个物理块，投影出索引属性，通过属性值去内循环进行查找，得到磁盘地址，取到记录进行连接</li>
<li>属性的重复数量&gt;20%，那么不如顺序扫描，因为一查，每次都得拿20%，过于分散，好多物理块都得访问，I/O次数得不到减少</li>
</ul>
<h5 id="Hash-连接"><a href="#Hash-连接" class="headerlink" title="Hash 连接"></a>Hash 连接</h5><p>在两个经常连接的公共属性上定义一个相同的hash函数，把两个表一起散列到一个hash文件中，按照hash值将记录分到不同桶里面，能连接的肯定都在一个桶里面</p>
<h4 id="分布式环境"><a href="#分布式环境" class="headerlink" title="分布式环境"></a>分布式环境</h4><p><strong>主要问题</strong></p>
<ol>
<li><p>物化问题-选择参与查询的片段的合适副本</p>
<p>影响效率、负载不均衡</p>
<ol>
<li><p>局部最大化</p>
<p>贪心的策略</p>
<p><img src="/posts/19931/image-20220420191150345-1692774513968-88.png" alt="image-20220420191150345"></p>
<p>假设$R_3$在1、3上有备份，$R_4$在1、2、4上有备份</p>
<p>在查询分解时同时解决副本选择问题，遍历到$R_3$时发现其在1、3上都有副本，而当前的子查询节点(j)是1，那么就优先选择$R_3$在节点1上的副本，同理在$R_4$也这样贪心处理，直到某时候再也没办法选择相同的节点</p>
</li>
</ol>
</li>
<li><p>连接实现策略</p>
<p><img src="/posts/19931/image-20220420195055941-1692774513968-93.png" alt="image-20220420195055941" style="zoom:67%;"></p>
<p>| 连接策略     | 连接操作 |<br>| —————— | ———— |<br>| 先并再连接   | 直接连接 |<br>| 两两连接再并 | 半连接   |</p>
</li>
<li><p>实现join（主要是直接连接）的具体算法</p>
<p>传统集中式数据库的算法</p>
</li>
</ol>
<p>上述三种优化组合的策略非常多，操作优化就是估算这几种组合的代价以选择最好的组合策略</p>
<p><strong>基本优化方法</strong></p>
<ol>
<li><p>穷举各种连接组合的开销</p>
</li>
<li><p>启发式方法，基于一些启发式规则</p>
<p>有索引的关系作为内关系，嵌套循环实现连接</p>
<p>物理块少的作为外关系，尽可能减少内关系的遍历次数</p>
</li>
<li><p>1和2结合</p>
<p>先用启发式规则排除一些明显不好的策略，然后对剩下的策略进行代价的估算，选择出好的</p>
</li>
</ol>
<h5 id="代价估算"><a href="#代价估算" class="headerlink" title="代价估算"></a>代价估算</h5><ol>
<li><p>广域网环境</p>
<p>传输速率约为100bps~50Kbps，远远慢于计算机的处理速度，因此本地处理的成本可以省略，只考虑网络传输代价</p>
</li>
<li><p>局域网环境</p>
<p>传输速率将达到1000Mbps，上述两项都要考虑。</p>
</li>
</ol>
<p>总查询代价=本地处理代价+网络传输代价</p>
<ul>
<li><p>网络传输代价</p>
<p>$TC(x)=C_0+C_1x$</p>
<p>传送x个字节的代价</p>
<p>$C_0$就是传输的初始化代价（建立连接、握手），不管传输多少数据都要有这个代价</p>
<p>$C_1$是连接建立之后每传输一个字节需要的开销，受制于使用的网络特点</p>
</li>
<li><p>本地查询处理代价</p>
<p>$PC=cost_{cpu}+cost_{I/O}$</p>
<p>cpu比I/O快很多，一般忽略</p>
<p>一次I/O的代价=$D_0+D_1$</p>
<p>$D_0$:平均寻道时间(ms)，和机械硬盘的性能有关系</p>
<p>$D_1$:I/O一个物理块需要的时间(us)，忽略不计</p>
<p>$PC=cost_{I/O}=Number(I/O)×D_0$</p>
<p>其实最后比较的就是I/O次数</p>
</li>
</ul>
<h5 id="Semi-join"><a href="#Semi-join" class="headerlink" title="Semi join"></a>Semi join</h5><p>semi join用于减少<strong>网络传输开销</strong>，适用于广域网(WAN)</p>
<p><a href="#Semi join">Semi join</a></p>
<p>$R ⋉  S =\Pi _R(R ⋈ S)$</p>
<p>R和S分别在节点1和2上，先决定将R传输到S上进行连接，但是R关系太大了，怎么压缩（不用的记录不要传过去），按照如下步骤实现连接</p>
<ol>
<li>将$\Pi_A(S)$→site1，A是连接的属性</li>
<li>在节点1上执行$R⋈\Pi_A(S))$得到$R⋉S$，这里得到的就是满足连接条件的关系R里面的记录</li>
<li>将$R⋉S$→ site2</li>
<li>执行$(R⋉S)⋈S$得到$R⋈S$的最终结果，用刚刚得到的关系R的记录再去和S做连接，得到的就是R和S的连接</li>
</ol>
<p>假设R有1024记录，S有1024记录，每条记录10属性，等长为1</p>
<p>那么原本网络传输数据：10*1024</p>
<p>但是现在假设只有一半的R符合条件，A只有原属性的1/10长度</p>
<p>$10<em>1/10</em>1024+1/2<em>1024</em>10=6*1024$</p>
<p><strong>开销对比</strong></p>
<ul>
<li><p>直接连接开销：$C_0+C_1*min(r,s)——————①$</p>
<p>$C_0$建立连接的固定开销，$C_1$传输单位字节的开销，$r$,$s$是关系R和S的元组数</p>
</li>
<li><p>semi join开销：$min(2C_0+C_1<em>s’+C_1</em>r’’,2C_0+C_1r’+C_1<em>s’’)=\\2C_0+C_1</em>min(s’+r’’,r’+s’’)——②$</p>
<p>固定有两次连接开销$C_0$，$s’,r’=|\Pi_A(S)|, |\Pi_A(R)|$，$s’’,r’’=|S⋉R|,|R⋉S|$</p>
<p>$s’$表示投影得到的关系S剩余的数据量($r’$同理)，所以与$r’’$对应</p>
<p>$r’’$表示R满足连接条件的剩余数据量($s’’$同理)</p>
</li>
</ul>
<p>只有当$②&lt;①$时，semi join才有意义</p>
<p>当$C_0$相对于$C_1$很小时，可以忽略，那么只需要$min(s’+r’’,r’+s’’)&lt;min(r,s)$</p>
<ol>
<li><p>$C_0$需要很小，否则2次连接的开销影响较大</p>
</li>
<li><p>不适合采用多元semi join，多个关系做join</p>
<p><strong>R⋉(S⋉T)得到的是满足三者连接条件的R</strong></p>
<p>直接连接是两个小的关系的传输成本，比如就是s+r</p>
<p>semi join如下</p>
<ol>
<li>$T$的投影$t’$传输到$S$上，做semi-join得到满足连接条件的$S’$，经过了压缩</li>
<li>把$S’$的投影$s_1’$弄到$R$上，做semi-join得到满足条件的$R’$</li>
<li>再把$R’$和$S_1$传输到$T$上，$r’’$和$s’’$</li>
</ol>
<p>$t’+s_1’+r’’+s’’$</p>
<p><strong>?</strong></p>
</li>
<li><p>通过semi join对R和S操作时，需要能够剔除足够数量的元组数</p>
</li>
</ol>
<p><strong>评价</strong></p>
<ol>
<li><p>牺牲处理代价（投影、semi join）优化传输代价</p>
<p>局域网情况下不适合</p>
</li>
<li><p>semi join存在太多候选方案</p>
<p>$R_1⋈R_2⋈R_3…⋈R_n$，考虑对$R_1$的semi join</p>
<p>$R_1 ⋉ R_2, R_1 ⋉ (R_2 ⋉ R_1), R_1 ⋉ (R_2 ⋉ R_3), …$</p>
<p>无法穷举已进行代价估计</p>
</li>
<li><p>⋉ 可以视为数据压缩器(Bernstein’s remark)</p>
<ul>
<li><p>关系R的reducer program:对关系R的semi join操作链</p>
</li>
<li><p>RED(Q,R):查询Q中所有的对关系R的reducer program的集合</p>
</li>
<li><p>Full reducer:满足以下条件的reducer</p>
<ol>
<li>$\in RED(Q,R)$</li>
<li>能够最大化压缩R</li>
</ol>
</li>
<li><p>但是找到Full reducer不是追求的目标</p>
</li>
</ul>
</li>
</ol>
<h6 id="tree-query-amp-cyclic-query"><a href="#tree-query-amp-cyclic-query" class="headerlink" title="tree query &amp; cyclic query"></a>tree query &amp; cyclic query</h6><ul>
<li><p>TQ</p>
<p>$q = (R_1.A=R_2.B)∧(R_1.C=R_3.D)∧(R_2.E=R_4.F)∧\(R_3.G=R_5.H)∧(R_3.J=R_6.K)$</p>
<p>只要两个关系需要直接连接，就连一条边，得到如下tree query（无环）</p>
<p><img src="/posts/19931/image-20220422110848121-1692774513968-95.png" alt="image-20220422110848121" style="zoom:50%;"></p>
</li>
<li><p>CQ</p>
<p>$q = (R_1.A=R_2.B)∧(R_2.C=R_3.D)∧(R_3.E=R_1.F)$</p>
<p>如下cyclic query（有环）</p>
<p><img src="/posts/19931/image-20220422111108963-1692774513968-94.png" alt="image-20220422111108963" style="zoom:50%;"></p>
</li>
<li><p>Special</p>
<p>$q=(R_1.A=R_2.B)∧(R_2.B=R_3.C)∧(R_3.C=R_1.A)$</p>
<p>这不是CQ，而是TQ，因为$R_3.C=R_1.A$可以由前面的条件传递过来，并不是一个独立的条件，可以省略？</p>
<p>学生表学号=选课表学号，选课表学号=基本信息表学号，都是一个学号</p>
</li>
<li><p>发现</p>
<ul>
<li><p>TQ是有Full reducer</p>
</li>
<li><p>CQ的大部分情况下都不存在Full reducer</p>
<p><img src="/posts/19931/image-20220422111720799-1692774513968-97.png" alt="image-20220422111720799" style="zoom:50%;"></p>
<p>$q = (R_1.B=R_2.C)∧(R_2.D=R_3.E)∧(R_3.F=R_1.A)$</p>
<p>查询结果为空，但是无法通过任何的semi join操作减少某关系的元组数量</p>
<p>比如$R_1⋉R_3$得到的是$R_1$的所有元祖，同理任意两个关系也是一样</p>
<p>比如$R_1⋉(R_2⋉R_3)$也消除不掉任意元组</p>
<p>如下例子虽然结果也为空，但是存在Full reducer</p>
<p><img src="/posts/19931/image-20220422183319245-1692774513968-96.png" alt="image-20220422183319245" style="zoom:50%;"></p>
<p>最后用T’’对R’’做semi join得到∅，即Full reducer如下</p>
<p>$①R’=R⋉T②S’=S⋉R’③T’=T⋉S’④R’’=R’⋉T’\\⑤S’’=S’⋉’’⑥T’’=T’⋉S’’⑦R’’’=R’’⋉T’’=∅$</p>
<ul>
<li><p>推论</p>
<ol>
<li>对于CQ：一般来说，没有Full reducer。即使有，其长度也会随着查询中某些关系的图元的数量而线性增加(大约3(m-1))</li>
<li>对于TQ：Full reducer的长度&lt; n-1（n是查询图中的节点数，关系的个数）</li>
</ol>
</li>
</ul>
<p>所以找到Full reducer不应该成为优化目标，SDD-1 算法是一种启发式规则，不需要找Full reducer，也不考虑多元semi join，即便是多元连接，也只考虑两两semi join，看是不是能减少开销（<strong>开销对比</strong>），有用的保留（动态的，会随着查询进程，其他semi join的进行可能会变成benifit的），没用的直接全关系传输</p>
</li>
</ul>
</li>
</ul>
<h5 id="Direct-Join"><a href="#Direct-Join" class="headerlink" title="Direct Join"></a>Direct Join</h5><p>分布式环境下也按照集中式环境下的经典算法进行连接，但是需要把算法逻辑和数据传输结合起来</p>
<p><strong>原始开销</strong></p>
<p>嵌套循环cost：$[b_R+\lceil b_R/(n_B-1)\rceil\times b_S]*D_0$</p>
<p>归并扫描cost：$(b_R+b_S)*D_0+Cost_{sort}(R)+Cost_{sort}(S)$</p>
<p><strong>传输方式</strong></p>
<h6 id="shipped-whole"><a href="#shipped-whole" class="headerlink" title="shipped whole"></a>shipped whole</h6><p>参与运算的关系不加选择直接传输</p>
<p>以嵌套循环作为连接算法</p>
<ol>
<li><p>传输内循环的关系，需要传输到节点的磁盘上作为临时关系，因为需要多次扫描</p>
<p>内循环传输，传输1个物理块放入缓冲区，对比本地外关系的一个物理块后，不能丢弃，后面还要对比，所以需要存到磁盘上</p>
</li>
<li><p>传输外关系，不需要存储为临时关系</p>
<p>节点1上的关系R取一个物理块放入内存传输到节点2的缓冲区内，节点2取关系S的一个物理块放入另一个缓冲区，一一对比。对比完，节点1再取、发送过来，之前的就扔掉了</p>
</li>
</ol>
<h6 id="fetch-as-need"><a href="#fetch-as-need" class="headerlink" title="fetch as need"></a>fetch as need</h6><p>需要什么元组，传什么元组</p>
<p>被传输的关系（作为内循环关系）一般需要在连接属性上建立索引</p>
<p>外关系在本地开辟两个缓冲区，取外关系的1个物理块放到缓冲区，然后投影出连接属性的不同值发送给内关系的节点，内关系根据这个值借助索引去取内关系的元组传回外关系的节点，外关系这边做完连接后，再取下一个物理块。其实有点像按照物理块为单位让外关系对内关系做一次semi join</p>
<h6 id="R-系统"><a href="#R-系统" class="headerlink" title="R*系统"></a>R*系统</h6><p><img src="/posts/19931/image-20220422193709229-1692774513968-98.png" alt="image-20220422193709229" style="zoom:67%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>连接算法</th>
<th>传输方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>嵌套循环</td>
<td>外关系做shipped whole</td>
</tr>
<tr>
<td>嵌套循环</td>
<td>内关系做fetch as need</td>
</tr>
<tr>
<td>归并扫描</td>
<td>外关系做shipped whole</td>
</tr>
<tr>
<td>归并扫描</td>
<td>内关系可以fetch 也可以shipped</td>
</tr>
<tr>
<td>嵌套或归并</td>
<td>借助第三个节点，将内外关系做shipped whole</td>
</tr>
</tbody>
</table>
</div>
<p>归并扫描其实已经没有内外关系的区分了，但是实现上总是有一个指针先动，后一个指针后动，先动的就是外关系，后动的就是内关系</p>
<ol>
<li>显然，外关系都是shipped whole的，外关系是肯定扫描一遍的，所以肯定需要传输完整的过去</li>
<li>在嵌套循环中，如果内循环是做shipped whole，索引过不去，并且还得存成临时关系，传输代价和存储代价都比较大</li>
</ol>
<p><strong>未考虑的情形</strong></p>
<ol>
<li><p>Multiple join</p>
<p>转换成多个二元关系，两两连接</p>
</li>
<li><p>Copy selection</p>
<p>R*系统不支持副本</p>
</li>
</ol>
<h5 id="分布式分组与聚合函数评估"><a href="#分布式分组与聚合函数评估" class="headerlink" title="分布式分组与聚合函数评估"></a>分布式分组与聚合函数评估</h5><p>Evaluation 128)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PNUM, <span class="built_in">SUM</span>(QUAN) <span class="keyword">FROM</span> SP <span class="keyword">GROUP</span> <span class="keyword">BY</span> PNUM;</span><br></pre></td></tr></table></figure>
<p>$GB_{PNUM, SUM(QUAN)}SP$:按照零件编号做分组，看每种零件的总供货量</p>
<p>$GB$就是$group~by$操作，第一个就是分组属性，第二个是要做的聚集函数，最后那个是表</p>
<p><strong>优化思想</strong></p>
<p>如果SP水平分布在不同裂片上，那么原本是需要对SP做重构的，但是其实是不是可以在不同裂片上直接做分组聚集，最终结果做并集</p>
<h6 id="SNC准则"><a href="#SNC准则" class="headerlink" title="SNC准则"></a>SNC准则</h6><ol>
<li><p>非全表范围的聚集函数</p>
<p>比如求按照某属性分组之后组的平均值</p>
<p>关系$R$水平分割成$R_1∪R_2$，假设$G_i$是对关系R按照分组条件分组得到的其中一个组，当且仅当</p>
<p>$G_i\in R_j~or~ Gi∩Rj=Φ~for~all~i,j————SNC准则$</p>
<p>就是这个组要么完全属于其中一个裂片，要么和这个裂片一点关系都没有，即任意组不会跨裂片，那么</p>
<p>$GB_{G, AF}(R1 ⋃ R2) = (GB_{G, AF}R1) ⋃ (GB_{G, AF}R2)$</p>
<p>现在就是可以在裂片内直接做分组了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SNUM, <span class="built_in">AVG</span>(QUAN) <span class="keyword">FROM</span> SP <span class="keyword">GROUP</span> <span class="keyword">BY</span> SNUM;</span><br></pre></td></tr></table></figure>
<p>按照供应商编号求每个供应商的供应量的平均值</p>
<ol>
<li>如果SP是按照供应商所在城市做的导出分割（S那张表水平分割），同一个城市的供应商都在一个裂片，同一个供应商的供应关系肯定也只能在一个裂片，此时按照供应商编号分组，那么每个供应商的供应关系只能出现在一个裂片里面。</li>
<li>如果SP是按照零件类型做的导出分割，那就不满足上述条件了，因为这样一个供应商供应不同零件，那这些供应关系就会跨裂片，无法在裂片内直接做分组</li>
</ol>
</li>
<li><p>全表范围的聚集函数的运算</p>
<p>比如求总和、最大值、最小值、平均值、计数等</p>
<p>$S→S_1,S_2,…,S_n$</p>
<p>例如</p>
<script type="math/tex; mode=display">
SUM(S) = SUM(SUM(S_1), SUM(S_2), …, SUM(S_n)) \\
COUNT(S) = SUM(COUNT(S_1), … COUNT(S_n)) \\
AVG(S) = SUM(S)/COUNT(S)\\
MIN(S) = MIN(MIN(S_1), MIN(S_2), …, MIN(S_n)) \\
MAX(S) = MAX(MAX(S_1), MAX(S_2), …, MAX(S_n))</script></li>
</ol>
<h5 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h5><p>更新操作是在查询的基础上实现的，where条件用来搜索需要更新的数据</p>
<p>需要保证更新时，多副本的一致性</p>
<p><strong>策略</strong></p>
<h6 id="同时更新所有副本"><a href="#同时更新所有副本" class="headerlink" title="同时更新所有副本"></a>同时更新所有副本</h6><p>只要有一个副本不能更新，更新就失败了</p>
<p>这样就会导致只要副本数量够多，那么更新成功的概率就会无限趋向于0</p>
<p>p是更新成功的概率，n是副本数量</p>
<p>$lim_{n→∞}p^n=0$</p>
<h6 id="尽可能更新"><a href="#尽可能更新" class="headerlink" title="尽可能更新"></a>尽可能更新</h6><p>能更新的都更新，如果有不能更新的节点，那么需要维持更新信息到一个临时节点，等到故障节点正常，就去这个临时节点取数据再做更新</p>
<p>实现很困难，还有好多突发情况，比如临时节点也坏了咋办</p>
<h6 id="主副本更新策略"><a href="#主副本更新策略" class="headerlink" title="主副本更新策略"></a>主副本更新策略</h6><p>指定一个副本为主要副本，其他的是从副本，只对主副本更新，主副本某时会进行广播来更新从副本</p>
<p>存在主从副本的不一致，如果下一个操作还是更新，那没事了，但是如果下一个操作是对从副本的读取，那就得比较版本号，如果不一致就</p>
<ol>
<li>将查询操作重定向到主副本节点</li>
<li>等待从副本的更新</li>
</ol>
<h6 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h6><p>只在一个节点存储主副本，其他节点存储快照，快照是主题在某一个时刻的印象</p>
<p>用户可以自主选择查master copy还是snapshots</p>
<p>一致性要求高，那就差master copy</p>
<ul>
<li>主体更新，快照不变</li>
<li>快照要么命令（REFRESH ）强制更新，要么周期更新</li>
</ul>
<p>比较适用于更新少的数据库，比如人口统计数据</p>
<ol>
<li>代数优化-把用户提交的查询语言进行重写（结果等价、效率更高的形式）</li>
<li>操作优化-根据查询涉及到的数据对象在磁盘上的具体物理存储、所能使用的访问路径决定最高效的操作策略来获取结果</li>
</ol>
<p><strong>目标</strong></p>
<p>以最小的代价在短时间内获取用户查询的结果</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-目录分布</title>
    <url>/posts/61373.html</url>
    <content><![CDATA[<h3 id="目录分布策略"><a href="#目录分布策略" class="headerlink" title="目录分布策略"></a>目录分布策略</h3><h4 id="集中式分布"><a href="#集中式分布" class="headerlink" title="集中式分布"></a>集中式分布</h4><p>目录信息集中存放在一个节点</p>
<ol>
<li>实现非常简单</li>
<li>效率较低</li>
<li>系统可靠性很差</li>
</ol>
<p><strong>扩展的集中式分布：初始化时集中存储于某节点，系统运行过程中其他节点用到了某个数据对象就从网络上取过来保留到本地</strong></p>
<p>这样会带来目录的更新问题，目录信息的一致性，维持一个映射表，每个目录信息在网络上的哪个节点上有缓存，一旦更新就查表，全部更新</p>
<h4 id="全复制式分布"><a href="#全复制式分布" class="headerlink" title="全复制式分布"></a>全复制式分布</h4><p>每个节点都存储一份完整的目录信息、</p>
<ol>
<li><p>效率较高</p>
</li>
<li><p>实现也简单</p>
</li>
<li><p>更新时维护一致性代价比较大</p>
</li>
<li><p>影响节点的自治性</p>
<p>比如某节点更新自己的目录信息，一旦存在一个节点无法更新，那么这次更新就会失败，该节点的目录更新受制于其他节点，自治性较差</p>
</li>
</ol>
<h4 id="局部目录式分布"><a href="#局部目录式分布" class="headerlink" title="局部目录式分布"></a>局部目录式分布</h4><p>目录随数据存放，数据存放在哪，关于该数据的目录信息也就存放在那个节点</p>
<ol>
<li><p>效率较高</p>
</li>
<li><p>实现较为难</p>
</li>
<li><p>更新时维护也方便</p>
</li>
<li><p>缺少全局目录信息</p>
<p>某节点想要访问不在这个节点上的数据，不知道从哪里可以找到这个数据，解决方法</p>
</li>
</ol>
<h5 id="Master-catalog"><a href="#Master-catalog" class="headerlink" title="Master catalog"></a>Master catalog</h5><p>存储一些完整的目录信息到分布式系统的某些节点上，本地没有就到Master上找</p>
<p>Master会成为整个系统的效率瓶颈</p>
<h5 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h5><p>在通过广播获得并使用其他节点的数据目录信息后，将其保存起来供将来使用（缓存）。通过版本号的比较来更新缓存的目录。</p>
<p>当再次访问节点2进行查询时，根据本地的缓存构建一个查询计划（带上版本号），发送到节点1进行执行，节点1比较这个版本号，一致可以执行；否则，该执行计划可能有问题，节点1返回给节点2出错信息，并将新的目录信息附带上，节点2按照新的目录信息重新搞一遍</p>
<p>  <img src="/posts/61373/image-20220415161551871.png" alt="image-20220415161551871"></p>
<h4 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h4><p>对不同的目录内容使用不同的策略，然后得到不同的组合策略。</p>
<ol>
<li><p>使用<strong>全复制分布策略</strong>来处理分布信息，其他目录信息随数据存放（<strong>局部目录式分布策略</strong>）</p>
<p>因为分布信息是分布式环境下用来定位数据的，这样能够很快知道用户需要信息存放在哪里。</p>
</li>
<li><p>对统计信息使用<strong>局部目录策略</strong>，其他目录信息<strong>全复制</strong></p>
<p>统计信息经常会变（维护的一致性问题），其他目录信息基本不变（一致性问题可以忽略）</p>
</li>
</ol>
<h3 id="R-系统"><a href="#R-系统" class="headerlink" title="R*系统"></a>R*系统</h3><p>R*就是SystemR的分布式版本，每个局部数据库都是SystemR（0-多个）</p>
<p><strong>特点</strong></p>
<ol>
<li><p>不存在全局目录，区别于全局模式</p>
</li>
<li><p>支持用户独立命名和数据定义</p>
<p>不同节点之间的表一般不能重名</p>
</li>
<li><p>目录增长比较稳定</p>
</li>
</ol>
<h4 id="系统范围名"><a href="#系统范围名" class="headerlink" title="系统范围名"></a>系统范围名</h4><p>\<SWN\>::=User@UserSite.ObjectName@BirthSite</SWN\></p>
<ul>
<li><p>User: 创建者名称用户名，可以允许不同创建者创建相同名字的数据对象</p>
</li>
<li><p>UserSite: 创建者所在节点的ID，允许不同节点的用户有相同的用户名</p>
</li>
<li><p>ObjectName: 该创建者创建的名字</p>
</li>
<li><p>BirthSite: 最初被创建的节点，可以做数据迁移，但是该数据不会变</p>
<p>虽然没有全局完整目录，但是通过BirthSite可以找到每个数据对象的目录信息所在的位置</p>
</li>
</ul>
<h4 id="打印名"><a href="#打印名" class="headerlink" title="打印名"></a>打印名</h4><p>在特定环境下，写Sql语句时使用的名称</p>
<p>\<PN>::=[User[@UserSite].]ObjectName[@BirthSite]</PN></p>
<p>至少包括ObjectName，其余可以缺省</p>
<h4 id="Mapping-PN-to-SWN"><a href="#Mapping-PN-to-SWN" class="headerlink" title="Mapping PN to SWN"></a>Mapping PN to SWN</h4><p>同义词定义同义词语句，为每个用户维护一张同义词表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ObjectName</th>
<th>SWN</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxx</td>
<td>xxxxxx</td>
</tr>
</tbody>
</table>
</div>
<p>例如，节点$2$上有一个用户$u1$，创建了一张表叫student</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Define</span> Synonym S <span class="keyword">AS</span> u1<span class="variable">@02</span>.student<span class="variable">@02</span>;</span><br></pre></td></tr></table></figure>
<p>S就表示u1@02.student@02，后面直接用S就行了</p>
<p><strong>映射规则</strong></p>
<ol>
<li>直接就是SWN，不需要映射</li>
<li>只有ObjectName，查<strong>当前节点</strong>上<strong>当前用户</strong>的同义词表，找到SWN就替换，否则<strong>补缺</strong></li>
<li>User.ObjectName，查<strong>当前节点</strong>上<strong>User这个用户</strong>的同义词表，找到SWN就替换，否则<strong>补缺</strong></li>
<li>User@UserSite.ObjectName，强调节点的自治县，系统会认为需要跨节点，需要<strong>补缺</strong></li>
<li>ObjectName@BirthSite，需要补缺</li>
</ol>
<p><strong>补缺规则</strong></p>
<p>2,3没有找到或者4,5两种形式</p>
<ol>
<li>用当前用户的ID补上缺少的User</li>
<li>用当前节点的ID补上缺少的UserSite或者BirthSite</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库管理系统及其实现</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA-引言</title>
    <url>/posts/55942.html</url>
    <content><![CDATA[<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>一个大规模集成的数据集合。</li>
<li>数据库作用：<ul>
<li>一个数据库是对现实生活中一个企业或一个单位在计算机中的建模结果<ul>
<li>实体</li>
<li>联系（实体间的关系）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><ul>
<li>用来管理数据库的一种系统软件。</li>
</ul>
<h3 id="文件与数据库之间的关系"><a href="#文件与数据库之间的关系" class="headerlink" title="文件与数据库之间的关系"></a>文件与数据库之间的关系</h3><ul>
<li>数据库可以通过DBMS直接进行很多操作，而文件的话只提供了简单的操作。</li>
<li>用文件的话，要针对不同的文件结构编写不同的代码。</li>
<li>由于实际应用中并发同时访问导致数据访问不一致。【文件没有解决办法，需要在应用软件层解决，而DBMS中有】</li>
<li>故障处理【文件系统不具备这个能力，但DBMS会自动恢复】</li>
<li>安全和访问控制</li>
</ul>
<p>数据库系统建立在文件系统之上。</p>
<h3 id="使用数据库的好处"><a href="#使用数据库的好处" class="headerlink" title="使用数据库的好处"></a>使用数据库的好处</h3><ul>
<li>支持数据的独立性和有效访问</li>
<li>减少了应用开发时间</li>
<li>支持对数据完整性和安全性的控制</li>
<li>支持并发访问</li>
<li>支持对故障的恢复</li>
</ul>
<h3 id="学习数据库的必要"><a href="#学习数据库的必要" class="headerlink" title="学习数据库的必要"></a>学习数据库的必要</h3><ul>
<li>将计算转换为信息<ul>
<li>低端应用：web内存在的所有的数据【十分混乱而多】</li>
<li>高端应用：核能等高新端科技</li>
</ul>
</li>
<li>随着当前科技发展，数据的种类不断膨胀</li>
<li>DBMS是对计算机科学的大部分技术的成果<ul>
<li>可以当作对学过的很多知识的一个实例</li>
</ul>
</li>
</ul>
<h3 id="一些基本概念和术语"><a href="#一些基本概念和术语" class="headerlink" title="一些基本概念和术语"></a>一些基本概念和术语</h3><h4 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据 Data"></a>数据 Data</h4><ul>
<li>用来描述现实世界的一种符号</li>
<li>是信息存在的形式</li>
</ul>
<h4 id="数据模型-Data-model"><a href="#数据模型-Data-model" class="headerlink" title="数据模型 Data model"></a>数据模型 Data model</h4><ul>
<li>用来描述数据的一组概念</li>
<li>用来描述现实世界的一种建模方法</li>
<li>包括数据结构、数据操作和数据约束。<ul>
<li>数据结构用于描述数据之间的关系和组织方式</li>
<li>数据操作用于描述对数据的操作和处理方式</li>
<li>数据约束用于描述数据之间的约束条件和限制。</li>
</ul>
</li>
</ul>
<h4 id="数据模式-schema"><a href="#数据模式-schema" class="headerlink" title="数据模式 schema"></a>数据模式 schema</h4><ul>
<li><p>用一种给定的数据模型对一个特定的企业进行描述得到的结果就是数据模式，数据库中数据的结构和组织方式，包括</p>
<ul>
<li>数据库的结构：包括数据库中所有表格和关系之间的结构。</li>
<li>数据表格的结构：包括表格的名称、字段名、数据类型、约束等。</li>
<li>数据表格之间的关系：包括一对一、一对多、多对多等关系。</li>
<li>约束：包括主键、外键、唯一约束、非空约束等。</li>
</ul>
</li>
<li><blockquote>
<p>学生表格、课程表格和选课表格分别对应了三个数据表格，通过定义表格中的字段和约束等信息，定义了数据库中存储的数据的类型、结构、格式、关系和约束等信息。例如，在选课表格中，使用 FOREIGN KEY 约束定义了学生编号和课程编号与学生表格和课程表格之间的关系，从而实现了学生选课信息的存储和查询。</p>
</blockquote>
</li>
</ul>
<h4 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h4><ul>
<li>主要概念：关系，用表来记录关系<ul>
<li>行：元组</li>
<li>列：属性</li>
</ul>
</li>
</ul>
<h4 id="数据库三级模式"><a href="#数据库三级模式" class="headerlink" title="数据库三级模式"></a>数据库三级模式</h4><ul>
<li>第一级：Physical Schema 【物理模式】<ul>
<li>描述了数据在磁盘上是如何存储的</li>
</ul>
</li>
<li>第二级：Conceptal Schema 【概念模式】<ul>
<li>逻辑结构</li>
<li>概念模式中的这些表称为基表，与物理模式的表一一对应</li>
</ul>
</li>
<li>第三级：many view  【外模式】<ul>
<li>给最终用户看到的数据的样子</li>
</ul>
</li>
</ul>
<h5 id="举例：学生选课管理数据库"><a href="#举例：学生选课管理数据库" class="headerlink" title="举例：学生选课管理数据库"></a>举例：学生选课管理数据库</h5><ul>
<li>概念模式：<ul>
<li>学生（学号，名字，年龄，GPA）</li>
<li>课程（课程号，课程名）</li>
<li>选课关系（学号，课程号，成绩）</li>
</ul>
</li>
<li>物理模式：<ul>
<li>用堆文件形式存储这三张表</li>
<li>在学生的某项信息中建立索引</li>
</ul>
</li>
<li>外模式：<ul>
<li>课程信息表（课程号，选课人数）</li>
</ul>
</li>
</ul>
<h5 id="分析其中两级映射关系"><a href="#分析其中两级映射关系" class="headerlink" title="分析其中两级映射关系"></a>分析其中两级映射关系</h5><ul>
<li>外模式中的视图都是概念模式相关信息的可计算映射</li>
<li>物理模式与逻辑模式之间存在存储映射</li>
</ul>
<h4 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h4><ul>
<li>基于数据库开发的应用程序与数据的具体结构和具体存储方法之间相互隔离</li>
<li>数据的逻辑独立性：基于数据库开发的应用程序不受数据库内数据逻辑变化的影响</li>
<li>数据的物理独立性：基于数据库开发的应用程序不受数据库物理存储结构变化的影响</li>
</ul>
<h3 id="数据库技术发展历史及分类"><a href="#数据库技术发展历史及分类" class="headerlink" title="数据库技术发展历史及分类"></a>数据库技术发展历史及分类</h3><h4 id="数据模型的发展历史"><a href="#数据模型的发展历史" class="headerlink" title="数据模型的发展历史"></a>数据模型的发展历史</h4><ul>
<li>无管理阶段（1960）<ul>
<li>科学计算</li>
</ul>
</li>
<li>非数值应用<ul>
<li>文件系统：简单的数据管理</li>
</ul>
</li>
<li>数据管理的要求不断增强，DBMS出现<ul>
<li>1964，第一个DBMS：IDS，network（网状数据模型）</li>
<li>1969，层次数据模型</li>
<li>1970，关系数据模型</li>
<li>面向对象数据模型……</li>
</ul>
</li>
</ul>
<h4 id="数据库管理系统的体系结果发展"><a href="#数据库管理系统的体系结果发展" class="headerlink" title="数据库管理系统的体系结果发展"></a>数据库管理系统的体系结果发展</h4><ul>
<li>集中式数据库系统</li>
<li>并行数据库系统</li>
<li>分布式数据库系统</li>
<li>移动数据库系统</li>
</ul>
<h4 id="应用的发展"><a href="#应用的发展" class="headerlink" title="应用的发展"></a>应用的发展</h4><ul>
<li>集中式结构</li>
<li>分布式结构</li>
<li>客户/服务器结构<ul>
<li>客户端安装应用程序</li>
<li>多个客户端访问一个服务器</li>
</ul>
</li>
<li>三层/多层体系结构<ul>
<li>多个服务器<ul>
<li>分为Web 服务器</li>
<li>APP服务器</li>
<li>客户端只要能跑浏览器</li>
<li>DB 服务器</li>
</ul>
</li>
<li>优点：<ul>
<li>应用升级只需要升级app 服务器</li>
<li>客户端成本降低</li>
<li>活动范围增大</li>
</ul>
</li>
</ul>
</li>
<li>移动计算</li>
<li>云计算/网格计算</li>
</ul>
<h4 id="从数据库系统的应用领域分"><a href="#从数据库系统的应用领域分" class="headerlink" title="从数据库系统的应用领域分"></a>从数据库系统的应用领域分</h4><ul>
<li>OLTP：日常事务处理</li>
<li>工程数据库</li>
<li>多媒体数据库</li>
<li>时态数据库</li>
<li>空间数据库</li>
</ul>
<h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>应用程序+DBMS+数据库+DBA（数据库管理员）</p>
<h4 id="DBMS是数据库系统的核心"><a href="#DBMS是数据库系统的核心" class="headerlink" title="DBMS是数据库系统的核心"></a>DBMS是数据库系统的核心</h4><ul>
<li>提供高级访问接口</li>
<li>支持有效的查询处理和优化</li>
<li>目录管理</li>
<li>提供并发控制和恢复功能【数据一致性保证】</li>
<li>提供完整性约束</li>
<li>提供访问控制</li>
</ul>
<h3 id="数据库系统的生命周期"><a href="#数据库系统的生命周期" class="headerlink" title="数据库系统的生命周期"></a>数据库系统的生命周期</h3><ul>
<li>数据库系统的规划阶段</li>
<li>数据库设计</li>
<li>在数据库内创建加载数据</li>
<li>基于数据库开发应用程序、管理和维护</li>
<li>数据库重构</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库系统及其应用</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA-数据库管理系统</title>
    <url>/posts/61473.html</url>
    <content><![CDATA[<p><a href="/posts/57766.html">详见-数据库管理系统及其实现</a></p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库系统及其应用</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA-数据库安全和完整性约束</title>
    <url>/posts/8042.html</url>
    <content><![CDATA[<h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="数据库数据被破坏的原因"><a href="#数据库数据被破坏的原因" class="headerlink" title="数据库数据被破坏的原因"></a>数据库数据被破坏的原因</h4><ul>
<li>系统的软硬件故障 【DBMS的恢复机制】</li>
<li>很多用户的并发访问控制不当  【DBMS的并发控制】</li>
<li>人为破坏   【数据库的安全性】</li>
<li>数据库输入的数据不正确  【数据库的完整性约束】</li>
</ul>
<h4 id="保证数据库数据安全的措施"><a href="#保证数据库数据安全的措施" class="headerlink" title="保证数据库数据安全的措施"></a>保证数据库数据安全的措施</h4><ol>
<li><p>利用视图和查询修改</p>
<p>视图之前讲过了，看不到基表</p>
<p>查询修改，自动在查询语句后加限制条件，看不到别的学院的数据</p>
</li>
<li><p>访问控制</p>
<p>对用户进行分类来给不同的权限</p>
<ul>
<li>普通用户</li>
<li>DBA（所有权限）</li>
<li>有资源特权的用户 创建数据对象（表、视图），授权给别人对这些对象的访问权限</li>
</ul>
</li>
<li><p>用户标识和用户认证</p>
<ul>
<li><p>每个用户有一个用户标识</p>
</li>
<li><p>通过password进行用户认证</p>
</li>
</ul>
</li>
<li><p>授权【权限检查】</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> JOHN IDENTIFIED <span class="keyword">BY</span> jjjjj;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 在数据库建立一个用户JOHN，password为jjjjj</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 基本访问权限</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> S <span class="keyword">TO</span> U1 <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 对数据对象进行授权，U1的用户可对S表做<span class="keyword">select</span>操作，<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION是允许权力转授 给别人这个权限</span><br></pre></td></tr></table></figure>
<ol>
<li><p>role【角色机制】</p>
<p>针对角色进行授权，通过该方法提高权限控制</p>
</li>
<li><p>数据加密</p>
<p>不能绕过操作系统对数据库的数据进行访问，但是还是有可能会突破这层限制</p>
<ul>
<li><p>加密后存储【密码学】</p>
</li>
<li><p>代价：加密解密影响效率</p>
</li>
</ul>
</li>
<li><p>审计追踪</p>
<ul>
<li>结合数据库日志，可以在关注的对象上添加审计追踪，会记录该对象上进行的操作 </li>
</ul>
</li>
</ol>
<h3 id="统计数据库的安全"><a href="#统计数据库的安全" class="headerlink" title="统计数据库的安全"></a>统计数据库的安全</h3><ul>
<li><p>实际应用中一些统计结果可以给所有人看，但个体数据不可公开的情况</p>
</li>
<li><p>防止合法用户通过合法查询经过推算得到他不可得的隐私数据</p>
<p>员工的基本信息</p>
<p><img src="/posts/8042/image-20220402115213368.png" alt="image-20220402115213368"></p>
<p>保密薪水信息，允许做统计信息，可以查平均工资，男性平均工资，最高工资啥啥的</p>
<p><img src="/posts/8042/image-20220402115417893.png" alt="image-20220402115417893"></p>
<p>恰好男性程序员只有一个，SUM就能求出</p>
<p>限制 满足条件的元组数&gt;1</p>
<p><img src="/posts/8042/image-20220402115540957.png" alt="image-20220402115540957"></p>
<p>总男性10个，非男性程序员9个，剩下必须是王</p>
<p>求总工资，求非男性程序员总工资，一减又求出来了</p>
<p>再限制 M-B&gt;x&gt;B 2-8之间</p>
<p><img src="/posts/8042/image-20220402115738733.png" alt="image-20220402115738733"></p>
<p>男性员工4个，不是程序员的男性员工3个，剩下那个又是王</p>
<p>求男性员工总工资，非程序员的男性员工总工资，一减就是王的工资</p>
</li>
<li><p>统计数据库的安全难以保证：因为有个体追踪器和通用追踪器，而数据库不可能检查每一条谓词</p>
</li>
</ul>
<h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><p>完整性约束就是规则，一张表内所有元组都要满足的条件就是完整性约束</p>
<p>保证所有进入数据库的数据都是干净的</p>
<h3 id="静态约束"><a href="#静态约束" class="headerlink" title="静态约束"></a>静态约束</h3><p>限制数据库的状态</p>
<ol>
<li><p>数据模型固有的约束：</p>
<p>关系模型中的一范式（要求每一张表的每一个属性都是原子性的，不允许表中套表）</p>
</li>
<li><p>隐含约束</p>
<p>数据库表的模式定义里面的约束</p>
<p>如：域完整性约束（属性值符合定义域）、主键约束（唯一性）、外键约束【引用完整性约束】</p>
</li>
<li><p>显式约束</p>
<p>通过断言ASSERTION </p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ASSERT balanceCons【断言名字】 <span class="keyword">ON</span> account【表名】 :balance<span class="operator">&gt;=</span><span class="number">0</span> 【要求满足的属性条件】</span><br></pre></td></tr></table></figure>
<p>  通过应用程序，不满足条件的数据不接受</p>
<h3 id="动态约束"><a href="#动态约束" class="headerlink" title="动态约束"></a>动态约束</h3><p>数据库在状态转换（数据一致性）中要满足的约束叫做动态约束</p>
<h3 id="数据库的更新与引用完整性"><a href="#数据库的更新与引用完整性" class="headerlink" title="数据库的更新与引用完整性"></a>数据库的更新与引用完整性</h3><p>当有外键映射关系的两张表发生增删改操作时，数据库要做检查</p>
<p><img src="/posts/8042/image-20220403163805802.png" alt="image-20220403163805802"></p>
<p><strong>增</strong></p>
<p>当要在外键($α$)的表($r_2$)中增加元组$t_2$时，要在主键($K1$)的表($r_1$)进行检查，是否有对应主键的记录$t_1$，若没有就报错</p>
<p>$t_1[K_1]=t_2[α]$</p>
<p><img src="/posts/8042/image-20220403181933743.png" alt="image-20220403181933743"></p>
<p><strong>删</strong></p>
<p>如果要删除主键($K1$)的表的某条元组$t_1$时，要检查外键$α$的表$r_2$内是否有对应的值(选择操作)，如果查询结果为空，那么可以删，如果不为空的话，数据库会提供两种情况【由用户在定义表的时候决定】：</p>
<p><img src="/posts/8042/image-20220403182219584.png" alt="image-20220403182219584"></p>
<ul>
<li>报错【默认】</li>
<li>级联删除<ul>
<li>主键的表和外键的表的对应元组一同删除</li>
</ul>
</li>
</ul>
<p><strong>改</strong></p>
<p>想对外键表内已有的元组做更新，要检查要修改的新值是否在主键的表内有，如果有就能更新，如果没有就报错</p>
<p><img src="/posts/8042/image-20220403182753559.png" alt="image-20220403182753559"></p>
<p>向对主键表内已有的元组做更新，要检查外键的表内是否有对应的值，如果查询结果为空，那么可以直接修改，如果不为空的话，数据库会提供两种选择【由用户在定义表的时候决定】：</p>
<p><img src="/posts/8042/image-20220403182801494.png" alt="image-20220403182801494"></p>
<ul>
<li>报错【默认】</li>
<li>级联更新<ul>
<li>主键的表和外键的表的对应元组一同更改</li>
</ul>
</li>
</ul>
<h3 id="显式约束"><a href="#显式约束" class="headerlink" title="显式约束"></a>显式约束</h3><ol>
<li><p>Indicated with procedure</p>
<p>可以在编程时制定约束</p>
</li>
<li><p>Indicated with ASSERTION</p>
<p>断言语句，余额必须大于0</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ASSERT balanceCons <span class="keyword">ON</span> account: balance<span class="operator">&gt;=</span><span class="number">0</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 断言 名称 在 表名: 属性 约束;</span><br></pre></td></tr></table></figure>
<ol>
<li>Indicated with CHECK clause in base table</li>
</ol>
<ul>
<li>要求该表的级别的属性的值为大于等于1，小于等于10的整数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sailors(</span><br><span class="line">sid <span class="type">INTEGER</span>,</span><br><span class="line">sname <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">rating <span class="type">INTEGER</span>,</span><br><span class="line">age <span class="type">REAL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(sid),</span><br><span class="line"><span class="keyword">CHECK</span>(rating<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">AND</span> rating<span class="operator">&lt;=</span><span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>要求水手数和船的数的和要小于100</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sailors (</span><br><span class="line">sid <span class="type">INTEGER</span>,</span><br><span class="line">sname <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">age <span class="type">REAL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(sid),</span><br><span class="line"><span class="keyword">CHECK</span>(</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(S.sid) <span class="keyword">FROM</span> Sailors S)</span><br><span class="line"><span class="operator">+</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(B.bid) <span class="keyword">FROM</span> Boats B)<span class="operator">&lt;</span><span class="number">100</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>这样查询，如果长时间在船的表添加，而不往水手的表内添加的话就无法进行合理查询，当涉及多个表的约束要使用断言更好</span><br><span class="line">  <span class="operator">/</span><span class="operator">/</span>只在该表进行查、删、改操作时才执行<span class="keyword">CHECK</span>的检查</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION smallClub</span><br><span class="line"><span class="keyword">CHECK</span></span><br><span class="line">((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span> (S.sid) <span class="keyword">FROM</span> Sailors S)</span><br><span class="line"><span class="operator">+</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span> (B.bid) <span class="keyword">FROM</span> Boats B) <span class="operator">&lt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>用于动态约束</p>
<p>主动数据库：能对数据库采取一些主动的动作。</p>
<ul>
<li><p>数据库的主动依赖于规则</p>
<ul>
<li>ECA规则：E为事件、C为条件、A为动作。即当事件E发生，且条件C满足时，采取A动作</li>
</ul>
</li>
<li><p>触发器就是ECA规则</p>
</li>
<li><p>不同数据库的实现方法不同</p>
</li>
<li><p>例子：当在水手的表插入的水手年龄小于等于18时，同时向年轻水手的表内也插入</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> youngerSailorUptate <span class="operator">/</span><span class="operator">/</span>触发器名字</span><br><span class="line">AFTER[触发时机 <span class="keyword">or</span> BEFORE] <span class="keyword">INSERT</span> <span class="keyword">ON</span> SAILORS</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="keyword">TABLE</span> NewSailors [对水手表新插入的元组看出一张表 <span class="keyword">NEW</span> 新值 <span class="keyword">OLD</span> 老值]</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">INSERT</span>  </span><br><span class="line">    <span class="keyword">INTO</span> YoungSailors(sid,name,age,rating)</span><br><span class="line">    <span class="keyword">SELECT</span> sid,name,age,rating</span><br><span class="line">    <span class="keyword">FROM</span> NewSailors N</span><br><span class="line">    <span class="keyword">WHERE</span> N.age <span class="operator">&lt;=</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<h3 id="触发器的执行策略"><a href="#触发器的执行策略" class="headerlink" title="触发器的执行策略"></a>触发器的执行策略</h3><ol>
<li><p>立即执行【常用】</p>
<p>当事件发生时立刻去检查条件是否满足</p>
</li>
<li><p>延迟执行</p>
<p>等事务要提交时执行</p>
</li>
<li><p>分离执行</p>
<p>把ECA规则中的动作单独作为一个事务，作为原来事务的衍生事务</p>
</li>
</ol>
<h3 id="连锁触发问题"><a href="#连锁触发问题" class="headerlink" title="连锁触发问题"></a>连锁触发问题</h3><p>当触发器的动作内也有触发器产生连锁触发</p>
<p>连锁触发可能产生环路：类似递归中的无限递归</p>
<h3 id="避免连锁触发"><a href="#避免连锁触发" class="headerlink" title="避免连锁触发"></a>避免连锁触发</h3><ul>
<li>构造触发图</li>
<li>对连锁触发的次数进行限制</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库系统及其应用</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA-SQL语言</title>
    <url>/posts/2657.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>DBMS必须提供一些接口给用户使用数据库，用户接口类型包括<ul>
<li>查询语言【核心】<ul>
<li>形式化查询语言</li>
<li>表格式查询语言</li>
<li>图形化查询语言</li>
<li>受限制的自然语言查询</li>
</ul>
</li>
<li>访问数据库的工具（GUI）</li>
<li>API（解决在应用程序中访问数据库）</li>
<li>类库</li>
</ul>
</li>
</ul>
<h3 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h3><ul>
<li>查询语言：让用户有效的从数据库中检索需要的数据</li>
<li>关系模型支持简单，有力的查询语言</li>
<li>查询语言不是编程语言<ul>
<li>查询语言不是图灵完备的，不具备编程能力</li>
<li>不能做复杂计算</li>
</ul>
</li>
</ul>
<h4 id="形式化基础"><a href="#形式化基础" class="headerlink" title="形式化基础"></a>形式化基础</h4><h5 id="数学化"><a href="#数学化" class="headerlink" title="数学化"></a>数学化</h5><ul>
<li>关系代数 【过程化】</li>
<li>关系演算 【非过程化】</li>
</ul>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul>
<li>数据定义语言【DDL】</li>
<li>查询语言【QL】</li>
<li>数据操纵语言【DML】</li>
<li>数据控制语言【DCL】</li>
</ul>
<h4 id="重要术语与概念"><a href="#重要术语与概念" class="headerlink" title="重要术语与概念"></a>重要术语与概念</h4><ul>
<li>Base Table 基表<ul>
<li>关系模型中的关系【物理存在的】</li>
</ul>
</li>
<li>View 视图<ul>
<li>虚表  </li>
</ul>
</li>
<li>数据类型</li>
<li>NULL  <ul>
<li>保留字：空值</li>
</ul>
</li>
<li>UNIQUE<ul>
<li>保留字：表的某个属性是否允许有重复值</li>
</ul>
</li>
<li>DEFAULT<ul>
<li>保留字：为某张表的某个属性默认缺损值</li>
</ul>
</li>
<li>PRIMARY KEY<ul>
<li>保留字：主键</li>
</ul>
</li>
<li>FOREIGN KEY<ul>
<li>保留字：外键</li>
</ul>
</li>
<li>CHECK<ul>
<li>保留字：定义完整性约束</li>
</ul>
</li>
</ul>
<h4 id="基本的SQL查询"><a href="#基本的SQL查询" class="headerlink" title="基本的SQL查询"></a>基本的SQL查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] target<span class="operator">-</span>list</span><br><span class="line"><span class="keyword">FROM</span>     relation<span class="operator">-</span>list</span><br><span class="line"><span class="keyword">WHERE</span>   qualification</span><br></pre></td></tr></table></figure>
<ul>
<li>关系列表 relation-list  【查询设计的表】</li>
<li>目标列表  target-list    【要查询的东西】</li>
<li>条件   qualification   【布尔表达式】</li>
<li>DISTINCT 可选字符，加了的话表明要求系统对查询结果的重复元组要消除。 </li>
</ul>
<h4 id="查询语句执行的基本策略"><a href="#查询语句执行的基本策略" class="headerlink" title="查询语句执行的基本策略"></a>查询语句执行的基本策略</h4><ul>
<li>把FROM子句里出现的表做笛卡尔乘积</li>
<li>把笛卡尔乘积的觉果用qualification做筛选</li>
<li>根据target-list 内的对上一步结果做投影</li>
<li>如果有DISTINCT，将重复元组筛选</li>
</ul>
<h5 id="范围变量"><a href="#范围变量" class="headerlink" title="范围变量"></a>范围变量</h5><ul>
<li><p>即在FROM 内给表取别名，只要不会引起混淆，可以不加别名【下面的写法相同】</p>
</li>
<li><p>找出预定了船号为103的水手的姓名</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname  【最规范写法】</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid <span class="keyword">AND</span> R.bid<span class="operator">=</span><span class="number">103</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid <span class="keyword">AND</span> bid <span class="operator">=</span><span class="number">103</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT sname</span><br><span class="line">FROM Sailors,Reserves</span><br><span class="line">WHERE Sailors.sid = Reserves.sid AND bid = 103</span><br></pre></td></tr></table></figure>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><ul>
<li><p>SELECT 不同时，慎重考虑是否要加DISTINCT</p>
<ul>
<li>找出至少预定过一次船的水手</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br></pre></td></tr></table></figure>
<ul>
<li>比如：此例中若将sid 改为sname 那么加不加DISTINCT对结果的意义就有影响。</li>
</ul>
<ul>
<li>SELECT 子句中可以使用表达式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.age,age1<span class="operator">=</span>S.age<span class="number">-5</span>,<span class="number">2</span><span class="operator">*</span>S.age <span class="keyword">AS</span> age2   <span class="operator">/</span><span class="operator">/</span>给结果属性命名的两种办法【不一定两种方法都支持】</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="keyword">LIKE</span> <span class="string">&#x27;B_%B&#x27;</span>   <span class="operator">/</span><span class="operator">/</span>支持用<span class="keyword">like</span>表达的模糊查询</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用集合的交和并方式进行查找</p>
<ul>
<li>找出预定过一艘红船或者预定过一艘绿船的水手的编号</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span>(B.color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span> <span class="keyword">or</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span>【所有预定红船的水手编号】</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>【所有预定绿船的水手编号】</span><br></pre></td></tr></table></figure>
<ul>
<li>更新问题为：预定过红船和绿船的水手的标号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B1,Reserves R1,Boats B2,Reserves R2  【进行自连接】</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R1.sid <span class="keyword">AND</span> R1.bid<span class="operator">=</span>B1.bid <span class="keyword">AND</span> S.sid<span class="operator">=</span>R2.sid <span class="keyword">AND</span> R2.bid<span class="operator">=</span>B2.bid</span><br><span class="line"><span class="keyword">AND</span> (B1.color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span> <span class="keyword">AND</span> B2.color<span class="operator">=</span><span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">【自连接方法效率不高】</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span>【所有预定红船的水手编号】</span><br><span class="line"><span class="keyword">INTERSECT</span> 【集合的交不是每个数据库都支持】 </span><br><span class="line"><span class="keyword">SELECT</span> S.sid</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>【所有预定绿船的水手编号】</span><br><span class="line">【集合的交操作】</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sid </span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R </span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span> <span class="keyword">AND</span> S.sid <span class="keyword">in</span> ( <span class="keyword">SELECT</span> S.sid </span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Boats B,Reserves R </span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span>R.sid <span class="keyword">AND</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span> )</span><br><span class="line">【嵌套查询的方法】</span><br></pre></td></tr></table></figure>
<ul>
<li><p>嵌套查询</p>
<ul>
<li>找出预定了103号船的水手姓名</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="keyword">IN</span>(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    WHRER R.bid<span class="operator">=</span><span class="number">103</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>该例子为非关联嵌套，子查询只执行一次</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    WHRER R.bid<span class="operator">=</span><span class="number">103</span> <span class="keyword">AND</span> S.sid <span class="operator">=</span>R.sid)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>该查询为关联嵌套，子查询要做多次【相当于二层循环】</p>
</li>
<li><p>且只被一个水手预定过的船的编号：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  bid</span><br><span class="line"><span class="keyword">FROM</span> Reserves R1</span><br><span class="line"><span class="keyword">WHERE</span> bid <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> bid</span><br><span class="line">        <span class="keyword">FROM</span> Reserves R2</span><br><span class="line">        <span class="keyword">WHERE</span> R2.sid <span class="operator">!=</span> R1.sid)</span><br></pre></td></tr></table></figure>
<ul>
<li>查找出一个水手级别比任何一个叫Horatio的水手级别高的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.rating <span class="operator">&gt;</span> <span class="keyword">ANY</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> S2.rating</span><br><span class="line">    <span class="keyword">FROM</span> Sailors S2</span><br><span class="line">    <span class="keyword">WHERE</span> S2.sname <span class="operator">=</span> <span class="string">&#x27;Horatio&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>除法</p>
<ul>
<li>找出预定了所有船的水手</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    ((<span class="keyword">SELECT</span> B.bid</span><br><span class="line">    <span class="keyword">FROM</span> Boats B)  【所有的船】</span><br><span class="line">    <span class="keyword">EXCEPT</span>   【减去】</span><br><span class="line">    (SLELECT R.bid </span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.sid <span class="operator">=</span>S.sid)【该水手订过的船】</span><br><span class="line">     【结果就是该水手没订过的船，若不存在，那么他就订过所有的船】</span><br><span class="line">    ) </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> B.bid</span><br><span class="line">            <span class="keyword">FROM</span> Boats B</span><br><span class="line">            <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> R.bid</span><br><span class="line">            <span class="keyword">FROM</span> Reserves R</span><br><span class="line">            <span class="keyword">WHERE</span> R.bid <span class="operator">=</span>B.bid</span><br><span class="line">            <span class="keyword">AND</span> R.sid <span class="operator">=</span> S.sid</span><br><span class="line">            ))</span><br><span class="line">            【双重否定表肯定】</span><br></pre></td></tr></table></figure>
<h3 id="SQL语言内的函数运算"><a href="#SQL语言内的函数运算" class="headerlink" title="SQL语言内的函数运算"></a>SQL语言内的函数运算</h3><ul>
<li>COUNT* <ul>
<li>统计关系里面有多少元组</li>
</ul>
</li>
<li>COUNT([DISTINCT]A)<ul>
<li>统计关系属性A有多少个不同的值</li>
</ul>
</li>
<li>SUM<ul>
<li>求和</li>
</ul>
</li>
<li>AVG <ul>
<li>求平均值</li>
</ul>
</li>
<li>MAX<ul>
<li>求最大值</li>
</ul>
</li>
<li>MIN<ul>
<li>求最小值</li>
</ul>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COUNT <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S </span><br><span class="line">【查找有多少个水手】</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> S.rating)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="operator">=</span><span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">【叫bob的有多少个级别】</span><br></pre></td></tr></table></figure>
<h5 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h5><h6 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h6><ul>
<li>SELECT    target-list</li>
<li>FROM    relation-list</li>
<li>WHERE    qualification</li>
<li>GROUP BY   grouping-list【将筛选后得到的结果通过group by进行分组得到grouping-list】</li>
<li>HAVING    group-qualification 【对group by 得到的组进行筛选】</li>
</ul>
<h6 id="概念化执行步骤"><a href="#概念化执行步骤" class="headerlink" title="概念化执行步骤"></a>概念化执行步骤</h6><ul>
<li>把 FROM子句中出现的表进行笛卡尔乘积，拼接起来</li>
<li>用where子句的qualification进行筛选</li>
<li>按照group-by将经过筛选后的元组进行分组</li>
<li>用having子句对分组进行筛选</li>
<li>将筛选后的组通过select子句进行运算，每一个组得到一个结果</li>
<li>要求，select 子句和having子句中的属性必须是group by分组属性值的子集</li>
</ul>
<h6 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h6><ul>
<li>求出年龄大于18岁的水手里每个级别最年轻的水手，且级别组人数有2个以上</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.rating,<span class="built_in">MIN</span>(S.age) <span class="keyword">AS</span> minage</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.age<span class="operator">&gt;=</span><span class="number">18</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查每一条红船的预定人数有多少</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> B.bid,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> scount</span><br><span class="line"><span class="keyword">FROM</span> Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> B.bid,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> scount</span><br><span class="line"><span class="keyword">FROM</span> Boats B,Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid</span><br><span class="line"><span class="keyword">HAVING</span> B.color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span></span><br><span class="line">【报错。此处的<span class="keyword">having</span>属性的值不是<span class="keyword">group</span> <span class="keyword">by</span>的子集】</span><br></pre></td></tr></table></figure>
<ul>
<li>找出年龄大于18的各个级别中的最小年龄，级别人数至少为两人（任意年龄）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.rating,<span class="built_in">MIN</span>(S.age)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.age<span class="operator">&gt;</span><span class="number">18</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="number">1</span><span class="operator">&lt;</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S2</span><br><span class="line"><span class="keyword">WHERE</span> S2.rating<span class="operator">=</span>S.rating)</span><br></pre></td></tr></table></figure>
<ul>
<li>查找平均年龄最小的级别</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Temp.rating</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> S.rating,<span class="built_in">AVG</span>(S.age)<span class="keyword">AS</span> avgage</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.rating)<span class="keyword">AS</span> Temp</span><br><span class="line"><span class="keyword">WHERE</span> Temp.avgage <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(Temp.avgage)</span><br><span class="line"><span class="keyword">FROM</span> Temp)</span><br></pre></td></tr></table></figure>
<ul>
<li>FROM语句里面也可以嵌套查询</li>
</ul>
<h4 id="空值问题"><a href="#空值问题" class="headerlink" title="空值问题"></a>空值问题</h4><ul>
<li><p>空值是不知道，是没有。</p>
</li>
<li><p>需要一些特别的操作判断是否为空</p>
</li>
<li>考虑空值与布尔表达式的影响</li>
<li>需要三级逻辑（真、假、不知道）</li>
</ul>
<h3 id="一些扩展"><a href="#一些扩展" class="headerlink" title="一些扩展"></a>一些扩展</h3><h4 id="CAST表达式"><a href="#CAST表达式" class="headerlink" title="CAST表达式"></a>CAST表达式</h4><ul>
<li>类似于C、C++的强制类型转换</li>
<li>CAST + NULL(Expression)  AS  Data type</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>符合函数语法</li>
<li>改变计算精度</li>
<li>给空值赋予数据类型</li>
</ul>
<h4 id="CASE表达式"><a href="#CASE表达式" class="headerlink" title="CASE表达式"></a>CASE表达式</h4><ul>
<li>可以简单的做条件判断</li>
</ul>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="keyword">WHEN</span> type<span class="operator">=</span><span class="string">&#x27;chain saw&#x27;</span> <span class="keyword">THEN</span> accidents </span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">0e0</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><ul>
<li>一个查询里面嵌套着查询就是子查询</li>
</ul>
<h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><ul>
<li><p>标量子查询</p>
<ul>
<li>查询结果就是单个的值</li>
</ul>
</li>
<li><p>表表达式</p>
<ul>
<li>查询结果是一张表</li>
</ul>
</li>
<li><p>公共表表达式</p>
<ul>
<li>在一些复杂的查询中，一个表表达式可能需要用到多次，将它只定义一次，多次调用结果</li>
</ul>
</li>
<li><ul>
<li><p>用with子句可以定义公共表表达式【相当于是一个临时视图】</p>
</li>
<li><p>例子</p>
<ul>
<li>找出哪个部门的工资最高</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> payroll(deptno,totalpay) <span class="keyword">AS</span>(<span class="keyword">SELECT</span> deptno totalpay</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno)</span><br><span class="line"><span class="keyword">SELECT</span> deptno</span><br><span class="line"><span class="keyword">FROM</span> payroll</span><br><span class="line"><span class="keyword">WHERE</span> totalpay<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">max</span>(totalpay)</span><br><span class="line"><span class="keyword">FROM</span> payroll)</span><br></pre></td></tr></table></figure>
<h4 id="Outer-Join-外连接"><a href="#Outer-Join-外连接" class="headerlink" title="Outer Join 外连接"></a>Outer Join 外连接</h4><ul>
<li>EXCEPT和EXCEPT ALL<ul>
<li>都是做集合差，但EXCEPT ALL 不删重复元组，也就不用排序，效率比EXCEPT高</li>
</ul>
</li>
<li>用UNION ALL对多个SELECT结果并起来【这就是外连接】</li>
</ul>
<h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><ul>
<li>在公共表表达式中用了自己的查询就是递归查询</li>
</ul>
<h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> agents(name,salary) <span class="keyword">AS</span></span><br><span class="line">((<span class="keyword">SELECT</span> name,salary    【<span class="keyword">initial</span> query】</span><br><span class="line"><span class="keyword">FROM</span> FedEmp</span><br><span class="line"><span class="keyword">WHERE</span> manager<span class="operator">=</span><span class="string">&#x27;Hoover&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">(<span class="keyword">SELECT</span> f.name,f.salary   【<span class="keyword">recursive</span> query】</span><br><span class="line"><span class="keyword">FROM</span> agents <span class="keyword">AS</span> a,FedEmp <span class="keyword">AS</span> f</span><br><span class="line"><span class="keyword">WHERE</span> f.manager<span class="operator">=</span>a.name))</span><br><span class="line"><span class="keyword">SELECT</span> name 【<span class="keyword">final</span> query】        </span><br></pre></td></tr></table></figure>
<ul>
<li><p>飞机零件例子【有向无环图】</p>
</li>
<li><p>飞机航班例子【有向有环图】</p>
<ul>
<li>控制递归的结束条件</li>
</ul>
</li>
</ul>
<h3 id="数据操纵语言"><a href="#数据操纵语言" class="headerlink" title="数据操纵语言"></a>数据操纵语言</h3><ul>
<li><p>DELETE</p>
<ul>
<li>把表内满足条件的元组删除</li>
</ul>
</li>
<li><p>UPDATE</p>
<ul>
<li>把满足条件的元组的某些值进行更新</li>
</ul>
</li>
<li><p>Insert</p>
<ul>
<li><p>向表内插入元组</p>
</li>
<li><p>例子</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> employees <span class="keyword">values</span>(&quot;smith&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="SQL中的视图"><a href="#SQL中的视图" class="headerlink" title="SQL中的视图"></a>SQL中的视图</h3><h5 id="分类及相关介绍"><a href="#分类及相关介绍" class="headerlink" title="分类及相关介绍"></a>分类及相关介绍</h5><ul>
<li>普通视图【虚表】<ul>
<li>实现外模式</li>
<li>利用视图和逻辑模式的映射实现数据的逻辑独立性</li>
<li>数据库只存储视图的定义，不存储数据，数据在调用时临时计算，数据内容非永久保存</li>
<li>实现了数据库的安全性</li>
<li>对视图内数据的修改的问题</li>
</ul>
</li>
<li>临时视图【公共表表达式】<ul>
<li>没有存储视图的定义</li>
<li>可以实现递归查询</li>
</ul>
</li>
</ul>
<h3 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h3><ul>
<li>为了实现和程序设计语言结合，解决的问题<ul>
<li>如何让程序设计语言接收SQL语言</li>
<li>DBMS和应用程序如何交换数据和信息</li>
<li>DBMS的查询结果是个集合，如何传递给程序设计语言中的变量</li>
<li>DBMS支持的数据类型和应用程序支持的数据类型不是完全一样</li>
</ul>
</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>嵌入式SQL</li>
<li>编程的API</li>
<li>封装的类</li>
</ul>
<h5 id="以C语言中的嵌入式SQL"><a href="#以C语言中的嵌入式SQL" class="headerlink" title="以C语言中的嵌入式SQL"></a>以C语言中的嵌入式SQL</h5><ul>
<li>以ECEC SQL,开始，以；结尾会被预编译器识别为嵌入式SQL命令</li>
<li>用宿主变量在DBMS和应用程序之间交换数据和消息</li>
<li>在SQL命令里，可以用：的方法引用宿主变量的值</li>
<li>宿主变量在C语言中就当一个普通的变量使用</li>
<li>不可以把宿主变量定义为数组或结构</li>
<li>一个特殊的宿主变量，通过SQLCA在C和DBMS进行数组交换</li>
<li>SQLCA.SQLCODE 可以判断查询结果</li>
<li>用说明符来表示宿主变量的NULL</li>
</ul>
<h6 id="定义数组变量"><a href="#定义数组变量" class="headerlink" title="定义数组变量"></a>定义数组变量</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line"><span class="type">char</span> SNO[<span class="number">7</span>];</span><br><span class="line"><span class="type">char</span> GIVENSNO[<span class="number">7</span>];</span><br><span class="line"><span class="type">char</span> CNO[<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> GIVENCNO[<span class="number">6</span>];</span><br><span class="line"><span class="type">float</span> GRADE;</span><br><span class="line"><span class="type">short</span> GRADE1;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br></pre></td></tr></table></figure>
<h6 id="执行命令的方式"><a href="#执行命令的方式" class="headerlink" title="执行命令的方式"></a>执行命令的方式</h6><ul>
<li>连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL CONNECT :uid IDENTIFIED BY:pws: ;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行DML语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL INSERT INTO <span class="title function_">SC</span><span class="params">(SNO,CNO,GRADE)</span><span class="title function_">VALUES</span><span class="params">(:SNO,:CNO,:GRADE)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询【简单查询，返回一个值】</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL SELECT GRADE INTO :GRADE,:GRADE1</span><br><span class="line">FROM SC</span><br><span class="line">WHERE SNO=:GIVENSNO AND CNO=:GIVENCNO;</span><br></pre></td></tr></table></figure>
<p>为了处理查询返回的集合，引入游标机制</p>
<h6 id="Cursor游标的操作步骤"><a href="#Cursor游标的操作步骤" class="headerlink" title="Cursor游标的操作步骤"></a>Cursor游标的操作步骤</h6><ul>
<li>定义游标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC SQL DECLARE 游标名 CURSOR FOR</span><br><span class="line">SELECT</span><br><span class="line">FROM </span><br><span class="line">WHERE</span><br></pre></td></tr></table></figure>
<ul>
<li>执行游标【可以理解为打开一个文件】</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL OPEN 游标名</span><br></pre></td></tr></table></figure>
<ul>
<li>取游标内每一条元组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL FETCH 游标名</span><br><span class="line">INTO  :hostvar1,:hostvar2;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>判断查询结果是否取完</p>
<ul>
<li>SQLCA.SQLCODE ==100 时取完</li>
</ul>
</li>
<li><p>关闭CURSOR</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CLOSE CURSOR</span><br></pre></td></tr></table></figure>
<h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><p>上一个例子运用CURSOR的SQL语句是确定的，为了实现动态的SQL，</p>
<ul>
<li>可以直接运行的动态SQL【非查询】</li>
<li>动态SQL的查询【带动态参数】</li>
<li>动态构造查询语句</li>
</ul>
<h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><ul>
<li><p>可以直接运行的动态SQL【非查询】</p>
<ul>
<li>用字符数组动态拼接出一条sql语句</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL EXECUTE IMMEDIATE :sqlstring;</span><br></pre></td></tr></table></figure>
<ul>
<li>让系统动态的及时执行sqlstring中的sql语句</li>
</ul>
<ul>
<li><p>动态SQL的查询【带动态参数】</p>
<ul>
<li>运用占位符</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL PREPARE PURGE FROM :sqlstring;【sql命令执行准备】</span><br><span class="line">EXEC SQL EXECUTE PURGE USING:birth_yers;【将参数替换】</span><br></pre></td></tr></table></figure>
<ul>
<li><p>动态构造查询语句</p>
<ul>
<li>用字符数组动态拼接出一条查询语句</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL PREPARE query FROM :sqlstring;   【先准备一下查询语句】</span><br><span class="line">EXEC SQL DECLARE grade_cursor CURSOR FOR query; 【建立一个游标】</span><br><span class="line">EXEC SQL OPEN grade_cursor USING :GIVENCNO; 【在此处替换占位符】</span><br></pre></td></tr></table></figure>
<h3 id="存储过程机制"><a href="#存储过程机制" class="headerlink" title="存储过程机制"></a>存储过程机制</h3><ul>
<li>允许用户把一组常用的sql定义为一个存储过程，系统对其优化编译后可以被直接调用。<ul>
<li>用户使用更加方便，应用需求发生变化时，只需要改变存储过程</li>
<li>改进性能</li>
<li>可以扩展DBMS的功能</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库系统及其应用</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA-数据库设计</title>
    <url>/posts/11989.html</url>
    <content><![CDATA[<h2 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h2><ul>
<li>关系数据库内数据之间存在一定的数据依赖关系</li>
</ul>
<h3 id="函数依赖FD"><a href="#函数依赖FD" class="headerlink" title="函数依赖FD"></a>函数依赖FD</h3><p>Function Dependency</p>
<p>一个属性的值可以唯一的决定其它属性的值</p>
<p>学号可以唯一决定姓名、年龄等等</p>
<h3 id="多值依赖MVD"><a href="#多值依赖MVD" class="headerlink" title="多值依赖MVD"></a>多值依赖MVD</h3><p>Multi-valued Dependency</p>
<p>一个属性的值决定其它属性的一组值</p>
<p>实际生活存在但很少</p>
<h3 id="连接依赖JD"><a href="#连接依赖JD" class="headerlink" title="连接依赖JD"></a>连接依赖JD</h3><p>Join Dependency</p>
<p>关系属性之间能够无损连接</p>
<ul>
<li>无损连接：连接后的元组数一个不多，一个不少</li>
</ul>
<p>实际生活存在但很少</p>
<p>供应商-零件-工程的三元关系</p>
<p>某一个供应商供应零件某个操作</p>
<p>分解成三张表：供应商-零件 供应商-工程 零件-工程</p>
<p>再把这三张表连接能够完全还原原来的表</p>
<p>那么就叫无损连接分解</p>
<p>例如 某工程需要某零件，并且某供应商提供该零件，那么该工程必须去采购该供应商提供的零件才能满足无损连接分解，否则还原就会出现之前没有的记录</p>
<h2 id="关系模式的规范化"><a href="#关系模式的规范化" class="headerlink" title="关系模式的规范化"></a>关系模式的规范化</h2><h3 id="关系模式的范式理论"><a href="#关系模式的范式理论" class="headerlink" title="关系模式的范式理论"></a>关系模式的范式理论</h3><h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p>第一范式</p>
<p>不支持表中套表</p>
<p>关系中的每一个元组必须是原子【即不可再分】</p>
<p><img src="/posts/11989/image-20220405201338202.png" alt="image-20220405201338202"></p>
<p>分解Address</p>
<h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p> 第二范式</p>
<p>数据库设计时，设计出来的表满足一范式，并且该表内不存在属性对主键的部分函数依赖</p>
<p>例子：</p>
<p>若属性由（学号、姓名、班级、课程号、成绩）五个属性组成，其中（学号，课程号）共同组成主键。</p>
<ul>
<li>此时不满足二范式。</li>
<li>其中的姓名和班级，只需要依赖主键中的学号而不需要课程号就可以得到</li>
</ul>
<p>不满足2范式容易出现的问题：</p>
<ul>
<li><p>插入异常</p>
<p>上例中，不能插入一个还未选课的学生的信息，逐渐不能为空</p>
</li>
<li><p>删除异常</p>
<p>上例中，如果一个学生申请休学，把选过的课退了，那么他的信息也会被删除</p>
</li>
<li><p>更新异常</p>
<p>更新中难以保持数据的一致性，上例的设计有大量的数据冗余</p>
<p>每次更新学生数据，每一个选课记录都得改</p>
</li>
</ul>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul>
<li>设计时，一事一地。<ul>
<li>一张表只管一件事情</li>
<li>可以分解为学号-课程号-成绩和学号-姓名-班级两张表</li>
</ul>
</li>
</ul>
<h4 id="3-NF"><a href="#3-NF" class="headerlink" title="3 NF"></a>3 NF</h4><p>第三范式</p>
<p>在满足二范式的前提下，不存在属性对主键的传递依赖。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>若属性由（职工编号、工资级别、工资）三个属性组成，其中（职工编号）为主键。</p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>工资取决于工资级别，工资级别取决于职工编号</p>
<h5 id="上例不满足3范式的问题"><a href="#上例不满足3范式的问题" class="headerlink" title="上例不满足3范式的问题"></a>上例不满足3范式的问题</h5><ul>
<li>插入异常：当一个人的工资级别还没定的时候，他对应的工资也没有</li>
<li>删除异常：3级工资的人只有一个，若删除，会把对应的工资级别信息也删除了</li>
<li>更新异常：数据内有大量的冗余，1级工资对应1000元，会重复很多次，修改也很麻烦</li>
</ul>
<h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><ul>
<li>设计时，一事一地。<ul>
<li>一张表只管一件事情</li>
<li>一张职工编号-职工等级表，一张职工等级-工资表</li>
</ul>
</li>
</ul>
<h4 id="4-NF-四范式"><a href="#4-NF-四范式" class="headerlink" title="4 NF 四范式"></a>4 NF 四范式</h4><ul>
<li>在满足三范式的前提下，消除多值依赖。</li>
</ul>
<h4 id="5-NF-五范式"><a href="#5-NF-五范式" class="headerlink" title="5 NF 五范式"></a>5 NF 五范式</h4><ul>
<li>在满足四范式的前提下，消除连接依赖。</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><p><img src="/posts/11989/image-20220405203447643.png" alt="image-20220405203447643"></p>
<p>设计如下三张表：</p>
<ol>
<li>第一行设备基本信息表</li>
<li>第二行设备存放位置</li>
<li>第三行设备入库出库的记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	1[1NF]--消除属性对主键的部分函数依赖--&gt;2[2NF]--消除属性对主键的传递依赖--&gt;3[3Nf-足够了]--消除多值依赖--&gt;4[4NF]--消除多值依赖--&gt;5[5NF];</span><br></pre></td></tr></table></figure>
<h2 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h2><p><img src="/posts/11989/image-20220406145343358.png" alt="image-20220406145343358"></p>
<h2 id="数据库设计方法"><a href="#数据库设计方法" class="headerlink" title="数据库设计方法"></a>数据库设计方法</h2><h3 id="面向过程的方法"><a href="#面向过程的方法" class="headerlink" title="面向过程的方法"></a>面向过程的方法</h3><p>根据单位日常处理的流程，以过程为中心。</p>
<ul>
<li>好处<ul>
<li>在设计初期，能比较快的实现</li>
</ul>
</li>
<li>缺点<ul>
<li>没分析数据之间的关系，数据有冗余和矛盾，当流程进行改动时，会有很多问题</li>
</ul>
</li>
</ul>
<h3 id="面向对象的方法"><a href="#面向对象的方法" class="headerlink" title="面向对象的方法"></a>面向对象的方法</h3><p>依然会分析流程，但是需要归纳流程涉及到的数据，是以数据为中心的方法</p>
<p>分析数据之间的关系，设计一些符合3NF的模式</p>
<h2 id="数据库设计流程"><a href="#数据库设计流程" class="headerlink" title="数据库设计流程"></a>数据库设计流程</h2><p><img src="/posts/11989/image-20220406145943349.png" alt="image-20220406145943349"></p>
<ol>
<li><p>Requirement Analysis</p>
<p>需求分析，与用户交流确定需求</p>
<ol>
<li><p>Information requirement</p>
<p>每一项业务需要涉及到哪些信息</p>
</li>
<li><p>Process requirement</p>
<p>每一项业务需要对这些数据做什么处理（增删改查）</p>
</li>
<li><p>Requirement indication</p>
<p>结果是得到需求分析报告，需要和用户反复讨论、确认</p>
</li>
</ol>
</li>
<li><p>Concept Design</p>
<p>概念设计，与用户讨论，分析数据之间的关系（实体）、实体及实体间的逻辑，利用ER图来进行描述，和用什么数据库系统实现无关</p>
<p>得到DBMS independent data schema</p>
<p>确保用户的所有业务都能在我们设计的schema基础上顺利执行</p>
</li>
<li><p>Logic Design</p>
<p>逻辑设计，看采用哪一种数据库系统，生成全局模式（基表的属性、属性类型等等）【<strong>concept schema</strong>】，定义视图【<strong>outer schema</strong>】</p>
</li>
<li><p>Physical Design</p>
<p>物理设计，考虑数据在磁盘上到底如何存储，默认都是堆文件，但是比如学生基本信息表比较适合用簇集，而在某些属性上是否应该添加B+树索引</p>
<p>得到【<strong>inner schema</strong>】</p>
</li>
</ol>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>数据字典：把所有的基本数据元素都找出来</p>
<p>数据流图DFD or UML</p>
<p>解决问题：</p>
<ul>
<li><p>名字冲突</p>
<ul>
<li>同名异意，都叫编号，学号、设备编号啥的</li>
<li>异名同意，学号、学生编号啥的</li>
</ul>
</li>
<li><p>概念冲突</p>
<p>同一个概念，一个部门用作属性，一个部门用作实体</p>
<p>院系，可以作为学生表的属性，也可以作为实体（表）</p>
<p>是否需要视为实体，如果需要，则如何设置属性指向该表，院系编号</p>
</li>
<li><p>域冲突</p>
<p>同一个概念，名称、意义都没有区别，但是值域有区别，比如性别可以男\女、0\1、F\M</p>
</li>
<li><p>编码</p>
<ul>
<li>实现信息的标准化，学号（专业、院系、入学年份）</li>
<li>标识符，唯一标识实体</li>
<li>压缩信息，院系单独作为一张表，编号代表院系，而不是全称</li>
</ul>
</li>
</ul>
<p>通过需求分析，所有信息都要有唯一的来源和职责</p>
<h3 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h3><p>在数据字典和数据流图的基础上</p>
<ul>
<li>用ER图抽象出实体，哪些数据应该抽象形成一个实体</li>
<li>定义实体间的联系</li>
<li>绘制ER图（ERWin，Rose），与用户讨论</li>
</ul>
<h3 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h3><ul>
<li>把ER图表达的数据模型进行建表</li>
<li>表和属性的命名规则</li>
<li>定义每个属性的类型和值域</li>
<li><p>适当的逆规范化</p>
<ul>
<li>权衡效率和范式规范</li>
<li>采取一些存储过程、编程规范防止出现逆规范的问题</li>
</ul>
</li>
<li><p>定义必要的视图</p>
</li>
<li>考虑遗留系统的接口表的设计</li>
</ul>
<h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><p>根据DBMS特点对每个表的存储和索引情况进行权衡</p>
<ul>
<li>分区设计</li>
<li>存储过程</li>
<li>触发器</li>
<li>完整性约束</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>仅仅在结构上满足3范式是不够的</li>
<li>一事一地包括每项信息的唯一，要提取出问题的本质，识别本质上同一概念的信息项</li>
<li>对于表达类似信息、能合并尽量合并</li>
<li>考虑到效率、用途等因素、该分开的要分开</li>
<li>结合DBMS内部实现技术，合理设计索引和文件结构，为查询优化准备号存取路径</li>
<li>在结构规范化、减少数据冗余和提高数据库访问性能之间仔细权衡，适当折中</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库系统及其应用</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA-数据模型</title>
    <url>/posts/49403.html</url>
    <content><![CDATA[<h3 id="层次数据模型"><a href="#层次数据模型" class="headerlink" title="层次数据模型"></a>层次数据模型</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>由于现实世界中很多事物之间本身就存在层次关系，层次数据模型尝试用树来描述这些。</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>记录   record<ul>
<li>把现实世界一个实体表达为一个记录</li>
</ul>
</li>
<li>域   field<ul>
<li>一个记录由若干个域来描述</li>
</ul>
</li>
<li>双亲子女关系（Parent-Child Relationship，PCR）：表达现实生活中一对多的关系</li>
</ul>
<h4 id="层次型数据库的数据模式"><a href="#层次型数据库的数据模式" class="headerlink" title="层次型数据库的数据模式"></a>层次型数据库的数据模式</h4><ul>
<li>一个层次数据模型有多个PCR</li>
<li>每一个PCR表示一个1对多的关系</li>
<li>每一个记录类型只有一个父节点</li>
</ul>
<h4 id="虚记录"><a href="#虚记录" class="headerlink" title="虚记录"></a>虚记录</h4><h5 id="现有的PCR技术难以表示现实生活中下列类型的关系"><a href="#现有的PCR技术难以表示现实生活中下列类型的关系" class="headerlink" title="现有的PCR技术难以表示现实生活中下列类型的关系"></a>现有的PCR技术难以表示现实生活中下列类型的关系</h5><ul>
<li>现实生活中很多数据不是层次型，它难以用PCR表示<ul>
<li>记录之间的多对多关系</li>
<li>一个记录类型可能有不止一个父节点</li>
<li>多元关系</li>
</ul>
</li>
</ul>
<h5 id="引入虚记录"><a href="#引入虚记录" class="headerlink" title="引入虚记录"></a>引入虚记录</h5><ul>
<li>为了避免数据的冗余，且保持树状结构<ul>
<li>引入指针，由虚记录指向相应的真实记录</li>
</ul>
</li>
</ul>
<h3 id="网状数据模型"><a href="#网状数据模型" class="headerlink" title="网状数据模型"></a>网状数据模型</h3><h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>网状模型的基本数据结构为set【系】，一个set表达现实世界中两个数据类型的一对多关系。其中一为主记录，多为属记录。在网状模型中，一个记录类型可以是多个类型的主记录，也可以是多个类型的属记录。</li>
</ul>
<h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>突破了层次结构的限制，能更容易地表示非层次型数据</li>
<li>记录 record</li>
<li>data items <ul>
<li>与域相似，但它可以是向量</li>
</ul>
</li>
<li>set 表达两个记录类型的一对多关系 <ul>
<li>是一个链表</li>
</ul>
</li>
<li>Link记录类型<ul>
<li>可以表示多对多关系</li>
<li>可以表示多元关系</li>
<li>类型内的自连接<ul>
<li>用雇员【上司】与对应的link构成一个系s1</li>
<li>link对雇员【手下】之间构成系s2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h3><h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>关系模型的基本数据结构是表，即关系。将现实生活中实体和实体之间的联系全部用表来表示。将表看出多个元组【记录】的集合，可以采用数学的研究方法进行研究。</li>
</ul>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>基于数学集合论，有更高的抽象级别</li>
<li>屏蔽了所有的底层细节，易于理解</li>
<li>可以建立新的代数系统——关系代数</li>
<li>定义一个非过程化的查询语言——SQL<ul>
<li>非过程化，不需要程序员自己编写一步步的程序</li>
</ul>
</li>
<li>软连接<ul>
<li>一种逻辑指针</li>
</ul>
</li>
</ul>
<h4 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h4><ul>
<li>属性 Attributes<ul>
<li>称为列</li>
<li>一个实体的多种方面的信息，称为属性</li>
</ul>
</li>
<li>域 Domain<ul>
<li>每一个属性有一定的取值范围，称为域，表内数据的要求<ul>
<li>原子数据【不可再分】</li>
<li>允许属性的值为空值【空值为不知道，不是0也不是空串】</li>
</ul>
</li>
</ul>
</li>
<li>关系 Relation<ul>
<li>简称为表</li>
<li>现实世界的实体和实体间的联系用关系表达</li>
</ul>
</li>
<li>元组 Tuple<ul>
<li>表内每一行称为元组</li>
</ul>
</li>
<li>目 <ul>
<li>属性的数量</li>
</ul>
</li>
<li>主键<ul>
<li>候选键满足以下条件<ul>
<li>这个关系内任意两条不同的元组这个属性的值都不一样【这组属性的值能够唯一的决定其它的值】</li>
<li>该组属性的任意一个子集没有这个特性</li>
</ul>
</li>
<li>满足第一个而第二个不满足的话就称为超键（关系模式中，能唯一标识元组的属性集称为<em>超键</em>）</li>
<li>候选键可能有多个，可以指定其中一个为主键，其余的为候补键</li>
<li>如果主键是由该关系内所有属性组成，则称为全键</li>
</ul>
</li>
<li>外键<ul>
<li>在一个关系内，有一组属性用来引用另一张表内的元组，那么该外键应为另一张表的主键。</li>
<li>引用完整性：如果我们把外键看成是一个逻辑指针，那么该逻辑指针指向的不能为空【即没有】。</li>
</ul>
</li>
</ul>
<h5 id="外键的例子"><a href="#外键的例子" class="headerlink" title="外键的例子"></a>外键的例子</h5><ul>
<li>选课的表</li>
<li>学生的表</li>
<li>通过sid </li>
</ul>
<h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><ul>
<li>通过外键的引用完整性约束</li>
<li>域完整性约束：元组内的每个属性的值都要在定义的域的范围内</li>
<li>实体完整性约束：一个关系里定义的一个主键，主键的值不能为空，如果主键为空就无法进行唯一性标识</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li>该例子会在后面提到的关系代数和关系演算中用到</li>
<li>水手和船的预订</li>
</ul>
<p><strong>R1 水手和船的预订关系表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sid</th>
<th>bid</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>22</td>
<td>101</td>
<td>10/10/96</td>
</tr>
<tr>
<td>58</td>
<td>103</td>
<td>11/12/96</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>sid 水手编号 bid 船编号 day 预定日期</li>
</ul>
<p><strong>S1   Saliors  水手信息表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sid</th>
<th>sname</th>
<th>rating</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>22</td>
<td>dustin</td>
<td>7</td>
<td>45.0</td>
</tr>
<tr>
<td>31</td>
<td>lubber</td>
<td>8</td>
<td>55.5</td>
</tr>
<tr>
<td>58</td>
<td>rusty</td>
<td>10</td>
<td>35.0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>sid 水手编号 sname 水手姓名 rateing 水手级别 age 水手年龄</li>
</ul>
<p><strong>B1 船信息表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>bid</th>
<th>bname</th>
<th>color</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>tiger</td>
<td>red</td>
</tr>
<tr>
<td>103</td>
<td>lion</td>
<td>green</td>
</tr>
<tr>
<td>105</td>
<td>hero</td>
<td>blue</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>bid 船的编号 bname 船的名字 color 船的颜色</li>
</ul>
<p><strong>S2 Saliors  水手信息表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sid</th>
<th>sname</th>
<th>rating</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>28</td>
<td>yuppy</td>
<td>9</td>
<td>35.0</td>
</tr>
<tr>
<td>31</td>
<td>lubber</td>
<td>8</td>
<td>55.5</td>
</tr>
<tr>
<td>44</td>
<td>guppy</td>
<td>5</td>
<td>35.0</td>
</tr>
<tr>
<td>58</td>
<td>rusty</td>
<td>10</td>
<td>35.0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>sid 水手编号 sname 水手姓名 rateing 水手级别 age 水手年龄</li>
</ul>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><ul>
<li>关系模型的理论基础</li>
</ul>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li>选择操作σ   从一个表中把满足条件的元组选出来</li>
<li>projection 投影操作π   将需要的属性列出来</li>
<li>笛卡尔乘积×  两个关系的拼接</li>
<li>集合差- 把属于关系A不属于关系B的元组找出来</li>
<li>并 ∪    把两个模式相同的元组并起来</li>
</ul>
<h5 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h5><ul>
<li>join </li>
<li>division</li>
<li>intersection</li>
<li>outer union</li>
<li>outer join</li>
</ul>
<h6 id="操作的具体例子和详细讲解"><a href="#操作的具体例子和详细讲解" class="headerlink" title="操作的具体例子和详细讲解"></a>操作的具体例子和详细讲解</h6><ul>
<li>投影操作运算结果的模式就是投影的<ul>
<li>定义上说：投影操作要消除重复元组</li>
<li>实际数据库系统并不主动删除重复元组，除非用户主动要求</li>
</ul>
</li>
<li><p>选择操作就是从一个表中把满足条件的元组选出来</p>
<ul>
<li>选择操作不会产生重复元组【只要原关系中没有重复元组】</li>
<li>选择操作的模式与原关系的模式相同</li>
<li>选择操作的结果可以作为别的代数关系的输入</li>
</ul>
</li>
<li><p>集合的并、交、差</p>
<ul>
<li>参与集合的两个关系要满足两个条件<ul>
<li>属性个数相同</li>
<li>属性类型要一样</li>
</ul>
</li>
</ul>
</li>
<li>笛卡尔乘积<ul>
<li>结果模式包括进行操作的两个表的所有属性，两张表的每条元组之间两两拼接</li>
</ul>
</li>
<li>条件连接操作<ul>
<li>由笛卡尔乘积和选择操作的结合</li>
<li>结果模式和迪卡尔乘积的模式相同</li>
<li>连接操作的结果的元组数比笛卡尔乘积的结果元组要少</li>
<li>也称为theta-join</li>
</ul>
</li>
<li>等值连接操作<ul>
<li>一种特殊的条件连接，连接条件只有等值的条件</li>
<li>结果模式和笛卡尔乘积的模式类似，把等值的属性去掉一列</li>
<li>自然连接：两张表在所有的公共属性上做等值连接【应用开发最常用的】</li>
</ul>
</li>
<li>Division 除法操作<ul>
<li>不是一种必备的操作，但是它适合回答一些问题<ul>
<li>比如：找出水手预定的所有船只</li>
</ul>
</li>
<li>假设A有两种属性，x和y；B只有一种属性y：<ul>
<li>也可能x和y是一个集合</li>
</ul>
</li>
<li>A/B = {\<x>|ョ<x,y>∈A，∀\<y\>∈B}</y\></x,y></x></li>
<li>计算思路：比如对于A/B来说，我们要找在关系A中跟关系B中所有y值都有联系的x值。【也就是找出在关系B中没有一个y值与A的是没有联系的。否定的否定】<ul>
<li>先在A中找不满足除法条件的x<ul>
<li>先把A做一个投影，投影到x属性</li>
<li>将投影结果和关系B做一个笛卡尔乘积</li>
<li>用笛卡尔乘积结果-A</li>
<li>对上一步结果做一个投影，投影到x</li>
</ul>
</li>
<li>把关系A所有的x值减去所有不满足条件的x值<ul>
<li>把关系A投影到x</li>
<li>投影结果减去上一操作找到的所有不满足条件的x值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Outer joins 外连接</p>
<ul>
<li>解决情况：在自然连接中不满足连接操作的元组想要保留下来。</li>
<li>分类<ul>
<li>左外连接<ul>
<li>把连接运算符的左边的所有元组都要保留，找不到匹配的补空值</li>
</ul>
</li>
<li>右外连接<ul>
<li>把连接运算符的右边的所有元组都保留下来，找不到匹配的补空值</li>
</ul>
</li>
<li>全外连接<ul>
<li>把连接运算符的左右两边的所有元组都保留下来，找不到匹配的补空值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Outer Unions 外并操作</p>
<ul>
<li>解决情况：把不满足并兼容条件的两个关系强行并起来。</li>
<li>结果的属性集是参与运算的两个关系的属性的并，元组也是参与运算的两个关系的元组的并，单一存在的补空值</li>
</ul>
</li>
</ul>
<h3 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h3><ul>
<li>关系代数是一种过程化的表达。</li>
<li>关系演算是一个非过程化的表达。</li>
</ul>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>关系演算中把各种布尔表达式称为公式，查询结果元组是能使公式为真的表内的元组。</li>
</ul>
<h5 id="TRC-元组关系演算"><a href="#TRC-元组关系演算" class="headerlink" title="TRC 元组关系演算"></a>TRC 元组关系演算</h5><ul>
<li>以元组为单位定义变量</li>
<li>查询语句{t[\<attribute list>] | P(t)}</attribute></li>
<li>查询结果：取一个元组变量t内包含的若干属性，能使p（t）为真。</li>
</ul>
<h6 id="元组关系演算例子"><a href="#元组关系演算例子" class="headerlink" title="元组关系演算例子"></a>元组关系演算例子</h6><ul>
<li>找到一个级别大于7，且比50岁年轻的水手的姓名<ul>
<li>{t[N] | t ∈ Sailor ^ t.T&gt;7 ^ t.A&lt;50}</li>
</ul>
</li>
</ul>
<h5 id="DRC-域关系演算"><a href="#DRC-域关系演算" class="headerlink" title="DRC 域关系演算"></a>DRC 域关系演算</h5><ul>
<li><p>以属性为单位定义变量</p>
</li>
<li><p>查询语句：{<x1,x2,…,xn>|P(x1,x2,…,xn,xn+1,…,xn+m)}</x1,x2,…,xn></p>
</li>
<li>在要查询的属性上定义一组变量，根据需求定义布尔表达式，找出满足布尔表达式的元组。布尔表达式从原子公式开始，再利用逻辑连接符构成更复杂，更大的公式。<ul>
<li>域关系演算中的原子公式<ul>
<li><x1,x2,…,xn> ∈ Rname</x1,x2,…,xn></li>
<li>x op y : op 就是＞，＜，=，大于等于，小于等于，≠</li>
<li>x op 常量</li>
</ul>
</li>
<li>公式的定义：<ul>
<li>一个原子公式p</li>
<li>否定p,p^q,pvq，其中p和q都是公式</li>
<li>存在x(p(x)),公式p内的x是free的，那么就是一个公式</li>
<li>所有任意x(p(x)),其中公式p内的x是free的，那么就是一个公式</li>
</ul>
</li>
<li>如果在一个域变量内使用了存在量词或全称量词，那么就是被绑定了，没有被绑定就是free的。</li>
</ul>
</li>
</ul>
<h6 id="域关系演算例子"><a href="#域关系演算例子" class="headerlink" title="域关系演算例子"></a>域关系演算例子</h6><ul>
<li>查找水手表里级别大于7的<ul>
<li>${<I,N,T,A>|<I,N,T,A> ∈Sailors ^ T&gt;7}$</I,N,T,A></I,N,T,A></li>
<li>$I,N,T,A$四个变量表示是一个水手元组，要求该元组要在水手表内，且T变量的值大于7，其中T就是级别这个属性</li>
</ul>
</li>
<li>找出一个水手的年龄大于18，级别小于9，且名字叫做joe<ul>
<li>${<I,N,T,A>|<I,N,T,A> ∈Sailors ^ T<9 ^ a="Joe">18 }$</9></I,N,T,A></I,N,T,A></li>
</ul>
</li>
</ul>
<h4 id="安全查询问题"><a href="#安全查询问题" class="headerlink" title="安全查询问题"></a>安全查询问题</h4><ul>
<li>满足公式的结果可能会无限多，那么这个查询就是不安全的</li>
</ul>
<h4 id="表达能力"><a href="#表达能力" class="headerlink" title="表达能力"></a>表达能力</h4><ul>
<li><p>关系代数与关系演算的表达能力等价，只是考虑问题的角度和表达方式不同</p>
</li>
<li><p>SQL语言的表达能力也与关系代数与关系演算等价</p>
</li>
</ul>
<h3 id="传统数据模型评价"><a href="#传统数据模型评价" class="headerlink" title="传统数据模型评价"></a>传统数据模型评价</h3><h4 id="传统数据模型"><a href="#传统数据模型" class="headerlink" title="传统数据模型"></a>传统数据模型</h4><ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
</ul>
<h5 id="共同特点与不足"><a href="#共同特点与不足" class="headerlink" title="共同特点与不足"></a>共同特点与不足</h5><ul>
<li>都适用于OLTP【联机事物处理】应用<ul>
<li>OLTP：以记录为基础，基于结构化数据，不能很好的面向用户和应用</li>
</ul>
</li>
<li>不能用很自然的方法表达现实世界的模型，表达能力有限</li>
<li>模型本身缺乏语义信息</li>
<li>支持的数据类型少，难以满足需求应用需求</li>
</ul>
<h3 id="ER数据模型"><a href="#ER数据模型" class="headerlink" title="ER数据模型"></a>ER数据模型</h3><h4 id="术语和概念-1"><a href="#术语和概念-1" class="headerlink" title="术语和概念"></a>术语和概念</h4><ul>
<li>实体：把现实世界中可区别可区分的都表达为实体，一个实体由一组属性描述</li>
<li>实体集：所有相似实体的集合。<ul>
<li>一个实体集内所有实体有同样的实体</li>
<li>每一个实体有一个键</li>
<li>每一个属性有一个域</li>
<li>允许有复合类型属性、允许有多值属性</li>
</ul>
</li>
<li>联系：<ul>
<li>现实世界中两个或多个实体间的关系就叫做联系</li>
<li>联系也可以有属性</li>
</ul>
</li>
<li>联系集：<ul>
<li>所有同类联系组成的集就是联系集</li>
<li>一个联系集合是n个实体之间的n元关系</li>
<li>同一个实体集可以参与不同的联系，或者当不同的角色</li>
</ul>
</li>
<li>ER模型的语义信息比传统的更多</li>
</ul>
<h4 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h4><h5 id="语义约束"><a href="#语义约束" class="headerlink" title="语义约束"></a>语义约束</h5><h6 id="奇数比约束"><a href="#奇数比约束" class="headerlink" title="奇数比约束"></a>奇数比约束</h6><ul>
<li>可以有1对多，多对一，1对1，多对多</li>
</ul>
<h6 id="参与度约束"><a href="#参与度约束" class="headerlink" title="参与度约束"></a>参与度约束</h6><ul>
<li>可以设置某一个实体参与一个联系的最小和最大次数。</li>
</ul>
<h4 id="扩展的ER模型"><a href="#扩展的ER模型" class="headerlink" title="扩展的ER模型"></a>扩展的ER模型</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><ul>
<li>弱实体<ul>
<li>不能单独存在，相当于职工和职工家属，职工家属就是弱实体</li>
</ul>
</li>
<li>普遍化与特殊化<ul>
<li>与面向对象中的子类与父类的继承相似</li>
<li>学生与研究生</li>
</ul>
</li>
<li>聚集<ul>
<li>允许把两个实体集间的联系看出一个实体集，让这个实体集和别的实体集间建立联系</li>
</ul>
</li>
<li>范畴<ul>
<li>一个集合内的实体是由不同类型的实体构成</li>
<li>举例<ul>
<li>银行账户有企业账户、私人账户</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="面向对象数据模型"><a href="#面向对象数据模型" class="headerlink" title="面向对象数据模型"></a>面向对象数据模型</h3><ul>
<li>突破了一范式的限制</li>
<li><p>来自于面向对象的分析和设计</p>
</li>
<li><p>对象关系数据系统</p>
<ul>
<li>在原有关系数据模型中有了抽象模型，突破了一范式的限制</li>
</ul>
</li>
</ul>
<h3 id="别的数据模型"><a href="#别的数据模型" class="headerlink" title="别的数据模型"></a>别的数据模型</h3><ul>
<li>基于逻辑的数据模型<ul>
<li>扩展DBMS的推理能力</li>
</ul>
</li>
<li>时态数据模型<ul>
<li>能有效的管理事态信息</li>
</ul>
</li>
<li>空间数据模型<ul>
<li>能表达一些空间物体之间的关系</li>
</ul>
</li>
<li>XML数据模型<ul>
<li>网络存储</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>数据库系统及其应用</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/posts/52196.html</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p><img src="/posts/52196/Git-Cheet-Sheet-ByGeekHour.png" alt="Git-Cheet-Sheet-ByGeekHour"></p>
<h2 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h2><p><code>Git</code>是一个免费开源的分布式版本控制系统，它使用一个特殊的叫做仓库的数据库来记录文件的变化，仓库中的每个文件都有一个完整的版本历史记录，可以看到谁在什么时间修改了哪些文件的哪些内容，在需要的时候也可以将文件恢复到之前的某一个版本</p>
<h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p><img src="/posts/52196/image-20240116180426658.png" alt="image-20240116180426658" style="zoom:33%;"></p>
<p>所有的文件都保存在中央服务器上，每个人的电脑上只保存了一个副本，当你需要修改文件的时候，首先要从中央服务器上下载最新的版本，然后添加你想要的修改内容，修改完成之后再上传回中央服务器</p>
<p>优势在于使用很简单直接，缺陷是中央服务器的单点故障问题：如果中央服务器出现故障或者网络连接出现问题，那么所有人都无法工作了，只能等待中央服务器或者网络恢复正常</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p><img src="/posts/52196/image-20240116180826680.png" alt="image-20240116180826680" style="zoom:33%;"></p>
<p>每个人在电脑上都有一个完整的版本哭，所以我们可以在本地进行修改，不需要考虑网络问题，这样即使中央服务器出现故障，我们也可以继续工作，当需要将我们的修改内容分享给其他人的时候，只需要将仓库互相同步一下就可以了</p>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p><a href="https://git-scm.com/book/zh/v2/起步-安装-Git">Git - 安装 Git (git-scm.com)</a></p>
<p>安装完成后，即可在终端输入<code>git -version</code>命令，如果能够显示版本信息，表示安装成功</p>
<p><img src="/posts/52196/image-20240116191916905.png" alt="image-20240116191916905"></p>
<p>配置用户名和邮箱，识别是谁提交的内容（首次执行即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name xzp314</span><br><span class="line">git config --global user.email 1146433856@qq.com</span><br></pre></td></tr></table></figure>
<p><code>--global</code> 表示全局配置，对所有仓库都生效</p>
<p><code>--system</code> 表示系统配置，对所有用户都生效</p>
<p>缺省（local）表示本地配置，只对本地仓库有效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<p>使用上述命令保存用户名和密码，避免每次都输入，这个命令设置了一个全局git配置，相当于告诉git在需要身份验证时使用store的凭证助手</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<p>使用上述命令可以查看我们配置的用户信息</p>
<p><img src="/posts/52196/image-20240117181722309.png" alt="image-20240117181722309"></p>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol>
<li><p><strong>命令行</strong></p>
</li>
<li><p>图形化界面（Sourcetree、fork、Github Desktop）</p>
<p> <a href="https://git-scm.com/downloads/guis">Git - GUI Clients (git-scm.com)</a></p>
</li>
<li><p>IDE插件/扩展</p>
<p> 在常用的IDEA或者VSCode这些IDE工具中，通过插件或者扩展的方式使用git</p>
</li>
</ol>
<h3 id="新建版本库"><a href="#新建版本库" class="headerlink" title="新建版本库"></a>新建版本库</h3><p>repository（repo）可以理解为一个目录，目录内所有文件都可以被Gti管理起来，对文件的任意操作（修改、删除、添加）都能被Git跟踪到，以便追溯或者还原任意文件到某个历史版本</p>
<p><strong>本地创建</strong></p>
<p>直接在本地某个目录执行<code>git init</code></p>
<p><img src="/posts/52196/image-20240117180746704-1705486721465-5.png" alt="image-20240117180746704"></p>
<p><img src="/posts/52196/image-20240117180839120-1705486726406-7.png" alt="image-20240117180839120"></p>
<p><code>.git</code>文件夹存储了Git仓库的所有数据，删除该文件，仓库也就被删除了</p>
<p><code>git init my-repo</code>则会在当前目录中创建一个子目录<code>my-repo</code>作为仓库</p>
<p><strong>远程创建</strong></p>
<p>通过<code>git clone</code>从Git的远程服务器克隆一个已经存在的仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xzp314/xzp314.github.io.git</span><br></pre></td></tr></table></figure>
<h3 id="工作区域和文件状态"><a href="#工作区域和文件状态" class="headerlink" title="工作区域和文件状态"></a>工作区域和文件状态</h3><p><code>Git</code>的本地数据管理分为三个区域：</p>
<ol>
<li>工作区：电脑上资源管理器能看到的目录、文件（<code>.git</code>所在的目录，可以进行操作）</li>
<li>暂存区：临时存储区域，用于保存即将提交到Git仓库的修改内容，用于进行版本控制（中间区域，临时存放内容）</li>
<li>本地仓库：存储完整的项目历史和元数据，是Git存储代码和版本信息的主要位置</li>
</ol>
<p><img src="/posts/52196/image-20240117183518971.png" alt="image-20240117183518971"></p>
<p>首先通过<code>git add</code>将被修改的文件添加到暂存区，然后通过<code>git commit</code>将文件内容统一提交到本地仓库，在这个过程中可以使用相关命令进行查看、比较或者撤销修改</p>
<p>工作区的文件也分为四种状态：</p>
<ol>
<li>未跟踪：新创建的文件，还没有被Git管理起来的文件</li>
<li>未修改：已被管理但文件的内容没有修改</li>
<li>已修改：已被管理且文件内容有所修改</li>
<li>已暂存：已经添加到暂存区中的文件</li>
</ol>
<p><img src="/posts/52196/image-20240117185309230.png" alt="image-20240117185309230"></p>
<h3 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h3><p><img src="/posts/52196/image-20240118151017301.png" alt="image-20240118151017301"></p>
<h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>查看当前仓库的状态，包括处于哪个分支、存储了哪些文件、文件状态如何</p>
<p><img src="/posts/52196/image-20240117185722222.png" alt="image-20240117185722222"></p>
<p>创建一个新文件 <code>test.txt</code>，再次查看仓库状态</p>
<p><img src="/posts/52196/image-20240117185829999.png" alt="image-20240117185829999"></p>
<p>新的文件<code>test.txt</code>目前就是未跟踪的状态（红色）</p>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p><strong>常规使用</strong></p>
<p>通过<code>git add test.txt</code>将该文件添加到暂存区，如果是新文件，那么就是对其进行跟踪</p>
<p><img src="/posts/52196/image-20240117190006994.png" alt="image-20240117190006994"></p>
<p>新文件也就被跟踪了（绿色），仓库中存在已经被修改但是没有<code>commit</code>的文件，同时用<code>git rm --cached &lt;file&gt;</code>这个命令可以将暂存区的文件取消暂存，这样文件又变回未跟踪状态了</p>
<p><img src="/posts/52196/image-20240117190318022.png" alt="image-20240117190318022"><img src="/posts/52196/image-20240117190329138.png" alt="image-20240117190329138"></p>
<hr>
<p><strong>通配符</strong></p>
<p><code>git add</code>还可以使用通配符<code>*</code>，比如我们创建<code>test2.txt</code>，<code>test3.txt</code>及<code>test4.md</code></p>
<p><img src="/posts/52196/image-20240117191630799.png" alt="image-20240117191630799"></p>
<p><code>git add *.txt</code>就可以把所有以<code>.txt</code>结尾的文件都添加到暂存区</p>
<p><img src="/posts/52196/image-20240117191735433.png" alt="image-20240117191735433"></p>
<hr>
<p><strong>目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add . 添加当前目录下所有文件</span><br><span class="line">git add directory 添加指定目录下所有文件</span><br></pre></td></tr></table></figure>
<p>使用<code>git add .</code>之后的仓库状态，就不存在未被跟踪的文件了</p>
<p><img src="/posts/52196/image-20240117192025206.png" alt="image-20240117192025206"></p>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>通过<code>git commit</code>将所有暂存区中的文件进行提交，与工作区中的文件无关，比如再创建一个新文件<code>test1.txt</code></p>
<p><img src="/posts/52196/image-20240117190536156.png" alt="image-20240117190536156"></p>
<p>需要注意的是<code>git commit</code>需要<code>-m</code>来设置提交的信息，该信息也会被记录到仓库中，提交完后，未被提交的文件已经消失了，只剩下未被跟踪的<code>test2.txt</code></p>
<p><img src="/posts/52196/image-20240117190644479.png" alt="image-20240117190644479"><img src="/posts/52196/image-20240117190817837.png" alt="image-20240117190817837"></p>
<hr>
<p>如果未使用<code>-m</code>指定提交信息，那么就会进入交互式界面，通过<code>vim</code>编辑提交信息（<code>i</code>进入插入模式，<code>esc</code>回到命令模式，输入<code>:wq</code>保存退出），此时所有文件就都提交了</p>
<p><img src="/posts/52196/image-20240117192312654.png" alt="image-20240117192312654"><img src="/posts/52196/image-20240117192334569.png" alt="image-20240117192334569"></p>
<h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>通过该命令可以查看提交历史记录，包括comit后面这个16进制的字符串就是唯一ID、提交作者、日期及提交信息</p>
<p><img src="/posts/52196/image-20240117192438717.png" alt="image-20240117192438717"></p>
<p><code>git log --oneline</code>显示简洁的提交记录</p>
<p><img src="/posts/52196/image-20240117192602280.png" alt="image-20240117192602280"></p>
<h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><p><code>git reset</code></p>
<p>退回到之前某一个提交<code>commit</code>的状态，有三种用法</p>
<ol>
<li><code>git reset --soft</code>：回退到某一个版本，并且保留工作区和暂存区的所有修改内容</li>
<li><code>git reset --hard</code>：回退到某一个版本，但是丢弃工作区和暂存区的所有修改内容</li>
<li><code>git reset --mixed</code>（默认参数）：回退到某一个版本，并且只保留工作区的修改内容，丢弃暂存区的修改内容</li>
</ol>
<p><img src="/posts/52196/image-20240117192952889.png" alt="image-20240117192952889"></p>
<p>示例</p>
<p>首先创建<code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code>三个文件，每次添加一个文件，就<code>commit</code>一次，暂存区中也保存了这三个文件</p>
<p><img src="/posts/52196/image-20240117193305434.png" alt="image-20240117193305434"><img src="/posts/52196/image-20240117193410956.png" alt="image-20240117193410956"><img src="/posts/52196/image-20240117194452195.png" alt="image-20240117194452195"></p>
<h4 id="git-reset-soft"><a href="#git-reset-soft" class="headerlink" title="git reset --soft"></a><code>git reset --soft</code></h4><p>附加提交记录的唯一标识即可回退到该版本，提交历史中的<code>file3</code>就消失了，因为回退到<code>file2</code>的版本</p>
<p><img src="/posts/52196/image-20240117193746202.png" alt="image-20240117193746202"></p>
<p>工作区<img src="/posts/52196/image-20240117194139385.png" alt="image-20240117194139385"><code>file3</code>存在</p>
<p>暂存区<img src="/posts/52196/image-20240117194201323.png" alt="image-20240117194201323"><code>file3</code>也还在，依然是跟踪状态</p>
<p>仓库状态<img src="/posts/52196/image-20240117194235489.png" alt="image-20240117194235489">新添加了一个文件<code>file3.txt</code>，但是已经被跟踪了，这就是<code>soft</code>的影响，回退的时候，工作区和暂存区的东西不会被清空（暂存区有3个文件)，但是回退到了之前的版本，<code>file3</code>对于<code>file2</code>这个版本就是一个新文件，所以仓库中就没有<code>file3</code>的提交信息了</p>
<h4 id="git-reset-hard"><a href="#git-reset-hard" class="headerlink" title="git reset --hard"></a><code>git reset --hard</code></h4><p><code>HEAD^</code>表示前一个版本</p>
<p><img src="/posts/52196/image-20240117194924343.png" alt="image-20240117194924343"></p>
<p>工作区<img src="/posts/52196/image-20240117195138612.png" alt="image-20240117195138612"><code>file3</code>不存在了</p>
<p>暂存区<img src="/posts/52196/image-20240117195222477.png" alt="image-20240117195222477"><code>file3</code>也没了</p>
<p>仓库状态<img src="/posts/52196/image-20240117195245425.png" alt="image-20240117195245425">啥都没了，就是因为<code>hard</code>清空了工作区和暂存区的文件</p>
<h4 id="git-reset-mixed"><a href="#git-reset-mixed" class="headerlink" title="git reset --mixed"></a><code>git reset --mixed</code></h4><p>缺省就是<code>mixed</code>模式</p>
<p><img src="/posts/52196/image-20240117195516384.png" alt="image-20240117195516384"></p>
<p>工作区<img src="/posts/52196/image-20240117195608099.png" alt="image-20240117195608099"><code>file3</code>还在</p>
<p>暂存区<img src="/posts/52196/image-20240117195633238.png" alt="image-20240117195633238"><code>file3</code>没了</p>
<p>仓库状态<img src="/posts/52196/image-20240117195658719.png" alt="image-20240117195658719">相当于<code>file3</code>是一个新创建且未被跟踪的文件</p>
<p><strong>适用场景</strong></p>
<p>当我们提交了多个版本，但是这么多次没有意义，就可以合并为一个版本，那么就用<code>soft | mixed</code>：</p>
<p>这两者的区别主要在于暂存区还有没有文件，如果所有提交的文件都有用，那么用<code>soft</code>就行，如果有部分是无效的，不需要提交，就用<code>mixed</code>，再手动选择文件进行<code>add</code>，最后提交</p>
<p><strong>hard误删</strong></p>
<p><code>git reflog</code>查看所有操作历史记录，再使用<code>reset</code>进行回溯即可</p>
<p><img src="/posts/52196/image-20240117200331803.png" alt="image-20240117200331803"></p>
<p><img src="/posts/52196/image-20240117200355822.png" alt="image-20240117200355822"></p>
<h3 id="对比文件差异"><a href="#对比文件差异" class="headerlink" title="对比文件差异"></a>对比文件差异</h3><p><code>git diff</code></p>
<ol>
<li>查看工作区、暂存区、本地仓库之间的差异</li>
<li>查看两个特定版本之间的差异</li>
<li>查看两个分支的差异</li>
</ol>
<p>主要使用方式偏向于图形化的工具，更为方便和简洁</p>
<p>不加参数，默认查看工作区和暂存区之间的差异，显示发生更改的文件以及更改的内容</p>
<p><img src="/posts/52196/image-20240118150942023.png" alt="image-20240118150942023"></p>
<p><strong>初始状态</strong></p>
<p><img src="/posts/52196/image-20240118144603728.png" alt="image-20240118144603728"></p>
<p>修改文件3的内容：”333”→”333+333”</p>
<h4 id="工作区-vs-暂存区"><a href="#工作区-vs-暂存区" class="headerlink" title="工作区 vs 暂存区"></a>工作区 vs 暂存区</h4><p>使用git diff查看工作区和暂存区之间的区别</p>
<p><img src="/posts/52196/image-20240118145100236.png" alt="image-20240118145100236"></p>
<p>有区别是因为工作区的文件暂时没有被添加到暂存区，添加之后，就没有区别了</p>
<p><img src="/posts/52196/image-20240118145359072.png" alt="image-20240118145359072"></p>
<h4 id="工作区-vs-版本库"><a href="#工作区-vs-版本库" class="headerlink" title="工作区 vs 版本库"></a>工作区 vs 版本库</h4><p><img src="/posts/52196/image-20240118145625153.png" alt="image-20240118145625153"></p>
<p>因为刚刚添加的内容还没有<code>commit</code>，所以是会有区别的，提交后自然就不会有输出了</p>
<h4 id="暂存区-vs-版本库"><a href="#暂存区-vs-版本库" class="headerlink" title="暂存区 vs 版本库"></a>暂存区 vs 版本库</h4><p><img src="/posts/52196/image-20240118145754931.png" alt="image-20240118145754931"></p>
<p>也是有区别的，当然，提交后也不会有输出了</p>
<h4 id="特定版本"><a href="#特定版本" class="headerlink" title="特定版本"></a>特定版本</h4><p><img src="/posts/52196/image-20240118150205518.png" alt="image-20240118150205518"></p>
<p>经常用到的是比较当前版本和前一个版本之间的差异，可以用波浪线，而如果加上数字则可以表示前几个版本，比如<code>HEAD~2</code>表示前两个版本</p>
<p><img src="/posts/52196/image-20240118150257309.png" alt="image-20240118150257309" style="zoom: 67%;"><img src="/posts/52196/image-20240118150631280.png" alt="image-20240118150631280" style="zoom: 67%;"></p>
<p>之前用到的<code>HEAD^</code>也能用于表示上一个版本，但是不能通过加数字表示前几个版本</p>
<p><img src="/posts/52196/image-20240118150324176.png" alt="image-20240118150324176"></p>
<h4 id="特定文件"><a href="#特定文件" class="headerlink" title="特定文件"></a>特定文件</h4><p><img src="/posts/52196/image-20240118150813894.png" alt="image-20240118150813894"></p>
<p>后面附加文件名，那么就只会查看该文件在两个版本的差异</p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>附加分支名，后续补充</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><img src="/posts/52196/image-20240118151922588.png" alt="image-20240118151922588"></p>
<h4 id="delete-add-commit"><a href="#delete-add-commit" class="headerlink" title="delete+add+commit"></a>delete+add+commit</h4><p>首先，资源管理器或者命令行 删除文件3，此时查看仓库状态，文件3被删除</p>
<p><img src="/posts/52196/image-20240118151237921.png" alt="image-20240118151237921"></p>
<p>再查看暂存区中的文件，发现暂存区中还是有文件3的</p>
<p><img src="/posts/52196/image-20240118151324997.png" alt="image-20240118151324997"></p>
<p>所以需要进行<code>add</code>，其实<code>add</code>也可以理解为添加的是操作，而不是文件本身，此时暂存区中也没有该文件了</p>
<p><img src="/posts/52196/image-20240118151421313.png" alt="image-20240118151421313"></p>
<p>最后再提交</p>
<h4 id="git-rm-commit"><a href="#git-rm-commit" class="headerlink" title="git rm+commit"></a>git rm+commit</h4><p><img src="/posts/52196/image-20240118151735086.png" alt="image-20240118151735086"></p>
<p>通过该目录删除文件，会直接把暂存区的文件也同步删除，当然工作区的自然也没了，最后只需要<code>commit</code>就行了</p>
<p>如果只是需要删除暂存区文件而保留工作区文件，那么需要附加参数<code>--cached</code></p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p><code>.gitignore</code>:忽略掉一些不应该加入到版本库管理的文件，包括</p>
<ul>
<li><p>系统或者软件自动生成的文件</p>
</li>
<li><p>编译产生的中间文件和结果文件</p>
<p>  一个文件是通过另外一个文件自动生成的，自动生成的文件没有必要放到版本库中，管理父文件即可，比如java编译生成的<code>.class</code>和<code>.o</code>文件</p>
</li>
<li><p>运行时生成的日志文件、缓存文件、临时文件</p>
</li>
<li><p>涉及身份、密码、口令、密钥等铭感信息文件</p>
</li>
</ul>
<p><img src="/posts/52196/image-20240118152337637.png" alt="image-20240118152337637"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>先创建一个<code>access1.log</code>模拟日志文件，默认是会被纳入版本库进行管理的，为了对比创建第二个日志文件<code>access2.log</code>。接着创建<code>.gitignore</code>文件，并添加<code>access1.log</code>的文件名，此时查看状态</p>
<p><img src="/posts/52196/image-20240118152754656.png" alt="image-20240118152754656"></p>
<p>此后进行<code>add</code>、<code>commit</code>都会忽略<code>access1.log</code>文件，但是<code>access2.log</code>会被添加，可以使用<code>*.log</code>的通配符忽略所有日志文件，再次查看状态。</p>
<p><img src="/posts/52196/image-20240118153004853.png" alt="image-20240118153004853"></p>
<p>但是，对于已经被添加到仓库中的日志文件，后续修改这个文件，git会提示我们发生了变化，用<code>git diff</code>也可以查看区别。</p>
<p><img src="/posts/52196/image-20240118153620667.png" alt="image-20240118153620667"></p>
<p>这是因为<code>.gitignore</code>只对未被添加到暂存区中的文件生效，此时可以先用<code>rm</code>删除暂存区中的文件，但是不能删除工作区中的文件，所以需要用<code>git rm --cached xxx.log</code>，这时就不会再对<code>access2.log</code>进行版本管理了</p>
<p><img src="/posts/52196/image-20240118153752508.png" alt="image-20240118153752508"></p>
<p>如果想要忽略目录（空目录默认不进行版本控制），可以添加”目录名+/“表示忽略该目录以下的所有内容</p>
<h4 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h4><p>从上到下逐行匹配，每一行表示一个忽略规则</p>
<p><img src="/posts/52196/image-20240118154620115.png" alt="image-20240118154620115"></p>
<p>具体实例</p>
<p><img src="/posts/52196/image-20240118154917166.png" alt="image-20240118154917166"></p>
<p>github上提供了各种常用语言的忽略文件的模板</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="SSH配置和远程仓库操作"><a href="#SSH配置和远程仓库操作" class="headerlink" title="SSH配置和远程仓库操作"></a>SSH配置和远程仓库操作</h3><p><img src="/posts/52196/image-20240119153955181.png" alt="image-20240119153955181"></p>
<h4 id="本地仓库↔远程仓库"><a href="#本地仓库↔远程仓库" class="headerlink" title="本地仓库↔远程仓库"></a>本地仓库↔远程仓库</h4><p><img src="/posts/52196/image-20240119153226800.png" alt="image-20240119153226800"></p>
<p>两个仓库互相独立，互不干扰</p>
<p>本地仓库的修改不会直接影响远程仓库，远程仓库的修改也不会直接影响本地仓库，因此需要一套机制进行同步</p>
<p>就是<code>git pull</code>（拉取）和<code>git push</code>（推送）</p>
<h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p><img src="/posts/52196/image-20240119145321918.png" alt="image-20240119145321918"></p>
<h4 id="远程仓库链接到本地"><a href="#远程仓库链接到本地" class="headerlink" title="远程仓库链接到本地"></a>远程仓库链接到本地</h4><ol>
<li><p>本地没有仓库，则先在本地创建仓库，然后<code>push</code>到远程仓库建立链接</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;# learn-git&quot; &gt;&gt; README.md</span><br><span class="line">git init # 初始化本地仓库</span><br><span class="line">git add README.md # 添加README.md文件</span><br><span class="line">git commit -m &quot;first commit&quot; # 提交</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/xzp314/learn-git.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地已有仓库，将本地仓库和远程仓库链接起来</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/xzp314/learn-git.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入其他仓库</p>
</li>
</ol>
<p>推送的两种方式</p>
<ol>
<li><p><code>HTTPS</code></p>
<p> 需要验证用户名和密码（停止使用，改为使用<code>token</code>或者<code>web auth</code>）</p>
</li>
<li><p><code>SSH</code></p>
<p> 不需要验证用户名和密码，但是需要在<code>Github</code>添加每台电脑上生成的SSH公钥，更加安全</p>
</li>
</ol>
<h4 id="SSH密钥配置"><a href="#SSH密钥配置" class="headerlink" title="SSH密钥配置"></a>SSH密钥配置</h4><ol>
<li><p>右键<code>git bash here</code>打开<code>git bash</code></p>
</li>
<li><p><code>cd ~/.ssh</code>查看是否已经有了<code>ssh</code>密钥</p>
<p> 存在则备份然后删除 或者 修改文件名 避免覆盖</p>
<p> <img src="/posts/52196/image-20240119151007599.png" alt="image-20240119151007599"></p>
</li>
<li><p>配置用户名和邮箱</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;email&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看用户名和邮箱是否配置正确</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<p> <img src="/posts/52196/image-20240119151326757.png" alt="image-20240119151326757"></p>
</li>
<li><p>生成密钥</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>
<p> <code>ssh-key generate</code></p>
<p> <code>-t</code>指定协议为<code>rsa</code></p>
</li>
<li><p>第一次一般需要三次回车，最后会创建<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件</p>
<p> <img src="/posts/52196/image-20240119151139875.png" alt="image-20240119151139875"></p>
</li>
<li><p>添加密钥到<code>Github</code>远程仓库</p>
<p> <img src="/posts/52196/image-20240119151514038.png" alt="image-20240119151514038"></p>
<p> <img src="/posts/52196/image-20240119151537004.png" alt="image-20240119151537004"></p>
<p> <img src="/posts/52196/image-20240119151602726.png" alt="image-20240119151602726"></p>
</li>
<li><p>如果是新增了一个密钥，则需要指定使用哪个ssh，创建一个config文件，并编辑</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa2</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证是否成功添加<code>ssh -T git@github.com</code></p>
<p> <img src="/posts/52196/image-20240119152118993.png" alt="image-20240119152118993"></p>
</li>
</ol>
<h4 id="远程仓库克隆"><a href="#远程仓库克隆" class="headerlink" title="远程仓库克隆"></a>远程仓库克隆</h4><ol>
<li>把远程仓库<code>clone</code>到本地</li>
</ol>
<p><img src="/posts/52196/image-20240119152323535.png" alt="image-20240119152323535"></p>
<ol>
<li><p>本地创建<code>README.md</code>文件，添加并提交，但是只是存储在本地仓库</p>
<p> <img src="/posts/52196/image-20240119152736045.png" alt="image-20240119152736045"></p>
</li>
<li><p>推送到远程仓库</p>
<p> <img src="/posts/52196/image-20240119153353617.png" alt="image-20240119153353617"></p>
<ul>
<li><code>git push</code> 用于推送更改，但需要手动指定远程仓库和分支</li>
<li><code>git push -u origin main</code> 在推送的同时，通过 <code>-u</code> 选项建立本地分支与远程分支的关联，使得后续的推送操作可以更方便地进行</li>
</ul>
</li>
</ol>
<h4 id="推送和拉取"><a href="#推送和拉取" class="headerlink" title="推送和拉取"></a>推送和拉取</h4><p><img src="/posts/52196/image-20240119154858372.png" alt="image-20240119154858372"></p>
<ol>
<li><p>创建一个远程仓库<code>first-repo</code></p>
</li>
<li><p>创建一个本地仓库<code>myrepo</code>，添加3个文件，并提交</p>
</li>
<li><p>添加远程仓库，查看当前仓库对应的远程仓库的别名和地址</p>
<p> <img src="/posts/52196/image-20240119155045248.png" alt="image-20240119155045248"></p>
</li>
<li><p>指定分支名称，因为默认就是<code>main</code>，所以可以省略</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -M main</span><br></pre></td></tr></table></figure>
</li>
<li><p>把本地的<code>master</code>分支和远程的<code>main</code>分支关联起来</p>
<p> <img src="/posts/52196/image-20240119162634353.png" alt="image-20240119162634353"></p>
<p> <code>-u</code>是<code>upstream</code> 向上传输数据流</p>
<p> 把本地仓库和远程别名为<code>origin</code>的仓库关联起来</p>
<p> 把本地<code>master</code>分支推送到远程的<code>main</code>分支，如果名称相同可以省略只写一个</p>
</li>
<li><p><code>Github</code>页面直接修改一些内容（一般是别的用户本地修改后推送到远程仓库）</p>
</li>
<li><p>本地拉取远程仓库的内容，再进行合并，合并是pull命令自动执行的，所以可能会发生冲突</p>
<p> <img src="/posts/52196/image-20240119163550047.png" alt="image-20240119163550047"></p>
</li>
</ol>
<p>远程获取仓库内容，还有一个<code>fetch</code>命令，该命令只是获取仓库的修改，但是并不会自动进行合并</p>
<h2 id="分支-1"><a href="#分支-1" class="headerlink" title="分支"></a>分支</h2><p><img src="/posts/52196/image-20240122180254468.png" alt="image-20240122180254468"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>分支（Branch），可以视作代码库中的不同版本，可以独立存在，有自己的提交记录</p>
<p>分支适用于团队协作和开发管理，比如说team1负责开发功能1，team2负责开发功能2，team3负责修复遗留bug，如果都在一个分支上搞，即便修改的是不同的文件，不会冲突，提交记录也会比较混乱，不利于开发。并且，主分支处于不稳定的状态，存在部分功能未开发完成、部分bug未修复等问题。引入分治，主分支随时处于稳定的版本，开发团队可以基于该版本进行功能开发，完善后再合并回来。</p>
<p><img src="/posts/52196/image-20240122151431736.png" alt="image-20240122151431736"></p>
<p><strong>示例</strong></p>
<p><img src="/posts/52196/image-20240122152909913.png" alt="image-20240122152909913"></p>
<ol>
<li>创建 添加 提交三次文件，<code>git branch</code>查看所有分支和当前分支</li>
</ol>
<p><img src="/posts/52196/image-20240122153014756.png" alt="image-20240122153014756"></p>
<ol>
<li>创建新的分支<code>git branch branch_name</code>，但是没有切换到该分支</li>
</ol>
<p><img src="/posts/52196/image-20240122153354916.png" alt="image-20240122153354916"><img src="/posts/52196/image-20240122153445929.png" alt="image-20240122153445929"></p>
<ol>
<li>切换到该分支<code>git checkout branch_name</code>，该分支会继承<code>main/master</code>分支的以往提交记录</li>
</ol>
<p><img src="/posts/52196/image-20240122153539992.png" alt="image-20240122153539992"></p>
<blockquote>
<p><code>git checkout</code>还有一个功能是恢复文件到之前的状态，语法是一样的，所以如果文件名称和分支名称相同，就会出现歧义，默认是切换分支</p>
<p><code>git switch</code>是专门用来切换分支的</p>
<p><img src="/posts/52196/image-20240122154112113.png" alt="image-20240122154112113"></p>
</blockquote>
<ol>
<li>创建 添加 提交新的文件，但是切换回<code>master</code>分支，其实是没有这几个文件的</li>
</ol>
<p><img src="/posts/52196/image-20240122154607960.png" alt="image-20240122154607960"></p>
<p><code>master</code>：<img src="/posts/52196/image-20240122155257559.png" alt="image-20240122155257559"></p>
<p><code>dev</code>：<img src="/posts/52196/image-20240122155317600.png" alt="image-20240122155317600"></p>
<ol>
<li><p>切换回<code>master</code>分支进行修改和提交</p>
<p> <img src="/posts/52196/image-20240122155800813.png" alt="image-20240122155800813"></p>
</li>
<li><p><code>dev</code>分支的任务完成，需要合并回主分支：<code>current_branch:git merge branch_name</code>就是将<code>branch_name</code>分支合并到<code>current_branch</code>（通常要求是主分支）</p>
</li>
</ol>
<p><img src="/posts/52196/image-20240122160041709.png" alt="image-20240122160041709"></p>
<ol>
<li><code>git log --graph --oneline --decorate --all</code>查看分支图</li>
</ol>
<p><img src="/posts/52196/image-20240122160156780.png" alt="image-20240122160156780"></p>
<ol>
<li><p>分支被合并不会被删除，要删除则使用<code>git branch -d branch_name</code>命令</p>
<p> <code>-d</code>表示删除已经完成合并的分支，如果没有完成合并则删除不了，如需要强制删除则使用<code>-D</code></p>
</li>
</ol>
<p><img src="/posts/52196/image-20240122160419486.png" alt="image-20240122160419486"></p>
<h3 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h3><p><img src="/posts/52196/image-20240122182355843.png" alt="image-20240122182355843"></p>
<p><strong>何为冲突？</strong></p>
<p>两个分支在合并时，如果出现修改的内容重合，则会引发冲突，比如两个分支修改了同一个文件的同一行代码。需要我们手动解决冲突。</p>
<p><strong>示例</strong></p>
<ol>
<li>新建分支<code>feat</code>，并切换到该分支，修改<code>master1.txt</code>的内容，并提交</li>
</ol>
<p><img src="/posts/52196/image-20240122180936107.png" alt="image-20240122180936107"><img src="/posts/52196/image-20240122181237321.png" alt="image-20240122181237321"></p>
<ol>
<li>切换回<code>master</code>分支，同样修改<code>master1.txt</code>的内容，并提交，此时<code>master1.txt</code>的原始内容是不包括<code>feat</code>分支所修改的内容的</li>
</ol>
<p><img src="/posts/52196/image-20240122181102442.png" alt="image-20240122181102442"><img src="/posts/52196/image-20240122181304941.png" alt="image-20240122181304941"></p>
<ol>
<li>现在在<code>master</code>分支上合并<code>feat</code>分支，提示自动合并失败，冲突文件是<code>master1.txt</code></li>
</ol>
<p><img src="/posts/52196/image-20240122181356192.png" alt="image-20240122181356192"></p>
<ol>
<li>使用git status命令查看冲突列表，git diff查看冲突具体内容，这里不显示具体内容是因为windows系统上的txt文件的编码是UTF-8</li>
</ol>
<p><img src="/posts/52196/image-20240122181519991.png" alt="image-20240122181519991"><img src="/posts/52196/image-20240122181652318.png" alt="image-20240122181652318"></p>
<ol>
<li><p>手工编辑该文件，留下需要的内容，再添加暂存，最后提交</p>
<p> <img src="/posts/52196/image-20240122182247393.png" alt="image-20240122182247393"><img src="/posts/52196/image-20240122182301460.png" alt="image-20240122182301460"></p>
</li>
<li><p>如果想要终止此次合并，也可以使用<code>get merge --abort</code></p>
</li>
</ol>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>中文释义是变基，命令通常是<code>git rebase branch_name</code>，意思是将当前分支变基到<code>branch_name</code>分支上</p>
<p><img src="/posts/52196/image-20240122160041709.png" alt="image-20240122160041709"></p>
<p><code>merge</code>通常是要求在主分支（<code>master</code>或者<code>main</code>）上执行的，其实就是将别的分支合并到主分支，而<code>rebase</code>没有这种限制</p>
<p><img src="/posts/52196/image-20240122183252961.png" alt="image-20240122183252961"></p>
<p>执行<code>rebase</code>之后的结果是一条直线，这和<code>merge</code>也是不一样的</p>
<p><img src="/posts/52196/image-20240122183008764.png" alt="image-20240122183008764"></p>
<p>实际上，Git中的每个分支都存在一个指针[<code>HEAD</code>]，上述两种不同操作其实就是指针的指向变更不一样</p>
<p><img src="/posts/52196/image-20240122183146636.png" alt="image-20240122183146636"></p>
<p><code>Git</code>会找到这两个分支的最近公共祖先，也就是<code>main3</code>，然后将<code>main3</code>之后当前分支的所有提交移动到目标分支</p>
<p><strong>示例</strong></p>
<p><img src="/posts/52196/image-20240122183453523.png" alt="image-20240122183453523"></p>
<ol>
<li><p>将<code>feat</code>分支删除<code>git branch -d feat</code></p>
</li>
<li><p>将<code>dev</code>分支恢复出来，后面是<code>dev-2</code>那次提交的提交ID</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b dev 7c7de8c45434181d212fee657800ba98549dfaac</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/posts/52196/image-20240122183741202.png" alt="image-20240122183741202"></p>
<p><img src="/posts/52196/image-20240122184133903.png" alt="image-20240122184133903"></p>
<ol>
<li><p>再切换到<code>master</code>分支，并回退到<code>main-5</code>这次提交</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 91514ce76e2a19439e40b612aa4c6054fb606056</span><br></pre></td></tr></table></figure>
<p> <img src="/posts/52196/image-20240122184216731.png" alt="image-20240122184216731"></p>
</li>
<li><p>复制一份仓库<code>branch_demo2</code>，原仓库执行<code>rebase</code>到<code>master</code>，新仓库执行<code>rebase</code>到<code>dev</code></p>
</li>
</ol>
<p>原仓库：<img src="/posts/52196/image-20240122184420920.png" alt="image-20240122184420920">把<code>main-4</code>之后的<code>dev-1</code>和<code>dev-2</code>嫁接到<code>main-5</code>之后</p>
<p>新仓库：<img src="/posts/52196/image-20240122184546262.png" alt="image-20240122184546262">把<code>main-4</code>之后的<code>main-5</code>嫁接到<code>dev-2</code>之后</p>
<p><strong><code>Rebase</code> vs <code>Merge</code></strong></p>
<p><code>Merge</code>的优点在于不会破坏原分支的提交历史，方便回溯和查看，但是会产生额外的提交节点，分支图比较复杂。</p>
<p><code>Rebase</code>的优点在于不会新增额外的提交记录，形成线性历史，比较直观和干净，但是会改变提交历史（时间顺序会被破坏），避免在共享分支使用，容易造成困扰。</p>
<h2 id="工作流模型"><a href="#工作流模型" class="headerlink" title="工作流模型"></a>工作流模型</h2><h3 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h3><p><img src="/posts/52196/image-20240122190720116.png" alt="image-20240122190720116"></p>
<p>分支被划分为5种类型：</p>
<ol>
<li><p><strong>main[主要分支]</strong></p>
<p> 主线分支[长期存在]，项目核心分支，包含项目最新的稳定版本的代码，需要保证该分支的代码随时都是可发布的，能够部署的</p>
<p> 该分支的代码不允许直接修改，只能通过合并别的分支实现版本迭代，每次合并分支都建议生成一个新的版本号，便于追踪和回溯，用<code>git tag</code>命令进行标记，版本号规则：</p>
<ol>
<li>主版本（Major Version）：主要的功能变化或重大更新</li>
<li>次版本（Minor Version）：一些新的功能、改进和更新，通常不会影响现有功能</li>
<li>修订版本（Patch Version）：一些小的bug修复，安全漏洞补丁等。通常不会更改现有功能和接口。</li>
</ol>
</li>
<li><p><strong>hotfix[辅助分支]</strong></p>
<p> 问题修复分支[短期存在]，包含项目某个问题修复的源码，用于解决线上问题，所以通常是由<code>main</code>分支分离出来的，修复完成后合并回<code>main</code>分支或者<code>develop</code>分支，并删除该分支，一般命名规则为<code>hotfix-#issueid-desc</code>，通常也会更新小版本号，即修订版本</p>
</li>
<li><p><strong>release[辅助分支]</strong></p>
<p> 预发布分支[短期存在]，包含项目最新预发布版本的代码，用于发布前的测试和验证，通常是从<code>develop</code>分支中分离出来的，当预发布分支的代码稳定后会合并到<code>main</code>分支和<code>develop</code>分支中，并将该预发布分支删除</p>
</li>
<li><p><strong>develop[主要分支]</strong></p>
<p> 开发分支[长期存在]，从<code>main</code>分支分离出来的，包含了项目最新开发版本的代码，用于开发和测试</p>
</li>
<li><p><strong>feature[辅助分支]</strong></p>
<p> 功能分支[短期存在]，包含项目某个新功能的代码，通常是从<code>develop</code>分支中分离出来的。功能开发完成后，合并回<code>develop</code>分支</p>
</li>
</ol>
<h3 id="GithubFlow"><a href="#GithubFlow" class="headerlink" title="GithubFlow"></a>GithubFlow</h3><p><code>GitFlow</code>模型很完善，各个方面都兼备，但是也带来了一定的复杂性，所以就引入<code>GithubFlow</code>，通常包括一个长期存在的主分支[禁止直接提交]和其他功能开发的分支</p>
<p><img src="/posts/52196/image-20240122190840601.png" alt="image-20240122190840601"></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p><strong>分支命令</strong></p>
<p>使用带有意义的描述性名称来命名分支</p>
<ol>
<li>版本发布应该根据版本号命名：v1.0.0</li>
<li>功能性分支应该根据其功能和任务命名：feature-login-page</li>
<li>修补补丁和错误应该根据其问题编号命名：hotfix-#issueid-desc</li>
</ol>
<p><strong>分支管理</strong></p>
<ol>
<li>定期合并已经成功验证的分支，并及时删除已经合并的分支</li>
<li>保持合适的分支数量</li>
<li>确保及时将功能性分支合并回主分支</li>
<li>为分支设置合适的管理权限</li>
</ol>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h4 id="Gitee和GitLab"><a href="#Gitee和GitLab" class="headerlink" title="Gitee和GitLab"></a>Gitee和GitLab</h4><p><a href="https://www.bilibili.com/video/BV1HM411377j?p=13">13.Gitee的使用和GitLab本地化部署_哔哩哔哩_bilibili</a></p>
<h4 id="在VSCode中使用Git"><a href="#在VSCode中使用Git" class="headerlink" title="在VSCode中使用Git"></a>在VSCode中使用Git</h4><p><a href="https://www.bilibili.com/video/BV1HM411377j?p=15">15.在VSCode中使用Git_哔哩哔哩_bilibili</a></p>
<h4 id="小窍门"><a href="#小窍门" class="headerlink" title="小窍门"></a>小窍门</h4><p><code>alias graph=git log --oneline --graph --decorate --all</code>将这么长的命令命名为<code>graph</code>（windows不支持）</p>
<p>建议使用git配置文件来设置git命令的别名，便于迁移</p>
<h2 id="unable-to-access问题解决"><a href="#unable-to-access问题解决" class="headerlink" title="unable to access问题解决"></a>unable to access问题解决</h2><p><a href="https://www.douban.com/note/821097747/?_i=5652571QMCZcLA">https://www.douban.com/note/821097747/?_i=5652571QMCZcLA</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/620877553">【Github】fatal: unable to access ‘https://github.com/<strong>/</strong>.git’: Proxy CONNECT aborted—解决办法 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-AOP</title>
    <url>/posts/17849.html</url>
    <content><![CDATA[<h3 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于记录日志、性能监控这些几乎所有模块都要使用的功能，我们可以划出一个横切面，一方面可以重用这些功能模块，另一方面也可以把这些和业务逻辑无关的功能分离出去</p>
<p><img src="/posts/17849/image-20230827151256984.png" alt="image-20230827151256984"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现的核心是动态代理，如果要代理的对象实现了某个接口，就可以使用JDK动态代理，否则会使用CGLIB来实现代理</p>
<p><img src="/posts/17849/image-20230827151401363.png" alt="image-20230827151401363"></p>
<h4 id="环绕方式"><a href="#环绕方式" class="headerlink" title="环绕方式"></a>环绕方式</h4><p>有点类似word里面，插入图片，文字相对于图片的环绕方式</p>
<ol>
<li>前置@Before：方法调用之前触发</li>
<li>后置@After：方法调用之后触发，不管是抛出异常还是正常返回</li>
<li>返回@AfterReturning：方法正常返回结果之后触发</li>
<li>异常@AfterThrowing：方法运行中抛出 / 触发异常后触发</li>
<li>环绕@Around：执行前、退出后都触发</li>
</ol>
<p><img src="/posts/17849/image-20230824153622011.png" alt="image-20230824153622011"></p>
<p>可以使用@order注解标记切面执行顺序，值越小优先级越高</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><img src="/posts/17849/image-20230827152125297.png" alt="image-20230827152125297"></p>
<h3 id="JDK动态代理和CGLIB代理"><a href="#JDK动态代理和CGLIB代理" class="headerlink" title="JDK动态代理和CGLIB代理"></a>JDK动态代理和CGLIB代理</h3><p>JDK动态代理由Proxy实现，Proxy持有一个调用处理器的对象实例，在使用时，我们只需要</p>
<ol>
<li><p>定义被代理的接口，实现类可有可无</p>
</li>
<li><p>创建实现InvocationHandler接口的调用处理器类，重写invoke方法，定义切面逻辑，可以通过method.invoke方法调用原始对象的方法</p>
</li>
<li><p>调用Proxy.newProxyInstance传入类加载器、存储被代理接口的数组、调用处理器来实例化接口的动态代理对象</p>
</li>
</ol>
<p>这样调用接口的任何方法都会转为调用动态代理类的invoke方法</p>
<p>运行时会动态生成一个继承了Proxy，同时实现了被代理接口的动态类，叫$Proxy，这个类会重写接口的方法，在方法内部会执行所持有的的调用处理器类的invoke方法，这也就是为什么接口方法会被invoke拦截的底层原理</p>
<p><img src="/posts/17849/image-20230827171205438.png" alt="image-20230827171205438"></p>
<p>CGLIB突破JDK动态代理只能代理接口的缺陷，底层实现原理是基于字节码，为代理类创建一个子类，然后重写父类的所有方法实现切面逻辑</p>
<p><img src="/posts/17849/image-20230910161556429.png" alt="image-20230910161556429"></p>
<blockquote>
<p>Spring默认在目标类实现接口时是通过JDK代理实现的，只有非接口的是通过CGLIB代理实现的。当然也可以通过设置proxy-target-class为true来优先使用CGLIB代理</p>
</blockquote>
<h3 id="Spring-AOP和AspectJ-AOP"><a href="#Spring-AOP和AspectJ-AOP" class="headerlink" title="Spring AOP和AspectJ AOP"></a>Spring AOP和AspectJ AOP</h3><p>Spring AOP基于动态代理实现，如果实现了接口那就用JDK动态代理，否则使用CGLIB，属于运行时的功能增强</p>
<p>AspectJ AOP属于编译时的功能增强，通过修改代码的class文件实现的静态切面，性能比Spring AOP要好，是一种更强的AOP框架，可以实现Spring AOP做不到的东西，比如切入点不仅仅支持方法</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>IM项目-服务端如何正确调用合适的处理器</title>
    <url>/posts/62638.html</url>
    <content><![CDATA[<h3 id="Handler体系"><a href="#Handler体系" class="headerlink" title="Handler体系"></a>Handler体系</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/posts/62638/image-20230903150049595.png" alt="image-20230903150049595"></p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>基类处理器用泛型定义入参类型，子类声明为具体的类型——策略模式</p>
<p><code>pipeline</code>中通过<code>addLast()</code>方法添加处理器构成处理器链，然后利用<code>fireChannelRead</code>推进处理器的执行——责任链模式</p>
<h4 id="重要源码"><a href="#重要源码" class="headerlink" title="重要源码"></a>重要源码</h4><p><strong>基类处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseHandler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">protected</span> UserService userService; <span class="comment">// api提供的用户服务实例对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 处理器调用的入口方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, T msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        channelRead(ctx.channel(), msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 泛型 子类来具体实现处理器需要接收的参数类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(Channel channel, T msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>信息处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgHandler</span> <span class="keyword">extends</span> <span class="title class_">MyBizHandler</span>&lt;MsgRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MsgHandler</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(userService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定入参类型为MsgRequest</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(Channel channel, MsgRequest msg)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;消息信息处理：&#123;&#125;&quot;</span>, JSON.toJSONString(msg));</span><br><span class="line">        <span class="comment">// 异步写库</span></span><br><span class="line">        userService.asyncAppendChatRecord(<span class="keyword">new</span> <span class="title class_">ChatRecordInfo</span>(msg.getUserId(), msg.getFriendId(), msg.getMsgText(), msg.getMsgType(), msg.getMsgDate()));</span><br><span class="line">        <span class="comment">// 添加对话框[如果对方没有你的对话框则添加]</span></span><br><span class="line">        userService.addTalkBoxInfo(msg.getFriendId(), msg.getUserId(), Constants.TalkType.Friend.getCode());</span><br><span class="line">        <span class="comment">// 获取好友通信管道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">friendChannel</span> <span class="operator">=</span> SocketChannelUtil.getChannel(msg.getFriendId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == friendChannel) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;用户id：&#123;&#125;未登录！&quot;</span>, msg.getFriendId());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        friendChannel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">MsgResponse</span>(msg.getUserId(), msg.getMsgText(), msg.getMsgType(), msg.getMsgDate()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>channel初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseChannelInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseChannelInitializer</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//对象传输处理[解码]</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ObjDecoder</span>());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的处理器</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DelTalkHandler</span>(userService));</span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoginHandler</span>(userService));</span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MsgHandler</span>(userService));</span><br><span class="line">        <span class="comment">//对象传输处理[编码]</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ObjEncoder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编码解码器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjEncoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToByteEncoder</span>&lt;Packet&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Packet in, ByteBuf out)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = SerializationUtil.serialize(in);</span><br><span class="line">        out.writeInt(data.length + <span class="number">1</span>);</span><br><span class="line">        out.writeByte(in.getCommand()); <span class="comment">//添加指令</span></span><br><span class="line">        out.writeBytes(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in.markReaderIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dataLength</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            in.resetReaderIndex();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">command</span> <span class="operator">=</span> in.readByte();  <span class="comment">//读取指令</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[dataLength - <span class="number">1</span>]; <span class="comment">//指令占了一位，剔除掉</span></span><br><span class="line">        in.readBytes(data);</span><br><span class="line">        out.add(SerializationUtil.deserialize(data, Packet.get(command)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><ol>
<li><p><code>ByteToMessageDecoder.channelRead()</code>：最后会调用自定义解码器的<code>decode()</code>方法</p>
</li>
<li><p><code>ObjDecoder.decode()</code>：解码，读取数据长度，读取指令，将对象进行反序列化，对象就有类型了</p>
<ol>
<li>返回<code>ByteToMessageDecoder.channelRead():fireChannelRead()</code>：推进责任链的执行，会执行下一个处理器<code>SimpleChannelInboundHandler</code>的<code>channelRead()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numElements; ++i) &#123;</span><br><span class="line">        ctx.fireChannelRead(msgs.getUnsafe(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SimpleChannelInboundHandler</code>.<code>channelRead()</code>通过<code>acceptInboundMessage</code>判断是否需要执行</p>
</li>
<li><p>调用<code>TypeParameterMatcher.match()→ReflectiveMatcher.match()</code>方法判断是否需要执行，所以是根据msg的类型进行判断的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.type.isInstance(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不需要执行，则继续调用<code>fireChannelRead()</code>推进责任链的执行</p>
</li>
<li><p>需要执行，则进入处理器调用的入口方法</p>
</li>
</ul>
</li>
<li><p><code>channelRead0()</code>：处理器调用的入口方法</p>
</li>
<li><p><code>channelRead()</code>：处理器调用的具体方法，包含业务逻辑</p>
</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>实现底层原理就在于<code>TypeParameterMatcher</code>，这是每个<code>SimpleChannelInboundHandler</code>的成员变量，叫<code>matcher</code>，在matcher里存储了处理器需要进行处理的协议包类型，比如<code>class cn.edu.seu.chat.protocol.friend.AddFriendRequest</code></p>
<p>只需要比较传进来的参数类型和自己拥有的协议包类型是否匹配即可判断当前处理器是否需要处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.type.isInstance(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目</category>
        <category>即时通讯系统</category>
      </categories>
      <tags>
        <tag>项目开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>IM项目-MVC vs DDD</title>
    <url>/posts/16771.html</url>
    <content><![CDATA[<h3 id="面向对象实现业务逻辑"><a href="#面向对象实现业务逻辑" class="headerlink" title="面向对象实现业务逻辑"></a>面向对象实现业务逻辑</h3><p>如果是一个小项目，可以把定义属性、创建方法、调用展示等步骤全部写在一个类里面</p>
<p><img src="/posts/16771/image-20230901140450237.png" alt="image-20230901140450237"></p>
<p>但是如果项目体量比较大，就可能需要各种对象类、库表类、方法类，全部写在一个类里面，非常臃肿，项目难以进行拓展和维护</p>
<p>所以，就需要进行解耦，把对象、方法、接口各种组件分离出来，存放到不同的模块中，不同模块的职责是什么、如何组织这些模块就是架构需要完成的</p>
<p><img src="/posts/16771/image-20230901140918095.png" alt="image-20230901140918095"></p>
<p><strong>常用相关对象概念</strong></p>
<ul>
<li><p>PO：持久化对象<code>User</code>，一般就是表示数据库的一条记录，用PO可以组装出VO和DTO</p>
</li>
<li><p>VO：值对象<code>UserInfo</code>，可以基于某个值进行区分的对象，通常用于给前端进行数据传输，VO一般是从PO中提取的部分属性，或者不同PO的属性组合</p>
</li>
<li><p>DAO：数据访问对象<code>IUserDao</code>，一般表现为接口，接口的方法是与数据库交互的真正方法，可以和mapper.xml文件进行关联，实现POJO到PO的转换</p>
</li>
<li><p>DTO：数据传输对象<code>UserDto</code>，远程传输数据对象</p>
</li>
</ul>
<ul>
<li><p>POJO：简单的Java对象，没有任何限制、继承、实现接口的Java对象</p>
</li>
<li><p>BO：业务对象，用于表示某个业务逻辑的实体或者模型</p>
</li>
</ul>
<h3 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h3><h4 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h4><p><img src="/posts/16771/image-20230901142324005.png" alt="image-20230901142324005"></p>
<p>基于上述分层架构对项目的不同组件进行划分、整理后，每个层次的职责就比较清晰，方便后续的维护和迭代，这也是MVC架构的目标</p>
<h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><p><img src="/posts/16771/image-20230901143147847.png" alt="image-20230901143147847"></p>
<h4 id="实际测试项目"><a href="#实际测试项目" class="headerlink" title="实际测试项目"></a>实际测试项目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── Application.java 启动程序的SpringBoot应用</span><br><span class="line">├── common 通用类</span><br><span class="line">│   ├── Constants.java 通用常量 比如状态码</span><br><span class="line">│   └── Result.java 操作结果描述对象 状态码,描述信息 </span><br><span class="line">├── controller 对外提供服务使用接口</span><br><span class="line">│   └── UserController.java 用户相关的服务接口 比如查询用户信息</span><br><span class="line">├── dao 数据库操作层</span><br><span class="line">│   └── IUserDao.java 数据库操作接口 UserDao @Mapper</span><br><span class="line">├── domain 对象定义层</span><br><span class="line">│   ├── po 持久化对象</span><br><span class="line">│   │   └── User.java 用户的持久化对象 和数据库用户记录一一对应 用户信息包括用户ID、名称、昵称、头像、密码等</span><br><span class="line">│   ├── req 查询请求对象 DTO</span><br><span class="line">│   │   └── UserReq.java 用户查询请求对象 记录查询字段 比如uid</span><br><span class="line">│   ├── res 查询返回对象 DTO</span><br><span class="line">│   │   └── UserRes.java 用户查询返回对象 记录查询得到的结果 操作结果描述对象 存储UserVO的列表 属于DTO</span><br><span class="line">│   └── vo 值对象</span><br><span class="line">│       └── UserInfo.java 值对象 往前端应用界面传输的对象 比如用户id 用户名称 创建时间</span><br><span class="line">└── service 服务层</span><br><span class="line">   ├── IUserService.java 服务接口</span><br><span class="line">   └── impl</span><br><span class="line">       └── UserServiceImpl.java 服务实现 查询用户列表 封装成UserInfo并返回</span><br></pre></td></tr></table></figure>
<h3 id="DDD架构"><a href="#DDD架构" class="headerlink" title="DDD架构"></a>DDD架构</h3><p>实际上，前面提到的定义属性、创建方法、调用展示三步走的模式只适用于非常简单的项目开发，而对于DDD架构，可以抽象为<code>触发→函数→连接</code>三个过程</p>
<p><img src="/posts/16771/image-20230901144044139.png" alt="image-20230901144044139"></p>
<p>系统的调用方    式不仅仅是HTTP请求，还有远程过程调用、TASK任务执行等方式，统一归为触发，触发调用函数来完成业务逻辑，函数通过连接，调用其他接口提供的功能、数据库、缓存等来辅助业务逻辑的实现</p>
<h4 id="架构分层-amp-调用流程"><a href="#架构分层-amp-调用流程" class="headerlink" title="架构分层&amp;调用流程"></a>架构分层&amp;调用流程</h4><p><strong><img src="/posts/16771/image-20230902145010753.png" alt="image-20230902145010753"></strong></p>
<p>需要根据使用上述DDD架构分层模式所设计实现的项目进行内容补充</p>
<h4 id="实际测试项目-1"><a href="#实际测试项目-1" class="headerlink" title="实际测试项目"></a>实际测试项目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">agreement</span><br><span class="line">	codec</span><br><span class="line">		ObjDecoder: 对象传输的反序列化功能</span><br><span class="line">			1. 读取Int型的数据长度</span><br><span class="line">			2. 读取一个字节的指令类型</span><br><span class="line">			3. 读取实际承载数据</span><br><span class="line">			4. 借助SerializationUtil 基于指令类型所对应的类的schema进行反序列化</span><br><span class="line">        ObjEncoder: 对象传输的序列化功能</span><br><span class="line">        	1. 定义字节数组 存储借助SerializationUtil实现序列化的对象的二进制字节流数据</span><br><span class="line">        	2. 写入Int型的数据长度 数组长度+1</span><br><span class="line">        	3. 写入指令类型</span><br><span class="line">        	4. 写入实际数据内容</span><br><span class="line">	protocol</span><br><span class="line">		定义各自协议包 包括协议包的基础类型的数据和Dto类型的数据 比如登录响应包有登录反馈的基础类型疏忽和好友列表中好友的DTO类型数据</span><br><span class="line">	util</span><br><span class="line">		SerializationUtil: 基于protostuff实现类对象的序列化和反序列化 实现的关键在于类的schema</span><br><span class="line">server</span><br><span class="line">	api</span><br><span class="line">		InetService: 服务端控制台服务接口定义</span><br><span class="line">		UserService: 客户端请求服务接口定义 没有任何业务逻辑</span><br><span class="line">	domain</span><br><span class="line">		inet</span><br><span class="line">			model</span><br><span class="line">			repository</span><br><span class="line">			service</span><br><span class="line">		user</span><br><span class="line">			model</span><br><span class="line">				聊天记录Info VO[发送方ID 接收方ID 信息内容 信息类型 信息时间 对话类型]</span><br><span class="line">				群组Info	VO[群组ID 群组昵称 群组头像]</span><br><span class="line">				搜索好友Info VO[好友ID 好友昵称 好友头像 好友添加状态]</span><br><span class="line">				会话框Info	VO[会话类型 对方ID 对方名称 对方头像]</span><br><span class="line">				用户Info	VO[用户ID 用户昵称 用户头像]</span><br><span class="line">				用户好友Info VO[好友ID 好友昵称 好友头像]</span><br><span class="line">			repository</span><br><span class="line">				定义仓储服务 也就是数据库交互操作</span><br><span class="line">			service</span><br><span class="line">				使用仓储服务 实现操作层面的业务逻辑 比如聊天信息的异步入库</span><br><span class="line">    infrastructure</span><br><span class="line">    	dao</span><br><span class="line">    		通过mapper.xml实现数据库操作</span><br><span class="line">    	po</span><br><span class="line">    		持久化对象</span><br><span class="line">    	repository</span><br><span class="line">    		仓储层的基础实现 实现数据库交互层面的业务逻辑 数据对象转换  将查询到的PO转换为VO</span><br><span class="line">	socket</span><br><span class="line">		handler: 实现各种处理器 实现服务层面的业务逻辑 需要封装哪些用于登录的初始化数据 还涉及数据对象的转换 将VO转换为DTO</span><br><span class="line">		MyChannelInitializer: 初始化通道的编码解码器和各自处理器</span><br><span class="line">		NettyServer: 服务器启动</span><br></pre></td></tr></table></figure>
<h3 id="MVC→DDD"><a href="#MVC→DDD" class="headerlink" title="MVC→DDD"></a>MVC→DDD</h3><p><strong>为什么DDD相较于MVC更有利于后期拓展和维护呢？</strong></p>
<p><img src="/posts/16771/image-20230902155943815.png" alt="image-20230902155943815"></p>
<p>MVC架构实际上是一种分层结构，简单来讲就是承担相同职责的类聚合在一起，比如对外暴露提供服务接口的类放到controller层，依据库表定义对象属性的类放到domain层，实现业务逻辑的类放到服务层，这种模式是一种贫血模型的体现：在domain层的PO VO这些对象中只有属性没有行为，而具体的业务行为又是在service中定义，service想要实现业务逻辑，就得使用PO VO的属性，更像是面向过程编程。</p>
<p>所带来的优势自然就是前期可以很快进入业务逻辑的开发阶段，但是随着不断拓展，就可能导致不同service使用统一定义的domain层中的对象，也就是交叉引用的问题。随着不断进行功能拓展，这些PO VO的设计目的不明确，代码可读性差。</p>
<p>而在DDD架构中呢，就基于业务逻辑抽象出领域，在领域中定义当前领域所需要的PO和VO，业务逻辑基于本领域内定义的PO VO实现，不会使用别的领域的PO VO，这样就能实现任意领域的业务变动，不会对其他领域造成干扰。</p>
<p>这样，一个领域包就是一个充血模型的体现，相当于独立的业务对象，先抽象出业务对象，业务对象的属性在领域内的model中定义，业务逻辑也在领域内的service中定义，更符合面向对象编程的思想。</p>
<p>因此，实际上架构从来不是导致难以维护的原因，即便强制不同service所使用的PO、VO对象不能互相污染，但是由于MVC架构天然没有基于领域包的约束，所有PO、VO对象都定义在domain中，那么最终也会导致所谓的”强制”失效。同理，即便采取DDD架构，如果不使用合适的设计模式，比如策略模式，也会导致代码的可读性很差。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>即时通讯系统</category>
      </categories>
      <tags>
        <tag>项目开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IoC</title>
    <url>/posts/19065.html</url>
    <content><![CDATA[<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><h4 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h4><p>Bean就是一个组件，组件的作用就是用来实现某种业务功能，通过调用、编排不同组件可以完成更为复杂的功能</p>
<h4 id="IoC定义"><a href="#IoC定义" class="headerlink" title="IoC定义"></a>IoC定义</h4><p>Java是面向对象的编程语言，业务逻辑的实现就是通过组合、编排不同对象的方法来完成的，一般来说我们都是自己创建对象，自己管理对象依赖，控制反转（Inversion of Control，IOC）就是说把创建对象、管理对象依赖的职责剥离出去，在Spring框架下就是交给容器来负责，我们需要啥都由容器造，也从容器中取</p>
<ul>
<li>控制：对外部资源获取的控制权</li>
<li>反转：正转就是我们自己在对象中主动控制去获取依赖的对象，反转就是将控制权交给容器来帮我们创建并注入</li>
</ul>
<p><img src="/posts/19065/image-20230827144603683.png" alt="image-20230827144603683"></p>
<h4 id="为什么需要IoC"><a href="#为什么需要IoC" class="headerlink" title="为什么需要IoC"></a>为什么需要IoC</h4><p>传统方式我们都是自己创建类对象，自己去处理类对象之间的依赖关系，类与类之间高度耦合，重复代码也比较多。有了IoC容器之后，控制权交给IoC容器，对象和对象之间的耦合度降低，方便测试，也有利于功能复用。</p>
<h4 id="Spring实现IoC"><a href="#Spring实现IoC" class="headerlink" title="Spring实现IoC"></a>Spring实现IoC</h4><p>Spring中的容器主要就是干三件事情</p>
<ol>
<li>接受订单，即需要生产什么样的Bean对象，可以通过xml文件、注解等形式，最后封装为BeanDefinition存储在一个哈希表中，相当于存储了这个Bean类的Class对象到工厂</li>
<li>生产产品，基于BeanDefinition提供的类的Class对象通过反射来创建Bean单例</li>
<li>库存产品，产品怎么存储的问题，容器中的对象的作用域一般是singleton，不需要重复创建，所以这里的存储器也是一个哈希表，维护不同Bean的单例对象</li>
</ol>
<p><img src="/posts/19065/image-20230831102147297.png" alt="image-20230831102147297"></p>
<blockquote>
<p> BeanFactory 是实现控制反转的基础，面向Spring容器，ApplicationContext则是在BeanFactory基础上的功能拓展，面向实际应用的开发人员</p>
</blockquote>
<h4 id="Spring-容器启动过程"><a href="#Spring-容器启动过程" class="headerlink" title="Spring 容器启动过程"></a>Spring 容器启动过程</h4><p>一般可以分为两个阶段，容器的启动阶段和Bean对象实例化阶段</p>
<p>容器启动阶段就是加载和解析配置文件，比如xml文件或者注解，封装成BeanDefinition并保存到哈希表中</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>依赖注入（Dependency Injection，DI）是IoC的一种实现方式，就是说比如A持有B的成员变量，初始化A时自然要初始化B，我们可以选择直接传入B的参数，由A进行初始化，而依赖注入的方式就是由容器创建B实例，然后注入进去。实际上依赖注入的不只是类对象，包括资源、常量数据都可以注入</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><p>通过构造方法以变量的形式传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CatDaoImpl</span><span class="params">(String message)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>. message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;CatDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.CatDaoImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot; message &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过属性设置的方法进行注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Id</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="built_in">this</span>.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.id &quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过注解的方式注入</p>
</li>
</ol>
<p>   修饰符有三种属性<a href="#自动装配">Constructor、byType、byName</a>，默认按照byType</p>
<h3 id="Bean对象详解"><a href="#Bean对象详解" class="headerlink" title="Bean对象详解"></a>Bean对象详解</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Bean对象是由容器创建和维护的，所以其生命周期一般分为实例化、属性赋值、初始化、使用和销毁</p>
<p>实例化就是通过反射创建类对象实例，属性赋值就是设置对象的相关属性，初始化比较复杂是为后续正常工作做预处理，包括设置Bean的id、设置Bean工厂的引用，后面就是正常使用，最后被销毁</p>
<h4 id="Bean配置"><a href="#Bean配置" class="headerlink" title="Bean配置"></a>Bean配置</h4><ol>
<li><p>xml配置文件，通过Spring加载文件创建Bean</p>
<p>优点：可以用于任何场景，xml文件可读性比较好</p>
<p>缺点：编写xml文件比较繁琐，不利于拓展</p>
<p>流程：</p>
<ol>
<li>配置xx.xml文件</li>
<li>声明命名空间和配置Bean</li>
</ol>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>Java配置，就是基于纯Java代码来配置Bean对象</p>
<p>优点：可以用于任何场景，纯Java代码，扩展性和灵活性较好</p>
<p>缺点：大量配置，影响可读性</p>
<p>流程：</p>
<ol>
<li>创建配置类，用@Configuration注解表明该类是配置类</li>
<li>创建方法，方法名与实例名保持一致，用@Bean注解表明是创建Bean对象的方法，由Spring创建并维护该实例对象</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>注解方式，通过在类上加注解的方式配置Bean，包括@Component、@Controller、@Service等类</p>
<p>优点：开发便捷，方便维护</p>
<p>缺点：不能配置第三方资源</p>
<p>流程</p>
<ol>
<li>对类添加相关注解</li>
<li>设置扫描器的包路径</li>
</ol>
</li>
</ol>
<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p><a name="自动支配">自动装配</a>就是说，Spring通过反射知道了所有Bean的信息后，包括构造函数、成员变量，可以自动进行装配，主要有以下几种自动装配的规则</p>
<ol>
<li><p>依据名称装配byName，比如有一个方法叫setCar，而容器里又有一个id为car的bean，把成员变量设置为这个car</p>
</li>
<li><p>依据类型装配byType，基于set方法，比如有一个成员变量类型为Car，而容器里也有一个类型为Car的bean，也会自动装配</p>
</li>
<li><p>依据构造函数Constructor，类似依据类型，只是需要匹配的是构造函数的入参类型，比如构造函数的入参有一个参数类型为Car，那就去找容器里面Car类型的bean</p>
<p>推荐构造函数来进行自动装配，能够保证</p>
<ol>
<li><strong>注入的组件不可变[final]</strong></li>
<li><strong>需要的依赖不为空[要么ok要么报错]</strong></li>
</ol>
</li>
</ol>
<p>具体实现包括两个后置处理器，第一个后置处理器主要是看有没有属性需要填充，如果没有就返回，否则调用第二次后置处理器进行@Autowired注解的解析，然后完成属性注入</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol>
<li>singleton：单例（默认），任何请求都只会返回唯一的单例</li>
<li>prototype：原型，任何请求会返回一个新的实例</li>
<li>web应用中的Bean对象作用域<ol>
<li>request：每一个Http请求都会产生一个新的Bean</li>
<li>session：同一个Http Session共享一个Bean</li>
</ol>
</li>
</ol>
<h4 id="Bean对象的线程安全问题"><a href="#Bean对象的线程安全问题" class="headerlink" title="Bean对象的线程安全问题"></a>Bean对象的线程安全问题</h4><p>prototype作用域下，每次获取都会生成一个新的Bean对象，不存在资源竞争问题，天生是线程安全的</p>
<p>而在singleton作用域下，单例的Bean对象是全局唯一且共享的，如果对Bean对象的操作只有查询，没有修改，那么也是线程安全的，除此之外，并无法保证线程安全，因为Spring框架本身就没有对多线程安全进行支持。</p>
<p>如果我们要保证Bean对象的多线程安全，可以使用ThreadLocal将其定义为局部变量，这样每个线程使用的都是本地内存中的Bean对象副本</p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>循环依赖就是说A类使用了B类的实例作为成员变量，B类也使用了A类的实例作为成员变量，或者C类使用了C类的实例作为成员变量</p>
<p><img src="/posts/19065/image-20230824135027599.png" alt="image-20230824135027599"></p>
<h4 id="Spring对循环依赖的支持"><a href="#Spring对循环依赖的支持" class="headerlink" title="Spring对循环依赖的支持"></a>Spring对循环依赖的支持</h4><p>循环依赖只有<strong>单例模式</strong>下才支持，并且需要使用<strong>setter方法</strong>实现依赖注入，如果是原型模式就会报错，比如创建A时，发现A依赖B，就去实例化B，又发现B依赖A，又要实例化A，循环往复，无限创建A、B对象，就会出问题</p>
<h5 id="为什么不支持构造器的循环依赖"><a href="#为什么不支持构造器的循环依赖" class="headerlink" title="为什么不支持构造器的循环依赖"></a>为什么不支持构造器的循环依赖</h5><p>构造器的循环依赖是说A构造函数内部需要完成B的构造，B构造函数内部也需要完成A的构造，因为构造函数没有完成之前是不能放到三级缓存的，因此就有点类似不可重入锁，互相卡住对方，都无法完成创建。</p>
<h5 id="为什么不能解决原型prototype作用域的循环依赖"><a href="#为什么不能解决原型prototype作用域的循环依赖" class="headerlink" title="为什么不能解决原型prototype作用域的循环依赖"></a>为什么不能解决原型prototype作用域的循环依赖</h5><p>prototype作用域下，Spring不会缓存这种原型对象，自然无法解决循环依赖</p>
<h5 id="为什么不能解决多例的循环依赖"><a href="#为什么不能解决多例的循环依赖" class="headerlink" title="为什么不能解决多例的循环依赖"></a>为什么不能解决多例的循环依赖</h5><p>同样没有设置三级缓存，无法解决循环依赖</p>
<h4 id="Spring如何处理循环依赖-单例"><a href="#Spring如何处理循环依赖-单例" class="headerlink" title="Spring如何处理循环依赖[单例]"></a>Spring如何处理循环依赖[单例]</h4><h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><p>Bean对象构造需要完成实例化→属性赋值→初始化三个步骤，依赖注入是在属性赋值时发生的，因此循环依赖也就需要在这一步进行处理，具体来讲Spring设置了三级缓存来解决循环依赖，其实就是三个Map，分别是</p>
<ol>
<li>一级缓存存储已经完成构造的Bean对象</li>
<li>二级缓存存储已经完成实例化的Bean对象</li>
<li>三级缓存存储的是生产Bean对象的工厂</li>
</ol>
<p>本质上就是通过缓存存储单例对象，表示该对象正在创建或者已经创建好了，以此处理循环依赖无限创建的问题</p>
<p>比如说A和B循环依赖了，现在A开始构造</p>
<ol>
<li><p>首先进行实例化，实例化的时候就会把A对象工厂放到三级缓存，表明A已经在实例化了</p>
<p><img src="/posts/19065/image-20230824141212428.png" alt="image-20230824141212428"></p>
</li>
<li><p>然后进行属性赋值，发现依赖B，而且B现在还没创建出来，就需要去实例化B</p>
<p>实例化B的时候也会把B对象工厂放到三级缓存，此时会发现依赖A，那么就会从一级缓存找到三级缓存，发现在三级缓存中有A的对象工厂，就可以把A扔到二级缓存中，B也可以继续往后构造完成，删除缓存，把B对象放到一级缓存中</p>
<p><img src="/posts/19065/image-20230824143243272.png" alt="image-20230824143243272"></p>
</li>
<li><p>接着A继续进行属性赋值，可以从一级缓存中拿到B对象了，A也构造完成了，把二级缓存、三级缓存中的A对象和A对象工厂删掉，然后把A扔到一级缓存中</p>
<p><img src="/posts/19065/image-20230824141638648.png" alt="image-20230824141638648"></p>
</li>
</ol>
<h5 id="第三级缓存的意义"><a href="#第三级缓存的意义" class="headerlink" title="第三级缓存的意义"></a>第三级缓存的意义</h5><p>实际上，如果单纯为了解决循环依赖，没有必要设置三级缓存，A直接实例化的时候就可以放到二级缓存，B实例化找到二级缓存中的A，就可以继续完成构造，最后放到一级缓存，A回来继续属性赋值时，也可以从一级缓存中拿到B对象，完成构造，甚至一级缓存就可以解决循环依赖</p>
<p>而多级缓存设置的意义在于支持代理，也就是说生成不同的代理对象时，确保所有代理对象持有的原始对象是唯一的</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Spring Boot</title>
    <url>/posts/50141.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Spring Boot实际上是对Spring在使用层面的功能增强</p>
<h4 id="Spring框架解决了啥问题"><a href="#Spring框架解决了啥问题" class="headerlink" title="Spring框架解决了啥问题"></a>Spring框架解决了啥问题</h4><ol>
<li>通过控制反转的思想、依赖注入的实现方式尽可能降低了组件之间的耦合度，使开发者能够专注于业务逻辑的开发</li>
<li>提供对面向切面编程的支持，尽可能减少重复造轮子</li>
<li>对主流的框架都能很好地集成，比如MyBatis、Hibernate</li>
</ol>
<h4 id="Spring框架还有啥需要完善"><a href="#Spring框架还有啥需要完善" class="headerlink" title="Spring框架还有啥需要完善"></a>Spring框架还有啥需要完善</h4><ol>
<li>配置过于复杂，包括xml配置、注解配置和基于Java的配置三种方式</li>
<li>依赖管理比较麻烦，依赖的库存在不兼容问题</li>
</ol>
<h4 id="Spring-Boot带来了什么"><a href="#Spring-Boot带来了什么" class="headerlink" title="Spring Boot带来了什么"></a>Spring Boot带来了什么</h4><ol>
<li><strong>配置过于复杂</strong>：Spring Boot基于<strong>约定优于配置</strong>的思想，进一步降低了配置的复杂度，使得开发人员尽可能专注于业务逻辑，其实就是提供了一种快速使用Spring的方式，实现基于默认配置的开箱即用</li>
<li><strong>依赖管理麻烦</strong>：Spring Boot 可以快速整合常用依赖，提供的POM依赖可以简化 Maven的配置。当我们引入核心依赖时，Spring Boot 会自引入其他依赖</li>
</ol>
<p>后续待补充…</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-MVC</title>
    <url>/posts/6963.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MVC是模型（Model）、视图（View）、控制器（Controller）的简写，核心思想在于将业务逻辑、数据、显示分离来组织代码，这样在改进和优化用户交互界面时，不需要动业务逻辑和数据模型部分的代码</p>
<p><img src="/posts/6963/image-20230825172629401.png" alt="image-20230825172629401"></p>
<h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><h4 id="Model-1"><a href="#Model-1" class="headerlink" title="Model 1"></a>Model 1</h4><p><img src="/posts/6963/image-20230827131858159.png" alt="image-20230827131858159"></p>
<p>整个Web页面几乎都是由JSP页构成的，还有少量的Java Bean类用来处理数据库操作，JSP即是控制器也是视图，业务逻辑和表现逻辑杂糅在一起，代码可读性差，重用率低，此外，前后端耦合度高，后期拓展困难</p>
<h4 id="Model-2"><a href="#Model-2" class="headerlink" title="Model 2"></a>Model 2</h4><p><img src="/posts/6963/image-20230827132457272.png" alt="image-20230827132457272"></p>
<p>解耦、封装程度不够，依然存在重复造轮子的问题</p>
<h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><p>在Spring容器、AOP等技术的基础上，遵循MVC规范所推出的web开发框架</p>
<p>解耦、封装程度进一步加深，添加了很多核心组件，功能更为丰富，但是使用起来依然很方便，能够便于开发者专注于业务逻辑。一般来说，Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h3 id="Spring-MVC-1"><a href="#Spring-MVC-1" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ol>
<li><strong><code>DispatcherServlet</code></strong>：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code></strong>：<strong>处理器映射器</strong>，根据统一资源标识符（Uniform Resource Identifier，URI）将请求映射到对应的 <code>Handler</code> ，并将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code></strong>：<strong>处理器适配器</strong>，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>
<li><strong><code>Handler</code></strong>：<strong>请求处理器</strong>，处理实际请求的处理器，封装具体的业务逻辑。</li>
<li><strong><code>ModelAndView</code></strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>
<li><strong><code>ViewResolver</code></strong>：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="/posts/6963/image-20230827134850989.png" alt="image-20230827134850989"></p>
<ol>
<li>客户端发起http请求，中央控制器接收</li>
<li>中央控制器解析出URI根据<code>HandlerMapping</code>查找处理器，<code>HandlerMapping</code>返回一个封装了拦截器和处理器的执行链</li>
<li>中央处理器请求适配器去调用对应的处理器，适配器的意义在于执行业务逻辑前的一些统一操作，包括数据验证、数据格式转换、数据封装等</li>
<li>处理器执行具体业务逻辑，逐层返回<code>ModelAndView</code>给中央处理器</li>
<li>中央处理器请求视图解析器解析视图并返回</li>
<li>中央处理器根据模型渲染视图，其实就是将模型数据填充到视图中</li>
<li>中央处理器将视图封装为http响应报文并返回给客户端</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>Spring MVC的核心组件虽然复杂，但是使用非常简单，开发者只需要关注业务逻辑即可，所以需要实现的就是Handler、View和Model</p>
<h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>前后端分离，是Web应用的一种架构模式，顾名思义就是将前端[浏览器端]和后端[业务端]解耦，约定数据交互接口，并行开发，前后端之间使用Http或者其他协议进行交互</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>比如把JSP中静态的HTML部分拿出来，变成简单的HTML文件，放在HTTP服务器上，浏览器只要获取到这些HTML就可以了。动态的数据部分用HTML里的JS通过AJAX的方式从服务器端获取，然后动态操作Dom（文档对象模型，Document Object Model），完成动态内容的展示。这样前后端就分离了。</p>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><img src="/posts/6963/image-20230827141326182.png" alt="image-20230827141326182"></strong></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-事务</title>
    <url>/posts/24314.html</url>
    <content><![CDATA[<h3 id="Spring事务支持"><a href="#Spring事务支持" class="headerlink" title="Spring事务支持"></a>Spring事务支持</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Spring事务本质上就是对数据库事务的支持，实际上事务的管理、维护还是由各自数据库自己实现的，Spring只是提供了统一的事务管理接口，数据库事务实际上就是指逻辑上的一组操作，要么都执行，要么都不执行，具备ACID性质</p>
<ol>
<li><p>原子性，事务的所有操作要么都执行，要么都不执行</p>
<blockquote>
<p>通过undo log，事务进行修改前先记录undo log，这样执行如果碰到异常，就可以通过undo log进行回滚，并且undo log优先于数据页写到磁盘中，这样即便数据库宕机，也能通过undo log回滚。</p>
</blockquote>
</li>
<li><p>一致性，事务执行前后数据库总要保持一致性，比如转账操作，转账前后两个账户的总额不能变，这是业务逻辑的一致性，还有一些主键约束、外键约束是关系型数据库的完整性</p>
<blockquote>
<p>业务逻辑层面以及数据库的约束来保证</p>
</blockquote>
</li>
<li><p>隔离性，不同事务之间不能互相干扰，比如一个事务在最终提交前，其对数据库的影响对别的线程来说是不可见的</p>
<blockquote>
<p>通过多版本并发控制[read view+undo log]和锁机制[记录锁 间隙锁 next-key 锁]</p>
</blockquote>
</li>
<li><p>持久性，事务对数据库的操作是持久保存的，即使发生了故障，也能恢复</p>
<blockquote>
<p>通过redo log，事务修改数据后，将对页的物理修改记录到redo log，redo log也会优先于数据页写到磁盘中，这样重启后也可以根据redo log的内容进行故障恢复</p>
</blockquote>
</li>
</ol>
<p>实际上，原子性、隔离性、持久性都是手段，最终目的是为了实现一致性</p>
<p><img src="/posts/24314/AID-C.png" alt="AID-&gt;C"></p>
<h4 id="事务管理分类"><a href="#事务管理分类" class="headerlink" title="事务管理分类"></a>事务管理分类</h4><ol>
<li><p>编程式事务管理</p>
<p>手动管理事务，很少使用，但是粒度可以细致到代码块级别</p>
</li>
<li><p>声明式事务管理</p>
<p>一般通过@Transactional注解的方式来使用，实际上通过AOP实现对方法前后进行拦截，将事务管理的功能附加到被拦截的方法前后，也就是说执行方法前启动一个事务，执行方法后根据执行情况决定是提交还是回滚</p>
<p>这样能够使业务逻辑和事务管理解耦，缺点就是粒度最多到方法</p>
</li>
</ol>
<h4 id="Spring的事务隔离级别"><a href="#Spring的事务隔离级别" class="headerlink" title="Spring的事务隔离级别"></a>Spring的事务隔离级别</h4><ol>
<li>ISOLATION_DEFAULT：使用数据库默认的隔离级别，比如MySQL默认是可重复读的</li>
<li>ISOLATION_READ_UNCOMMITTED：读未提交，无法阻止任何并发问题</li>
<li>ISOLATION_READ_COMMITTED：读已提交，可以防止脏读</li>
<li>ISOLATION_REPEATABLE_READ：可重复读，可以防止脏读、不可重复读</li>
<li>ISOLATION_SERIALIZABLE：串行化，可以防止幻读</li>
</ol>
<h4 id="Spring的事务传播机制"><a href="#Spring的事务传播机制" class="headerlink" title="Spring的事务传播机制"></a>Spring的事务传播机制</h4><p>多个事务同时执行，且存在互相调用的情况下，Spring是如何协调事务的动作的，也就是事务传播机制，需要注意的是事务传播机制使用<code>ThreadLocal</code>保证线程间互不干扰，所以多线程环境下不同线程的事务不存在事务传播</p>
<p>默认事务传播行为是，如果没有当前事务，则新建一个事务，如果已经存在，则加入到这个事务中，也就是说比如A调用B调用C，最后A B C会视作一个事务来进行执行，这也是用得最多的事务传播机制</p>
<h3 id="Spring事务实现原理"><a href="#Spring事务实现原理" class="headerlink" title="Spring事务实现原理"></a>Spring事务实现原理</h3><p>底层实际上通过AOP，基于动态代理实现事务管理</p>
<ol>
<li>实际上容器在创建Bean对象时，创建的都是代理对象，默认使用JDK动态代理，如果对象没有实现接口，则使用CGLIB创建子类对象，通过动态代理进行事务管理的功能增强</li>
<li>调用Bean对象的方法时，会被代理对象拦截，而且是一种环绕切面，也就是执行前、执行后都会有附加操作，这里的附加操作实际上就是开启事务，事务提交或者回滚</li>
</ol>
<h3 id="Spring声明式事务失效"><a href="#Spring声明式事务失效" class="headerlink" title="Spring声明式事务失效"></a>Spring声明式事务失效</h3><ol>
<li>@Tranctional声明的接口方法是非public的会导致事务失效，这是因为源码中会检测被声明的接口方法是不是public的，非public就直接返回了。除此之外，由于动态代理生成的动态代理对象会继承原始对象，然后重写方法，所以如果方法是private | static | final修饰的，都不能重写，事务也会失效</li>
<li>同一个类中的方法调用可能导致事务失效，比如A类定义方法test1和test2，test1调用了test2，test1没有事务注解，然后test2即便用@Tranctional进行注解，那么以test1为入口执行时，test2的事务不会生效。原因其实也是动态代理实现导致的，因为test1方法的调用是原始对象的正常执行，然后内部调用了test2，这里也是直接调用原始对象的test2方法，根本没走动态代理，事务自然就会失效</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-概览</title>
    <url>/posts/40135.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Spring是一个轻量级的开发框架，框架可以理解为半成品，能够帮助开发者更专注于业务逻辑的实现，比如说房子的地基、承重墙、柱子这些就是框架，我们需要装修房子，装修的动作就是我们业务逻辑的实现，因此框架的目的就是节省开发成本，提高开发效率</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><p>控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）</p>
<p>控制反转的意思就是将创建、维护Bean对象的控制权交给容器，容器帮助我们维护对象的创建和之间的依赖关系</p>
<p>依赖注入是实现控制反转的一种设计方式，简单来说A依赖B，但是A不自己创建B，而是交给容器基于配置来创建和赋值，再通过注入的方式交给A</p>
</li>
<li><p>面向切面编程（Aspect-Oriented Programming，AOP）</p>
<p>面向切面编程的意思是，对于记录日志、性能监控这些几乎所有模块都要使用的功能，我们可以划出一个横切面，一方面可以重用这些功能模块，另一方面也可以把这些和业务逻辑无关的功能分离出去</p>
</li>
<li><p>声明式事务</p>
<p>通过配置完成事务管理，减少硬编码的存在，比如事务提交、回滚这些JDBC代码就不需要我们自己写了</p>
</li>
<li><p>快速集成</p>
<p>支持和各自框架进行集成，比如MyBatis、Hibernate</p>
</li>
</ol>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol>
<li>Spring Core：Spring 核心，提供控制反转和依赖注入的支持</li>
<li>Spring AOP：提供面向切面编程的支持</li>
<li>Spring DAO：提供对JDBC的抽象，简化JDBC编码</li>
<li>Spring ORM：支持和主流的ORM框架的集成，比如Hibernate、MyBatis</li>
<li>Spring Web：提供Web应用开发的支持</li>
<li>Spring MVC：针对Web应用中MVC模型、视图、控制器三层架构的实现</li>
</ol>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Spring &amp; Spring MVC &amp; Spring Boot</strong></p>
<p>Spring就是Spring框架，内部包含比如Spring Core、Spring AOP等各种模块，而Spring MVC就是其中一个模块，实际上就是基于Spring IoC容器、AOP等技术实现的，符合MVC规范的一种开发Web应用程序的脚手架，MVC是模型（Model）、视图（View）、控制器（Controller）的简写，核心思想在于将业务逻辑、数据、显示分离来组织代码，这样在改进和优化用户交互界面时，不需要动业务逻辑和数据模型部分的代码</p>
<p>Spring Boot顾名思义就是Spring启动引导器，目的在于减少Spring的配置文件，简化使用方式。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><strong>工厂模式</strong>：Spring IoC就是一个大工厂，通过BeanFactory或者ApplicationContext创建、存储Bean对象，一般Bean对象是单例的，底层原理是反射，通过xml、注解等方式配置好Bean对象，Spring会将配置信息封装成一个BeanDefinition对象存储到哈希表中，获取Bean对象时，如果Bean对象未创建好，则从BeanDefinition获取类的class对象，基于反射机制进行Bean对象的实例化并存储到BeanRegistry中</li>
<li><strong>单例模式</strong>：Spring中的Bean对象作用域默认是singleton，也就是单例模式，只要已经创建，后续获取都是获取这个单例</li>
<li><strong>代理模式</strong>：Spring AOP面向切面编程，把切面功能单独分离出来就是用了代理模式，如果是实现了接口的目标类，则用JDK动态代理，否则用CGLIB动态代理</li>
<li>待后续阅读源码后补充…</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>java-ConcurrentHashMap详解</title>
    <url>/posts/58141.html</url>
    <content><![CDATA[<h3 id="HashMap的线程安全"><a href="#HashMap的线程安全" class="headerlink" title="HashMap的线程安全"></a>HashMap的线程安全</h3><p><code>HashMap</code>设计之初就没有考虑多线程访问，自然没有对多线程并发访问做任何控制，可以从两个示例进行分析</p>
<h4 id="多线程死循环"><a href="#多线程死循环" class="headerlink" title="多线程死循环"></a>多线程死循环</h4><p>JDK1.7之前，发生哈希冲突时，采用头插法插入新的<code>Node</code>，在多线程场景下，多线程扩容完成后，后续<code>get</code>操作可能发生死循环</p>
<p>首先，线程1和线程2都调用<code>transfer</code>方法进行扩容，假设切换到线程1执行扩容，并完成操作</p>
<p><img src="/posts/58141/image-20230916140306849.png" alt="image-20230916140306849" style="zoom:50%;"></p>
<p>然后，线程2开始扩容</p>
<p><img src="/posts/58141/image-20230916140943533.png" alt="image-20230916140943533"></p>
<p>最后，形成了<code>A</code>指向<code>B</code>，<code>B</code>指向<code>A</code>的循环，后续如果<code>get</code>访问到这个链表，就会出现死循环</p>
<p>虽然，在JDK1.8通过尾插法解决了该问题，但是依然可以证明<code>HashMap</code>本身对应多线程访问是没有过多附加安全控制的</p>
<h4 id="HashMap允许存放value为Null"><a href="#HashMap允许存放value为Null" class="headerlink" title="HashMap允许存放value为Null"></a>HashMap允许存放value为Null</h4><p><strong><code>value</code>为<code>Null</code>是否有意义？</strong></p>
<p><code>Null</code>是有意义的，可以类比数据库中允许为<code>Null</code>的字段，学生信息注册时，部分信息缺失，不能有缺失就不允许注册吧，因此需要允许某些字段为<code>Null</code>，表示信息缺失</p>
<p><strong><code>value</code>为<code>Null</code>存在什么问题？</strong></p>
<p> 可能存在一种歧义，获取到<code>Null</code>时，到底是不存在这个<code>key</code>，还是<code>key</code>对应的值就是<code>Null</code>呢</p>
<p>单线程场景下，我们可以通过额外添加一层<code>containsKey</code>方法来判断，也就是说，如果<code>containsKey</code>方法返回<code>true</code>，那么说明存在这个<code>key</code>，<code>get</code>就算获取到<code>Null</code>，那也是说明<code>value</code>就是<code>Null</code>；否则，说明不存在该<code>key</code>，直接结束<code>get</code>方法</p>
<p>需要注意多线程场景下就没办法解决，比如线程1和线程2，考虑这样一个执行流程，线程1调用<code>containsKey</code>方法返回<code>true</code>，线程2将<code>key</code>移除，线程1调用<code>get</code>自然只能获取到<code>Null</code>，此时，线程1会误认为自己获取到的<code>Null</code>就是<code>key</code>对应的<code>value</code>，但是实际上<code>key</code>已经被线程2移除了</p>
<p>所以，<code>HashMap</code>能够存放<code>value</code>为<code>Null</code>也是没有对多线程并发访问进行控制的一个证明</p>
<h3 id="并发安全的HashMap"><a href="#并发安全的HashMap" class="headerlink" title="并发安全的HashMap"></a>并发安全的HashMap</h3><h4 id="HashTable-amp-synchronizedMap"><a href="#HashTable-amp-synchronizedMap" class="headerlink" title="HashTable&amp;synchronizedMap"></a>HashTable&amp;synchronizedMap</h4><ul>
<li><p><code>HashTable</code>的<code>get put</code>方法都用<code>synchronized</code>进行修饰吗，并且<code>put</code>方法不允许存储<code>value</code>为<code>Null</code>，相当于加锁对象是<code>HashTable</code>的整个实例</p>
</li>
<li><p><code>synchronizedMap</code>维护一个<code>mutex</code>的成员变量，<code>mutex=this</code>，其实就是当前对象实例的互斥锁，然后<code>get</code>和<code>put</code>方法都是先对<code>mutex</code>加锁，才能继续后续操作</p>
</li>
</ul>
<p>上述两种数据结构都是通过对整个实例对象加锁实现的多线程并发访问控制，但是并非能够完全实现并发安全</p>
<p>单独对同步方法的调用是能够保证并发安全的，但是如果组合调用就无法保证了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeKey</span><span class="params">(String key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(map.containsKey(key))&#123; <span class="comment">// containsKey方法是线程安全的方法</span></span><br><span class="line">  	map.remove(key); <span class="comment">// remove方法也是线程安全的方法。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如线程1执行<code>containsKey</code>方法后释放锁还没获取<code>remove</code>的锁，线程2也执行<code>containsKey</code>方法后，后续继续执行，就会出现<code>remove</code>空的<code>key</code>，解决办法就是外层再进行锁封装，但是比较影响效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeKey</span><span class="params">(String key)</span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code>虽然在JDK1.7和1.8的实现不一样，但是均不是将整个实例对象上锁，并发度有所提高。此外，<code>ConcurrentHashMap</code>是不允许<code>value</code>为<code>Null</code>的</p>
<h4 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h4><p>底层是数组+链表，参考HashMap的JDK 1.7实现。在并发控制上采用分段锁，也就是将数组分为多个段，每段在逻辑上相当于一个小哈希表，每段上一个锁，不同段之间的锁不会互相影响，并发度取决于段的数量，因为默认是<code>16</code>，所以最多<code>16</code>个线程并发写，需要注意的是一旦初始化，后续不能修改，所以段的数量设置需要比较严谨</p>
<p><strong>put</strong></p>
<ol>
<li>检测<code>key</code>或者<code>value</code>是不是空，都不为空再继续后续操作</li>
<li>根据哈希找到对应的段，然后就是在段中进行<code>put</code>操作</li>
<li>段中的<code>put</code>操作首先要获取独占写入锁，如果失败就自旋来多次尝试获取锁，这个方法退出有两种方式，一是获取到锁，二是超出尝试次数。获取到锁之后就是正常的分为有没有已经存在的链表来分别处理</li>
<li>需要释放锁</li>
</ol>
<p><strong>resize</strong></p>
<p>扩容操作不是对整个<code>map</code>进行扩容，也就是说段的数量是不会变的，并且扩容的对象是其中一个段，将其扩充为原本的两倍大小</p>
<p>实际上如果从每个段都是一个小哈希表这个角度来看，就很好理解了，这一段不够了就扩容，没有必要影响别的段，相当于是局部扩容，而如果段的数量允许动态变化，甚至任意段的扩容都会触发全局扩容，那么考虑到触发频率[普通哈希表是整个表一次性触发，现在是任意段触发就全局扩容]，大范围迁移的成本是难以接受的</p>
<h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>底层是数组+链表+红黑树，参考<code>HashMap</code>的JDK 1.8实现。在并发控制上，采用<code>CAS+Synchronized</code>，并且锁的粒度进一步细化到<code>Node</code>，也就是链表或者红黑树的头结点，这就意味着只要并发访问的节点不是同一个节点，那么就不会出现并发问题，不需要进行并发控制，并发度相较于JDK 1.7有了显著提升，但是并没有完全摒弃JDK 1.7的分段机制（多线程扩容）。</p>
<p><strong>put</strong></p>
<p>如果数组位置是空的，那么通过<code>CAS</code>尝试设置值，效率比较高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是空的，那么就先获取<code>synchronized</code>锁，然后内部根据数据结构是红黑树还是链表进行插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>tryPresize</strong></p>
<p>扩容包括两个操作，首先新建一个两倍大小的新数组，然后进行数据迁移</p>
<p>这里的数据迁移实际上是并发的数据迁移，也就是会把整个数组的数据迁移任务划分为多个子任务[其实就是JDK 1.7的分段机制]，交给不同的线程完成，比如另外一个线程访问到某个<code>ForwardingNode</code>，发现当前线程正在扩容，就会先帮助完成扩容<code>helpTransfer()</code></p>
<p>当然也有可能就是一个线程先后完成，比如第一个发起数据迁移的线程会从数组最后开始，往前走一段，这个区间的迁移任务属于该线程，然后下一个线程就是从新的位置开始计算步长，然后迁移</p>
<p>相关成员变量</p>
<ul>
<li><code>sizeCtl</code>：判断当前<code>ConcurrentHashMap</code>所处的状态</li>
<li><code>transferIndex</code>：表示已经完成数据迁移的索引位置</li>
<li><code>ForwardingNode</code>：表示当前节点已经完成数据迁移，但是还没有完成全局数据迁移</li>
</ul>
<h3 id="相关并发容器（待补充）"><a href="#相关并发容器（待补充）" class="headerlink" title="相关并发容器（待补充）"></a>相关并发容器（待补充）</h3><h4 id="Fail-fast机制"><a href="#Fail-fast机制" class="headerlink" title="Fail-fast机制"></a>Fail-fast机制</h4><p>快速失败，就是<code>java</code>集合的一种错误检测机制。</p>
<p>底层实际上就是检查<code>expectedModCount</code>和<code>modCound</code>是否相等，不相等就会报<code>ConcurrentModificationException</code></p>
<p>对集合的修改会使得<code>modCound</code>发生变化，比如多线程环境下，有的线程在遍历，有的线程在修改，就会导致<code>expectedModCount</code>和<code>modCound</code>不相等</p>
<p>单线程场景下，在增强<code>for</code>循环遍历集合时如果涉及到修改集合那么也会报<code>ConcurrentModificationException</code>，因为增强<code>for</code>循环底层实现是迭代器，迭代器在初始化时，<code>expectedModCount</code>就已经固定为初始的<code>modCount</code>了，然后修改集合，会使得<code>modCound</code>发生变化，就导致<code>expectedModCount</code>和<code>modCound</code>不相等</p>
<h4 id="Fail-safe机制"><a href="#Fail-safe机制" class="headerlink" title="Fail-safe机制"></a>Fail-safe机制</h4><p>采用<code>Fail-safe</code>机制的并发容器[<code>java.util.concurrent</code>]在遍历时不是直接在原本的集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发<code>ConcurrentModificationException</code>。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p><code>ArrayList</code>的增删改查都是在原数组上进行操作的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(elementData, index, elementData, index + numNew, numMoved); <span class="comment">// 从elementData复制到elementData</span></span><br></pre></td></tr></table></figure>
<p>而<code>CopyOnWriteArrayList</code>就是读写分离的，几乎所有操作都是通过<code>Arrays.copyOf()</code>拷贝后在新数组上操作，操作完后再将引用指向新的数组，同时写之间的并发控制通过<code>synchronized</code>实现</p>
<p><code>add()</code>默认插入到末端，先获取原数组，然后将元素组复制到一个新的长度加1的数组，再在末尾增加值，最后将引用指向新数组</p>
<p><code>set()</code>获取原数组以及原数组对应位置的值，然后复制 | 迁移，再在对应位置设置值，最后将引用指向新数组</p>
<p><code>remove</code>()需要删除指定位置的元素，如果删除的元素是最后一个，那么直接复制，长度-1即可，否则，需要分别针对指定位置前和指定位置后做两次复制</p>
<h5 id="对比Vector"><a href="#对比Vector" class="headerlink" title="对比Vector"></a>对比Vector</h5><p><code>Vector</code>是对单独的增删改查等方法都上了<code>synchronized</code>锁，类似<code>HashTable</code>，能够保证单个操作的同步，但是组合操作则无法保证，比如一个方法的目标是删除最后一个元素，那么一般是先获取size，然后删除size-1位置的值。</p>
<p>那么假设有两个线程操作，线程1调用<code>size()</code>，线程2调用<code>remove()</code>，不会互斥，线程1得到的可能就是旧的<code>size</code>，中间线程2执行完<code>remove()</code>，线程1基于这个<code>size</code>计算下标再执行<code>remove()</code>就会报错，这时需要再加一个synchronized锁，双重锁，性能更低了</p>
<p><code>CopyOnWriteArrayList</code>则是增删改加锁，读不加锁，在读方面比<code>Vector</code>好</p>
<p>但是增删改操作是基于<code>Arrays.copyOf</code>的，如果原数组很大，可能也会得不偿失</p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><p>读轻，写重，无法适用于实时性要求较高的场景，因为<code>add()|remove()|set()</code>等操作都需要时间来拷贝数组，调用<code>get</code>操作，读取到的数据可能还是旧值，因为<code>set()</code>可能还没完成，虽然能够保证最终的一致性，但是无法满足实时性要求</p>
<p>此外，虽然<code>CopyOnWriteArrayList</code>看似适合读多写少的操作，但是无法保证到底要存多少数据，一旦数据量过大，一次写就得花大量时间进行拷贝，代价难以接受，即便读多写少，也可能出现问题</p>
<p>而如果初始化后几乎没有任何写操作，虽然完美符合<code>CopyOnWriteArrayList</code>的设计理念，但是这样用<code>ArrayList</code>也可以了</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>底层通过<code>CAS</code>操作来更新头结点和尾结点，保证原子性，控制并发安全</p>
<p><code>head</code>和<code>tail</code>的更新是一种延迟更新机制</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>如果要实现生产者-消费者模式，就需要一个队列存储任务，并实现以下功能</p>
<ol>
<li>队列满了，需要阻塞生产者，唤醒消费者</li>
<li>队列空了，需要阻塞消费者，唤醒生产者</li>
<li>考虑线程安全问题，避免重复消费和死锁</li>
</ol>
<p>这也就是<code>BlockingQueue</code>的设计目的，按照底层实现不同可以分为</p>
<ol>
<li><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列</li>
<li><code>LinkedBlockingQueue</code>：基于链表的线程安全的无界[<code>Integer.MAX_VALUE</code>]阻塞队列</li>
<li><code>PriorityBlockingQueue</code>：具有优先级排序特性的无界[<code>Integer.MAX_VALUE</code>]阻塞队列</li>
<li><code>SynchronousQueue</code>：不存储任何元素，存一个必须消费一个</li>
<li><code>LinkedTransferQueue</code>：基于链表结构的无界传输队列，同时允许一个元素直接从生产者传输给消费者，即如果消费者已经在等待，直接交付。如果没有等待的消费者，元素将入队</li>
<li><code>LinkedBlockingDeque</code>：基于链表结构的双端阻塞队列。它同时支持从队列头部插入和移除元素，也支持从队列尾部插入和移除元素</li>
<li><code>DelayQueue</code>：无界阻塞队列，用于存放实现了 <code>Delayed</code> 接口的元素，这些元素只能在其到期时才能从队列中取走</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-IO基础</title>
    <url>/posts/4986.html</url>
    <content><![CDATA[<h3 id="什么是IO？"><a href="#什么是IO？" class="headerlink" title="什么是IO？"></a>什么是IO？</h3><p>IO就是Input和Output的简称，其实就是数据流的输入和输出。</p>
<p><strong>从应用程序层面来看</strong>，以java为主体，Input就是从外部向java应用程序输入数据，Output则是从java应用程序输出数据。本质上，java IO的作用就是帮助java程序和外部进行数据交互，这里的外部可以包括磁盘、网络、键盘、显示器等。</p>
<p><strong>从操作系统层面来看</strong>，用户进程想要执行IO操作，必须通过系统调用来间接访问内核空间，即应用程序对操作系统的内核发起IO调用，内核负责具体的IO操作。</p>
<p><strong>内核需要做两件事情</strong></p>
<ol>
<li>内核等待I/O设备准备好数据，比如磁盘或者网卡</li>
<li>内核将数据从内核空间拷贝到用户空间</li>
</ol>
<h3 id="IO分类"><a href="#IO分类" class="headerlink" title="IO分类"></a>IO分类</h3><h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><ol>
<li>字节流（Stream）——可以处理任意文件，包括图片、音频、视频等</li>
<li>字符流（Reader | Writer）——一般只用来处理文本文件</li>
</ol>
<p>顾名思义，字节流表示传输的数据在逻辑上以字节（byte-8位）为单位，字符流则以字符（不同编码字节数不同）为单位。但是，实际文件的存储都是以字节的形式进行存储的，即便是字符，也是先编码为字节，再存储，读取时，也要解码为字符。</p>
<p>因此，实际上总得来说都是字节流，字符流只是在字节流的基础上引入编码、解码操作，以一种特定的规则（编码集）解读字节流得到的产物。</p>
<p>比如收到3个字节所表示的汉字“君”后，去掉<strong>报头</strong>，最后封装为4个字节的整型，反过来就是自动分割并添加报头</p>
<p><strong>1110</strong>0101 <strong>10</strong>010000 <strong>10</strong>011011→01010100 00011011→</p>
<p>00000000 00000000 01010100 00011011</p>
<p><strong>为什么引入字符流呢？</strong></p>
<p>归根到底是方便</p>
<ol>
<li>字节流读取单个字节，是给机器看的，对于我们来说根本理解不了；字符流读取一个字符，是能够理解的</li>
<li>传输字节流的时候，不管内容是什么，都要将其编码为字节，也就是二进制序列，接收方想要识别这些内容，就要进行解码，还可能出现编码错误，所以对于一些字符的内容，比如文本内容，直接传输字符是比较方便的，避免了编码和解码操作</li>
</ol>
<h4 id="传输方向"><a href="#传输方向" class="headerlink" title="传输方向"></a>传输方向</h4><ol>
<li>输入流——Input，从外部往java应用程序进行数据输入</li>
<li>输出流——Output，从java应用程序往外部进行数据输出</li>
</ol>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><ol>
<li>文件流：从文件中读写数据</li>
<li>数组流：从字节或者字符数组中读写数据</li>
<li>缓冲流：提供缓冲区的读写数据</li>
<li>对象流：提供对java对象的序列化和反序列化操作</li>
</ol>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>装饰者顾名思义就是不改变类的原始功能的基础上添加功能，实际上使用继承 | 代理的方法也能够实现</p>
<p><img src="/posts/4986/image-20231010130319333.png" alt="image-20231010130319333"></p>
<h4 id="IO类的装饰器模式"><a href="#IO类的装饰器模式" class="headerlink" title="IO类的装饰器模式"></a>IO类的装饰器模式</h4><p><img src="/posts/4986/DP-Decorator-java.io.png" alt="image"></p>
<p>比如<code>InputStream</code>是一个抽象类，实现类定义了文件字节输入流<code>FileInputStream</code>，而装饰器类则是了一个子类<code>FilterInputStream</code>，子类有<code>BufferedInputStream</code>的具体实现，提供缓存功能</p>
<p>比如我们要创建一个基于文件带缓存功能的字节输入流，这样原本的输入输出功能就被装饰了一层缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;text.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="File-如何递归列出目录下所有文件"><a href="#File-如何递归列出目录下所有文件" class="headerlink" title="File-如何递归列出目录下所有文件"></a>File-如何递归列出目录下所有文件</h4><p>参数就是目录地址dir</p>
<p>执行流程是这样的</p>
<ol>
<li>首先如果dir为空或者这不存在该目录，则返回，否则转2</li>
<li>如果dir是一个文件，打印文件名，返回，否则转3</li>
<li>说明dir是一个目录，遍历目录下的所有文件 | 目录，递归调用该方法</li>
</ol>
<h4 id="如何复制文件"><a href="#如何复制文件" class="headerlink" title="如何复制文件"></a>如何复制文件</h4><ol>
<li>定义文件输入流和文件输出流</li>
<li>定义一个中转站的字节数组</li>
<li>扫描输入流以中转站的大小读取原文件，只要读取的字节个数不为-1，就将读取的内容先存到中转站，然后借助输出流写到新的文件中</li>
<li>关闭输入输出流</li>
</ol>
<h4 id="逐行输出文本"><a href="#逐行输出文本" class="headerlink" title="逐行输出文本"></a>逐行输出文本</h4><ol>
<li>定义文件输入流，用缓冲区的输入流进行装饰</li>
<li>循环调用输入流的readline方法，只要返回值不为null就循环打印读取的一行文本</li>
<li>关闭输入流</li>
</ol>
<h4 id="将一个对象序列化为二进制字节存储起来再读取"><a href="#将一个对象序列化为二进制字节存储起来再读取" class="headerlink" title="将一个对象序列化为二进制字节存储起来再读取"></a>将一个对象序列化为二进制字节存储起来再读取</h4><ol>
<li>序列化的类必须实现Serializable接口，该接口只起到一个标识作用，没有实际意义</li>
<li>创建一个序列化类的对象实例</li>
<li>定义文件输出流，用对象输出流进行装饰</li>
<li>调用writeObject方法将对象实例写入到文件中</li>
<li>关闭输出流</li>
<li>定义文件输入流，用对象输入流进行装饰</li>
<li>调用输入流的readObject方法读取文件存储的对象实例</li>
<li>关闭输入流</li>
</ol>
<h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>如果我们想要将java的对象存储到文件或者通过网络进行传输，那么就需要对其进行序列化，也就是将其转换为字节流，然后需要使用时，或者接收方收到字节流可以对其进行反序列化，将其从字节流转回对象</p>
<p>序列化技术有很多，包括java原生序列化技术、XML、ProtoBuf、ProtoStuff等等，这些方法在序列化后数据大小、序列化性能、跨平台性、使用的方便程度有所区别</p>
<h4 id="为什么序列化要实现Serializable接口"><a href="#为什么序列化要实现Serializable接口" class="headerlink" title="为什么序列化要实现Serializable接口"></a>为什么序列化要实现Serializable接口</h4><p>实际上接口是一种规范和标准，实现Serializable接口的目的就是显式告知当前这个类是可序列化的，不需要我们重写任何方法，只起到一个标记作用，这样能够保证只有允许序列化的类才能被序列化</p>
<h4 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别?"></a>Java 中，Serializable 与 Externalizable 的区别?</h4><p>都是序列化的一种方式，以便在网络上传输或者可以将它们的状态保存在磁盘上</p>
<p>Serializable 接口是 JVM 内嵌的默认序列化方式，成本高、不安全、难以跨平台。Externalizable 主要就是增强安全控制，允许细粒度控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<p>具体来讲</p>
<ol>
<li>Serializable会把所有属性进行序列化和反序列化，而Externalizable 提供writeExternal()和readExternal()方法手动指定哪些属性需要序列化</li>
<li>使用Externalizable 必须按照写入时的顺序进行读取，增加了安全性，而Serializable无此要求</li>
</ol>
<h4 id="类的某些属性不想序列化"><a href="#类的某些属性不想序列化" class="headerlink" title="类的某些属性不想序列化"></a>类的某些属性不想序列化</h4><p>用transient关键字修饰，只能修饰变量，无法修饰类和方法，被transient修饰的变量，反序列化后会赋值为依据类型的初始值</p>
<p>此外，static变量因为属于类，而不属于类对象，本身就无法序列化</p>
<p>并且transient只作用于以Serializable实现序列化的类的属性，如果使用的是Externalizable ，则无效</p>
<h4 id="给定一个URL地址，从网络上读取数据"><a href="#给定一个URL地址，从网络上读取数据" class="headerlink" title="给定一个URL地址，从网络上读取数据"></a>给定一个URL地址，从网络上读取数据</h4><ol>
<li>传入url地址创建一个URL类的对象实例</li>
<li>调用url.openStream方法创建输入流，并用字符流和缓冲流进行装饰，指定解码格式是比如utf-8</li>
<li>调用readline方法，逐行打印</li>
<li>关闭输入流</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-IO扩展</title>
    <url>/posts/39414.html</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h4><p>进程视角，阻塞的意思就是进程请求IO，如果IO资源没有准备好，则需要阻塞等待，放弃CPU使用权</p>
<h4 id="同步IO和非同步IO"><a href="#同步IO和非同步IO" class="headerlink" title="同步IO和非同步IO"></a>同步IO和非同步IO</h4><p>操作系统视角，会不会主动通知进程。</p>
<p>同步IO就是说，操作系统收到进程的IO请求时，如果IO资源没有准备好则不响应进程，进程可以阻塞也可以不阻塞。</p>
<p>异步IO就是说，即便资源没有准备好，也会返回一个标记，当IO资源准备好以后，再用事件机制返回给程序。</p>
<h3 id="UNIX-IO模型"><a href="#UNIX-IO模型" class="headerlink" title="UNIX IO模型"></a>UNIX IO模型</h3><h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p><img src="/posts/39414/image-20231010175658823.png" alt="image-20231010175658823"></p>
<p>Linux的默认socket都是blocking的，阻塞就是应用进程挂起，放弃CPU使用权，执行别的任务。</p>
<p>同步阻塞IO模式，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。</p>
<p><strong>特点</strong></p>
<p>同步阻塞 IO 整个过程都是阻塞的，对于用户可以及时返回数据，无延迟，对于开发者来说简单省事，但是对于系统来说无法应对高并发访问，并且用户在等待期间也无法进行其他任何操作。</p>
<h4 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h4><p><img src="/posts/39414/image-20231010182127505.png" alt="image-20231010182127505"></p>
<p>采用轮询的方式，定时去查看数据是否准备完成。在这种模型中，进程是以非阻塞的形式打开的。IO 操作不会立即完成，如果该缓冲区没有数据的话，就会直接返回一个EWOULDBLOCK错误，不会让应用一直等待中。</p>
<p>实际上，非阻塞IO也会调用recvfrom，但是通过将连续长时间的阻塞划分为多个小阻塞，保证进程依然能够获取CPU使用权</p>
<p><strong>特点</strong></p>
<p>在等待任务期间进程可以处理其他事情，缺点的话就是因为采用定时轮询的方式，浪费CPU的性能，导致系统整体的吞吐量降低。</p>
<h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h4><p><img src="/posts/39414/image-20231010182201815.png" alt="image-20231010182201815"></p>
<p>高并发场景下，同步非阻塞IO需要创建大量线程读取数据，这些线程又会不断调用recvfrom，轮询socket状态，造成资源的浪费。</p>
<p>I/O多路复用其实就是循环查询多个任务的完成状态(fd文件描述符)，只要有任何一个任务完成，就去处理它。这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO多路复用。</p>
<h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p><img src="/posts/39414/image-20231010182211289.png" alt="image-20231010182211289"></p>
<p>虽然I/O多路复用解决了需要创建大量线程的问题，但是select轮询还是太浪费性能了，大部分轮询都是无效的，因此就引入了信号驱动I/O。信号驱动I/O在调用sigaction时候建立一个SIGIO的信号联系，当内核数据准备好之后再通过SIGIO信号，通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求。因为信号驱动IO的模型下，应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个文件描述符。</p>
<h4 id="异步非阻塞IO"><a href="#异步非阻塞IO" class="headerlink" title="异步非阻塞IO"></a>异步非阻塞IO</h4><p><img src="/posts/39414/image-20231010182541969.png" alt="image-20231010182541969"></p>
<p>信号驱动IO模型只是由内核通知我们可以开始下一个IO操作（recvfrom），而异步非阻塞 IO模型是由内核通知我们操作什么时候完成（已经到用户空间了）</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>小王去买火车票，三天后买到一张车票，往返车站耗费1小时</p>
<p><strong>同步阻塞</strong></p>
<p>小王去火车站买票，排队三天买到一张退票。整个三天小王无法做其他事情，只能做买票的一件事情。</p>
<p><strong>非同步阻塞</strong></p>
<p>小王去火车站买票，隔一天去火车站问有没有票，三天后买到一张票。整个过程中小王需要往返3次，往返消耗3小时，这个期间小王可以做其他事情。</p>
<p><strong>I/O多路复用</strong></p>
<p>委托黄牛去买票，多路指的就是一个黄牛可以服务多个人。</p>
<ul>
<li><p>select/poll</p>
<p>  小王去火车站买票，委托黄牛购买，然后每隔12小时打电话询问黄牛，黄牛三天买到票，然后小王去火车站交钱领票。整个小王需要往返2次，往返消耗2小时，黄牛需要手续费100，打电话6次，这里的黄牛就是select/poll。</p>
</li>
<li><p>epoll</p>
<p>  小王去火车站买票，委托黄牛购买，黄牛买到后即通知小王去领，然后小王去火车站交钱领票。整个过程小王需要往返2次，往返消耗2小时，黄牛需要手续费100，但是无需打电话。</p>
</li>
</ul>
<p><strong>信号驱动IO</strong></p>
<p>小王去火车站买票，售票员留下电话，有票后，售票员电话通知小王，然后小王去火车站交钱领票。整个过程小王需要往返2次，往返消耗2小时，无手续费，无需打电话。</p>
<p><strong>异步非阻塞IO</strong></p>
<p>小王去火车站买票，给售票员留下电话，有票后，售票员直接快递送票上门，然后通知小王。整个过程小王需要往返1次，往返消耗1小时，无手续费，无需打电话。</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>BIO全称是Blocking I/O，对应同步阻塞IO。同步阻塞，在这种模式下，数据的读取写入都会阻塞在一个线程内，线程释放CPU的使用权，等待数据完成读取和写入才能继续执行。这种模式的编程实现简单，在一些低负载的场景下比较适用。</p>
<p>在应用层面的体现就是：</p>
<ol>
<li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li>
<li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成对上一个请求的处理。</li>
</ol>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p><strong>系统调用过程</strong></p>
<p><strong>服务端</strong></p>
<p>主线程5759</p>
<ol>
<li><p>创建一个新的<code>socket</code>对象，返回文件描述符fd5，实际上是一个TCP连接对象</p>
</li>
<li><p>通过<code>bind()</code>将这个TCP连接绑定到本地端口8080</p>
</li>
<li><p>通过<code>listen()</code>进行监听</p>
</li>
<li><p>通过<code>accept()</code>阻塞等待客户端连接，底层实际上是<code>poll</code>方法</p>
<blockquote>
<p>为什么<code>poll()</code>还是阻塞的，原因在于<code>Stream API</code>无法支持“非阻塞读”</p>
</blockquote>
</li>
</ol>
<p><strong>客户端</strong></p>
<ol>
<li><p>创建<code>socket</code>对象，本地端口是8080</p>
</li>
<li><p>调用<code>connect()</code>；连接到服务器的8080端口</p>
</li>
</ol>
<p><strong>服务端</strong></p>
<ol>
<li>三次握手建立了新的连接，返回文件描述符为fd6，并<code>clone()</code>创建新的线程5873，负责后续该连接的读写操作和业务处理</li>
<li>新的线程会阻塞到<code>recvfrom()</code></li>
</ol>
<p><strong>图示</strong></p>
<p><img src="/posts/39414/image-20231010163324586.png" alt="image-20231010163324586"></p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>同一时间，服务器只能接受来自于单个客户端的请求信息；虽然可能多个客户端的请求是同时进行的，但是服务端还是只能顺序处理客户端请求，难以应对高并发的场景。</p>
<p>即便通过多线程伪异步进行优化也难以解决该问题，因为业务处理虽然可以多线程，但是接收数据报文还是顺序进行的，并且服务端也不能无限制地创建线程，线程数量太多，也会影响系统性能。</p>
<p>本质上是因为<code>accept()</code>、<code>read</code>函数底层实际上调用了<code>poll</code>、<code>recvfrom</code>函数，该函数实际上是操作系统级别的同步IO方法，会阻塞等待连接或者数据，阻塞就会触发上下文切换</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>NIO全称是Non-Blocking I/O，对应同步非阻塞IO。也就是同步非阻塞模式的IO，线程发起IO请求可以立即返回，但是需要以轮询的方式询问IO是否完成，完成则拷贝数据给发起IO请求的线程。</p>
<h4 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h4><p><strong>图示</strong></p>
<p><img src="/posts/39414/image-20231010165220909.png" alt="image-20231010165220909"></p>
<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>依然存在阻塞，即数据到达数据队列后，需要阻塞等待拷贝到用户缓冲区，因此也会触发上下文切换。</p>
<p>当然，相对于BIO还是有所改进，也就是不会阻塞等待accept方法，同时数据准备的过程（数据还没到网卡 或者 数据还没到数据接收队列）。但是，不断循环，就跟忙等一样，没有放弃CPU使用权，而这个时间是无效的CPU时间。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>I/O多路复用其实就是统一将多个文件描述符打包传给内核，并委托内核循环查询多个任务的完成状态(fd文件描述符)，只要有任何一个任务完成，就去处理它，这样就不需要用户进程轮询调用多次内核来查询是否有事件。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h5><p><img src="/posts/39414/image-20231010185722994.png" alt="image-20231010185722994"></p>
<video src="java-IO扩展/349279b4-9119-11eb-85d0-1278b449b310.mp4"></video>

<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><h5 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h5><p><img src="/posts/39414/image-20231011144518046.png" alt="image-20231011144518046"></p>
<video src="java-IO扩展/346e30f4-9119-11eb-bb4a-4a238cf0c417.mp4"></video>

<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>哈希表：优势在于查询效率非常高，底层实现是数组，虽然得益于动态扩容，不会出现空间不够的问题，但是当文件描述符数量变少时，哈希表不好缩容。</p>
<p>B+树：本来是通过多叉降低树的高度，减少磁盘的IO次数，但是这里是在内存中，并不是非常适用</p>
<h5 id="如何通知"><a href="#如何通知" class="headerlink" title="如何通知"></a>如何通知</h5><p>数据到达之后，比如5、6的网卡接收到数据，并借助DMA拷贝到内核缓冲区中，回调函数就能将数据和文件描述符添加到就绪队列，实际上不是拷贝过去，而是通过指针指向的改变，将节点链接到就绪队列中</p>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h5><p>水平触发：只要底层有事件就绪，只要没有被取走，就一直通知上层，直到没有数据为止</p>
<p>边缘触发：底层就绪事件的数量由无到有，由少变多时触发，并且只通知一次，如果没有处理，就只能等到下次有数据才会再次触发</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>select</strong></p>
<p><strong>优势</strong>：统一将多个文件描述符以bitmap的形式打包传给内核，并委托内核循环查询多个任务的完成状态(fd文件描述符)，只要有任何一个任务完成，就去处理它，这样就不需要用户进程轮询调用多次内核来查询是否有事件。</p>
<p><strong>缺陷</strong>：</p>
<ol>
<li>输入参数和输出参数是同一个位图，每次调用select都要重新初始化</li>
<li>位图需要频繁在内核态、用户态之间拷贝，每次循环就拷贝</li>
<li>内核态、用户态必须通过遍历才能识别就绪的连接</li>
<li>文件描述符的数量存在上限</li>
</ol>
<p><strong>poll</strong></p>
<p><strong>改进点</strong>：将bitmap的数据结构改为链表，解决数量上限问题</p>
<p><strong>epoll</strong></p>
<p><strong>改进点</strong>：</p>
<ol>
<li>拷贝次数减少，只在合适的时候调用 EPOLL_CTL_ADD 将文件描述符结构拷贝到内核中，内核态的数据结构是红黑树，增删改的平均开小是O(logN)，而select和poll中不存在这样的数据结构，所以每次循环就得拷贝进去</li>
<li>回调函数会将就绪的红黑树节点链接到就绪队列中，内核只需要看一下就绪队列是否为空，而不需要遍历整个文件描述符集合</li>
<li>不需要将整个文件描述符集合拷贝回用户态，只需要将就绪队列拷贝回内核态</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-List详解</title>
    <url>/posts/7673.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>java中的集合框架是经常使用到的类族，基本都包含在<code>java.util</code>中，可以划分为<code>List</code>、<code>Map</code>和<code>Set</code>三大类</p>
<p><img src="/posts/7673/image-20230911095555940.png" alt="image-20230911095555940"></p>
<p>列表的特点就是存储的元素是有序的，允许重复的。根据底层数据结构一般可以划分为<code>ArrayList</code>、<code>LinkedList</code>，此外还有一个<code>Vector</code>是线程安全的，但是效率非常低，几乎不使用。</p>
<p><strong>何为有序 | 无序？</strong></p>
<p>无序性不是说完全随机，而是说不是按照添加的顺序进行存储或者遍历的，比如<code>HashMap</code>实际上底层也是数组，但是却是按照哈希值计算的下标进行存储 | 遍历的（如果没有发生哈希冲突），所以从数组层面，实际上是有序的，但是从插入的角度来看，就是无序的，如果要保留插入的顺序，可以使用<code>LinkedHashMap</code></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>用数组存储元素的列表</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><code>ArrayList</code>的底层数据结构很简单，就是一个存储<code>Object</code>的数组<code>elementData</code>，因而具备快速随机查找的能力（<code>get()</code>、<code>set()</code>的开销均是<code>O(1)</code>），实现了<code>RandomAccess</code>接口，而该能力在我看来也是其能够作为<code>Map</code>底层数据结构的根本原因。此外，<code>ArrayList</code>的扩容使得我们不需要像数组一样，随时关心容量是否足够大。需要注意的是，考虑到效率问题，<code>ArrayList</code>本身是没有实现多线程并发访问的安全控制机制的</p>
<p><code>ArrayList</code>还有两个比较重要的属性，一个是容量<code>capacity</code>，一个是当前大小<code>size</code></p>
<p><code>size</code>表示的是当前数组中存储了多少元素，<code>capacity</code>指的是存储容量上限，实际上就是数组的大小</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ol>
<li>无参构造函数，其初始容量为10，实际上是将引用指向一个<code>final</code>修饰的<code>Object</code>数组，而并非临时创建</li>
<li>指定初始容量的构造函数，这里是新建一个<code>Object</code>数组</li>
<li>输入一个集合对象的构造函数<ol>
<li>首先，调用<code>toArray</code>将输入转换为<code>Object</code>的临时数组</li>
<li>其次，看集合类型是不是<code>ArrayList</code><ol>
<li>是，直接将引用指向临时数组</li>
<li>否，那就调用<code>Arrays.copyOf</code>方法进行转换</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li><p><code>new</code>一个<code>ArrayList</code>，然后调用<code>add</code>方法添加元素</p>
</li>
<li><p><code>new</code>的时候以内部类的形式调用<code>add</code>方法添加元素</p>
</li>
<li><p>通过<code>Arrays.asList</code>方法传入<code>ArrayList</code>的构造函数</p>
<p><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;))</code>  </p>
</li>
<li><p>调用<code>Collections.nCopies</code> ，生成存储<code>n</code>份指定元素的<code>ArrayList</code></p>
<p><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Collections.nCopies(10, 0));</code>  </p>
</li>
</ol>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p><code>add() | addAll()</code></p>
<p>二者都是添加元素的方法</p>
<ul>
<li><code>add()</code>方法支持单个元素的插入，允许默认尾部插入（<code>O(1)</code>）,也允许在指定位置插入</li>
<li><code>addAll()</code>方法支持集合形式（<code>size=m</code>）的插入，允许默认尾部插入（<code>O(m)</code>），也允许在指定位置插入</li>
</ul>
<p>算法流程</p>
<p><img src="/posts/7673/image-20230911102523327.png" alt="image-20230911102523327"></p>
<p><code>addAll()</code>整体流程类似<code>add()</code>方法，区别在于判断容量是否足够需要判断传入集合的大小<code>numNew</code>是否超过剩余存储空间（<code>capacity-size</code>），扩容时也需要考虑这部分元素数量<code>numNew</code>，此外，不是一个一个赋值，而是调用<code>arraycopy</code>方法直接复制过去，所以如果是带<code>index</code>的集合添加，那么就可能需要两次<code>arraycopy</code>，第一次是迁移原来的元素，长度基于<code>index</code>计算（<code>s-index</code>），位置偏移量自然就是<code>index→index+numNew</code>；第二次就是将集合内元素复制到数组里面去了，长度是<code>numNew</code>，位置偏移量是<code>0→index</code>。</p>
<blockquote>
<p><code>arraycopy(src, srcPos, dest, destPos, length)</code>:将<code>src</code>数组从<code>srcPos</code>开始，长度为<code>length</code>的区间内元素复制到<code>dest</code>数组从<code>destPos</code>开始的位置</p>
</blockquote>
<p><img src="/posts/7673/image-20230911103906647.png" alt="image-20230911103906647"></p>
<hr>
<p><code>remove()</code></p>
<p>支持输入下标，删除指定下标的元素，并返回该元素；支持输入元素，删除遍历碰到的第一个满足<code>equals</code>的元素，返回是否删除成功</p>
<p>实际上都是先把被删除元素右侧的元素复制（移动）到数组实现前移一位的操作，位置偏移量<code>index+1→index</code>，长度为<code>newSize-index</code>，然后将最后一位置为<code>null</code>，方便垃圾回收</p>
<hr>
<p><code>trimTosize()</code></p>
<p>将底层数组的容量修改为当前数组的实际大小<code>size</code>，也是通过复制实现的，长度自然就是<code>size</code>，大小改变，也会导致<code>modCount++</code></p>
<hr>
<p><code>ensureCapacity()</code></p>
<p>根据需要增加<code>ArrayList</code>实例的容量，以确保它至少可以容纳由<code>minCapacity</code>参数指定的元素。</p>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><h5 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h5><p>自动扩容的关键方法是<code>grow()</code>，自动扩容发生在添加元素前（初始容量为10，添加第11个元素时扩容），需要检查添加元素后的大小，也就是能够容纳这些元素的最小容量是否超过当前数组<code>length</code>，如果超过则需要扩容</p>
<p>扩容的具体步骤为</p>
<ol>
<li><p>首先，明确新的容量是多少，传入能够容纳的最小容量一般是<code>size+1</code>或者<code>size+numNew</code></p>
<p>新的容量首先初始化为老的数组的长度的大约1.5倍，然后如果所需要的最小容量还超过了这个1.5倍的新容量，那么新数组的大小应该赋值为这个所需要最小容量。此外，如果新容量已经超过默认的最大容量，那应该调用<code>hugeCapacity()</code>计算最终结果</p>
</li>
<li><p>然后新建一个新容量的数组，并将老数组的数据复制进去</p>
</li>
<li><p>最后返回这个新数组</p>
</li>
</ol>
<p>扩容完之后，再将新元素进行插入</p>
<p>这样的自动扩容机制能够使得我们在使用<code>arraylist</code>时不需要关心容量，但是频繁的递增式扩容的代价是比较大的，因此要么设定一个初始化容量，要么根据实际需求调用<code>ensureCapacity</code>方法手动进行扩容</p>
<h5 id="ArrayList→HashMap"><a href="#ArrayList→HashMap" class="headerlink" title="ArrayList→HashMap"></a>ArrayList→HashMap</h5><p>如果给你一组元素：a b c d e f g需要放到<code>ArrayList</code>中，如果使得获取元素的开销是<code>O(1)</code></p>
<ol>
<li><p>利用哈希表的思想，总共<code>7</code>个元素，新建一个容量为<code>2^3=8</code>的<code>ArrayList</code>，初始化可以利用<code>Collections.nCopies(8, &quot;0&quot;)</code>方法进行填充</p>
</li>
<li><p>然后通过计算每个元素，比如a的哈希值，再与<code>8-1</code>也就是<code>7</code>做按位与，计算出元素的位置，存储起来就行了</p>
<p><code>&quot;a&quot;.hashCode() &amp; (8-1)</code></p>
</li>
<li><p>获取元素的时候同样也要计算哈希值对应的数组下标</p>
</li>
</ol>
<h4 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h4><p><strong>Fail-Fast机制是什么</strong></p>
<p>快速失败，就是java集合针对更新操作的一种错误检测机制。</p>
<p>底层实际上就是检查<code>expectedModCount</code>和<code>modCound</code>是否相等，不相等就会报<code>ConcurrentModificationException</code></p>
<p>而<code>expectedModCount</code>在迭代器初始化时就确定，而<code>modCound</code>会随着对集合的操作而增加。</p>
<p><strong>Fail-Safe机制是什么</strong></p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发<code>ConcurrentModificationException</code>，其实就是<strong>快照遍历</strong>。</p>
<p><code>java.util.concurrent</code>包下的容器都是安全失败的</p>
<hr>
<p><strong>Arrays.asList的特点？为什么会有这种特点</strong></p>
<ol>
<li><code>Arrays.asList</code>构建的集合不能直接赋值给<code>ArrayList</code>的引用，需要以传参的形式初始化<code>ArrayList</code></li>
<li><code>Arrays.asList</code>构建的集合不能添加 | 删除元素</li>
</ol>
<p>归更到底<code>Arrays.asList</code>构建的不是一个<code>List</code>类的子类对象，而<code>ArrayList</code>才是<code>List</code>的子类，虽然都属于<code>Collcetion</code>类的子类</p>
<hr>
<p><strong>为什么初始化一个10大小的ArrayList，list.add(2,”1”)之后会报错IndexOutOfBoundsException</strong></p>
<p>这是因为<code>add(index)</code>方法会调用<code>rangeCheckForadd</code>，内部如果发现<code>index</code>大于<code>size</code>，或者小于<code>0</code>就报错，而<code>size</code>实际上不是容量，而是每添加一个元素就<code>+1</code>，初始化后没有添加任何元素，<code>size</code>为<code>0</code>，<code>add</code>传入下标为<code>2</code>自然会报错</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>双向链表存储元素的列表</p>
<h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><p><code>LinkedList</code>实现了<code>list</code>接口和<code>deque</code>接口，既可以作为顺序容器，也可以充当队列和栈</p>
<p><code>LinkedList</code>的底层是双向链表，维护了<code>first</code>和<code>last</code>两个引用分别指向首尾元素，链表为空时，均为<code>null</code>，允许存放<code>null</code>元素</p>
<p>所有跟下标相关的操作都是线性的，而首尾的操作则是<code>O(1)</code>，为追求效率，没有实现同步，如需要，可以先用<code>Collections.synchronizedList()</code>方法进行包装</p>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><ol>
<li>无参构造函数，没有任何操作</li>
<li>输入一个集合对象的构造函数，调用<code>addAll()</code>方法</li>
</ol>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li><p><code>new</code>一个<code>LinekdList</code>，然后调用<code>add</code>方法添加元素</p>
</li>
<li><p><code>new</code>的时候以内部类的形式调用<code>add</code>方法添加元素</p>
</li>
<li><p>调用<code>Collections.nCopies</code> 生成存储<code>n</code>份指定元素的<code>LinkedList</code></p>
<p><code>LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(Collections.nCopies(10, 0) );</code> </p>
</li>
</ol>
<h4 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h4><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>删除元素时，被删除的元素自身需要置为<code>null</code>并且<code>next</code>也指向<code>null</code>，清空操作也需要将节点之间的引用关系置为空，帮助垃圾回收机制进行回收</p>
<p>查找元素时，有一个小优化，头开始还是尾部开始取决于下标靠近哪一边</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>基于数组和双指针实现的双端队列</p>
<h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><p><code>ArrayDeque</code>实际上就是循环数组（<code>Object</code>数组）和双指针（<code>head|tail</code>）实现的双端队列，可模拟<code>LinkedList</code>能够实现的栈、队列、双端队列等数据结构</p>
<p><code>head</code>执行第一个有效元素，<code>tail</code>指向最后一个有效元素，首尾互相衔接</p>
<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><ol>
<li>无参初始化，默认大小是16</li>
<li>指定大小初始化，最后会变成大于指定大小的最小2次幂</li>
</ol>
<h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>添加元素实际上<code>addFisrt</code>都是从尾部开始存储的</p>
<p><img src="/posts/7673/image-20230911132141222.png" alt="image-20230911132141222"></p>
<p><code>poll</code>元素时需要注意置为<code>null</code>，便于垃圾回收机制进行对象回收</p>
<h4 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h4><p><strong>为什么容量大小是2次幂呢？</strong></p>
<p>因为比如头插法插入元素实际上是通过<code>head</code>指针来进行插入的，如果不需要扩容，开销是<code>O(1)</code>，而<code>head</code>决定插入位置时，需要对长度取模，如果长度是<code>2</code>的幂次方，那么对长度取模可以用按位与优化</p>
<p><code>elements[head = (head - 1) &amp; (elements.length - 1)] = e;</code>  </p>
<p><strong>初始化是怎么找到最小2次幂的？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>; </span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似<code>Hashmap</code>的初始化，也就是二进制向右移按位或的操作，右移按位或操作的目的在于将二进制的各个位置填上1。这样，得到的数字就是一个<code>2</code>的倍数<code>-1</code>了，比如<code>11111=1+2+4+8+16=31</code>，最后再把这个<code>1</code>补回来就得到比17大的32了</p>
<p><img src="/posts/7673/image-20230911130025333.png" alt="image-20230911130025333"></p>
<p><strong>扩容</strong></p>
<p>和<code>ArrayList</code>先扩容后插入不一样，<code>ArrayDeque</code>的扩容发生在插入之后，即如果<code>head</code>和<code>tail</code>指向同一个位置，说明数组填满了需要扩容，扩容其实就是申请一个<strong>两倍大</strong>的数组，然后将原数组复制过去，因为是循环数组，<code>head</code>和<code>tail</code>不一定就是数组的起点和终点，所以复制分为两步进行，就是依次<strong>复制<code>head</code>的右半部分和左半部分</strong></p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>通过堆实现的容器，堆的底层数据结构就是数组，<strong>保证每次取出的元素都是队列中权值最小的</strong>，大小判断可以用自然顺序也可以传入自定义的<code>Comparator</code></p>
<h5 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h5><p>底层是通过最小堆实现，而最小堆的底层实现就是数组，不允许放入<code>null</code>元素，每个元素都有两个子元素，他们的下标是有规律的，比如父亲的下标为<code>index</code>，则左右孩子的下标分别为<code>index*2+1</code>和<code>index*2+2</code>，反过来孩子是<code>index</code>，父亲就是<code>(index-1)/2</code></p>
<h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><p>可以根据自然顺序进行排序，也可以传入一个自定义排序规则的<code>Comparator</code>，依据业务场景自己设计优先级</p>
<h4 id="核心-3"><a href="#核心-3" class="headerlink" title="核心"></a>核心</h4><p><strong>扩容</strong></p>
<p>类似<code>ArrayLiist</code></p>
<p><strong>插入元素</strong></p>
<p>首先将元素插入到数组最后一位，然后从最后一位的<code>parent</code>开始，自底向上调整，不断将优先级低于当前插入元素的<code>parent</code>向下移动，其实就是复制，然后向上走到<code>parent</code>，直到无法向上走，也就是<code>parent</code>优先级高于插入的元素，这个时候最后调整的<code>parent</code>的值实际上存在两个，因此需要把新的元素插入到最后调整的<code>parent</code>的位置</p>
<p><img src="/posts/7673/image-20230911133708548.png" alt="image-20230911133708548"></p>
<p><strong>删除元素</strong></p>
<p>首先删除的肯定是下标为<code>0</code>的元素，调整是这样的</p>
<ol>
<li>首先将最后一个元素放到<code>0</code>的位置上，记录最后一个元素的值，并将最后一个元素置为<code>null</code>，便于垃圾回收</li>
<li>然后从下标<code>0</code>开始，自顶向下调整，将左右孩子中更优的节移动到<code>parent</code>位置上，往下走到更优的孩子，直到左右孩子都不优于最后一个元素，再把最后一个元素的值赋值给最后一次移动的孩子，其实就是更优的左右孩子的父亲</li>
</ol>
<p><img src="/posts/7673/image-20230911134500410.png" alt="image-20230911134500410"></p>
<h3 id="Collections常用方法"><a href="#Collections常用方法" class="headerlink" title="Collections常用方法"></a>Collections常用方法</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>底层调用的是<code>Arrays.sort()</code>，默认调用<code>DualPivotQuickSort()</code>，所以实际上使用的是双轴快排，使得大多数数组排序时间复杂度控制在<code>O(nlogn)</code></p>
<h4 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h4><p>源码首先检测是不是<code>RandomAccess</code>的，因为<code>ArrayList</code>实现了<code>RandomAccess</code>，表示这个集合支持随机访问，而<code>LinkedList</code>没有实现<code>RandomAccess</code></p>
<p>如果支持<code>RandomAccess</code>或者元素数量少于阈值<code>5000</code>，就用基于下标的二分搜索；否则，用迭代器的二分搜索</p>
<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>洗牌算法，其实就是将 <code>List</code> 集合中的元素进行打乱，一般可以用在抽奖、摇号、洗牌等各个场景中。  </p>
<p>主要有这么两种方式，一种直接传入集合、另外一种还可以传入固定的随机种子这种方式可以控制洗牌范围</p>
<p>源码实现简单来说就是</p>
<ol>
<li>从大到小遍历每个数字</li>
<li>随机生成一个左侧的位置</li>
<li>然后元素置换</li>
</ol>
<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><p>可以把 <code>ArrayList</code> 或者 <code>Linkedlist</code>，从指定的某个位置开始，进行正旋或者逆旋操作</p>
<p><img src="/posts/7673/image-20230914170714697.png" alt="image-20230914170714697"></p>
<p>顺时针旋转2位</p>
<p>源码实现，如果能够随机访问或者元素数量较少，则</p>
<ol>
<li><p>计算取余之后旋转多少，比如size是5，旋转12和旋转2都是2</p>
</li>
<li><p>循环不断将元素放到新的位置上</p>
<blockquote>
<p>比如1 2 3 4 5，旋转2位，就是1到3的位置，3到5的位置，5到2的位置，2到4的位置，4到1的位置，闭环结束</p>
</blockquote>
</li>
</ol>
<p>否则，则把链表分成前后两块，分别倒转，最后合在一起倒转</p>
<blockquote>
<p>比如1 2 3 4 5，旋转2位，以下标2为分界线，1 2 3倒转为3 2 1，4 5倒转为5 4，一起倒转为4 5 1 2 3</p>
</blockquote>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h4><ol>
<li><p>底层的数据结构不同，<code>ArrayList</code>的底层实现是动态数组，支持随机访问，<code>LinkedList</code>基于双向链表实现，只能顺序访问</p>
</li>
<li><p>插入的时间开销不同，可以分为头插、尾插和中间来说明</p>
<ol>
<li>头插：<code>ArrayList</code>需要以拷贝的形式移动数据，并且可能需要扩容，线性开销；而<code>LinkedList</code>只需要用头指针插入即可，<code>O(1)</code>开销</li>
<li>尾插：<code>ArrayList</code>和<code>LinkedList</code>都是<code>O(1)</code>的开销，但是<code>ArrayList</code>可能会扩容，<code>LinkedList</code>则需要实例化对象，相对来说还是<code>ArrayList</code>好</li>
<li>中间：<code>ArrayList</code>需要以拷贝的形式移动数据，线性开销；<code>LinkedList</code>需要遍历找到插入位置，也是线性；但是实际运行<code>ArrayList</code>比<code>LinkedList</code>快不少。我觉得主要原因是双向链表的遍历开销太花时间了，比<code>ArrayList</code>的<code>copy</code>和扩容慢得多</li>
</ol>
<p><code>LinkedList</code>还有一个额外开销就是每次添加元素都要申请堆空间</p>
</li>
<li><p>空间的开销不同，<code>ArrayList</code>空间浪费体现在可能在数组末尾预留一些无用空间，但是<code>trimToSize()</code>可以解决这个问题；而<code>LinkedList</code>存储每一个元素都要额外保存前驱、后继</p>
</li>
<li><p>应用场景不同，<code>ArrayList</code>可以用来模拟堆这样的树结构，<code>LinkedList</code>可以用来模拟栈、队列和双向队列</p>
</li>
</ol>
<h4 id="ArrayDeque-vs-LinkedList"><a href="#ArrayDeque-vs-LinkedList" class="headerlink" title="ArrayDeque vs LinkedList"></a>ArrayDeque vs LinkedList</h4><ol>
<li><code>ArrayDeque</code>底层数据结构是循环数组和双指针，<code>LinkedList</code>就是双向链表</li>
<li><code>ArrayDeque</code>的性能开销主要体现在扩容上，总体比<code>LinkedList</code>（申请堆空间）要好</li>
<li><code>ArrayDeque</code>不需要保存前驱后继，<code>LinkedList</code>需要，在空间性能上也是<code>ArrayDeque</code>好一点</li>
</ol>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ol>
<li><p>for循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"> xx += list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强for循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer itr : list) &#123;</span><br><span class="line"> xx += itr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Iterator遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    xx += next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(integer -&gt; &#123;</span><br><span class="line"> xx += integer;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>stream流遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().forEach(integer -&gt; &#123;</span><br><span class="line"> xx += integer;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-Map详解</title>
    <url>/posts/58446.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>Map</code>在功能上相当于<code>Python</code>中的字典，以键值对<code>&lt;key,value&gt;</code>的形式存储数据，根据实现方式、设计目的的不同有多种<code>Map</code>的实现，包括<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>、<code>WeakHashMap</code></p>
<h3 id="HashMap-Set"><a href="#HashMap-Set" class="headerlink" title="HashMap | Set"></a>HashMap | Set</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>JDK1.8之前，底层实现就是数组+链表，JDK1.8引入红黑树，红黑树和链表都是用于处理哈希冲突的，所以<code>HashMap</code>处理哈希冲突的方法本质上是冲突链表，<code>HashMap</code>是允许<code>key</code>或者<code>value</code>为<code>null</code>的</p>
<ol>
<li><p><code>Node&lt;K,V&gt;[] table</code>，存储节点的数组</p>
</li>
<li><p><code>size</code>，元素数量，实际存储了多少元素</p>
</li>
<li><p><code>threshold</code>，阈值，默认是<code>16</code></p>
</li>
<li><p><code>loadFactor</code>，负载因子，默认是<code>0.75</code></p>
<p>当<code>size&gt;=threshold*loadFactor</code>时扩容</p>
</li>
</ol>
<p><img src="/posts/58446/image-20230914194831073.png" alt="image-20230914194831073"></p>
<h5 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h5><p>或者说 为什么<code>HashMap</code>的扩容不像<code>ArrayList</code>那样是装不下了才扩容</p>
<p>其实就是负载因子为什么默认是<code>0.75</code>，而不是<code>1</code>，其实这是时间和空间的平衡</p>
<p>首先，明确负载因子就是用来决定扩容阈值的，而扩容是解决哈希冲突的有效方法，因此可以认为负载因子比较低，扩容更容易发生，哈希冲突的概率也会有所下降，但是不可否认的是，负载因子越低，数组的空间利用率也就会越低。</p>
<p>综上所述，<code>0.75</code>就是同时兼顾哈希冲突概率和空间利用率的理想值</p>
<h5 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h5><p>原始计算出来的哈希值的范围是很大的，冲突基本不会发生，但是内存放不下，因此需要根据数组的长度来做取模运算，得到的余数作为存储位置，对于取模运算，如果除数是2的幂次方，则取模运算等价于<code>(length-1) &amp; hash</code>，采用二进制的按位与操作比取模运算开销小，所以<code>HashMap</code>的大小是<code>2</code>的幂次方，扩容也是两倍来扩容</p>
<h5 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h5><p>如果入参设置了初始容量，那么需要找到比这个初始容量大或者相等的最小<code>2</code>的幂次方，比如输入<code>17</code>，那就应该是<code>32</code></p>
<p>源码中对这个计算有所优化，比较重要的是二进制向右移按位或的操作，右移按位或操作的目的在于将二进制的各个位置填上<code>1</code>，这样，得到的数字就是一个2的幂次-1了，比如1111=1+2+4+8=15，最后再把这个1补回来就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>; </span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/58446/image-20230911130025333.png" alt="image-20230911130025333"></p>
<h5 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h5><p>扰动函数的目的在于优化散列的效果</p>
<p>一般来说，哈希值是<code>int</code>型的，其表示的范围很大，理论上发生哈希冲突的概率是非常小的，但是我们不可能用这么大的数组表示哈希表，所以默认大小是<code>16</code>，那就需要进行取余操作来得到下标，而对<code>2</code>的幂次方取余，可以优化为<code>length-1</code>的按位与操作，那么<code>16-1=15</code>的二进制表示是<code>001111</code>，如果直接按位与，那么只有哈希值的低位发挥作用（高位都是<code>0</code>嘛），按位与操作是不太好改动的，因此引入扰动函数其实就是对将原哈希值的高<code>16</code>位和低<code>16</code>位混合起来，异或后能够保留高位的信息，再按位与能够增大随机性</p>
<p><img src="/posts/58446/image-20230914202509838.png" alt="image-20230914202509838"></p>
<h5 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h5><p><strong>迁移数据不需要重新计算哈希值</strong></p>
<p>数据迁移计算元素新位置时，直接看哈希值中新发挥作用的位是不是<code>0</code>，如果为<code>0</code>，则位置不改变，否则右移原始容量的位置</p>
<p>这是因为比如我们正常计算位置，是用<code>hash</code>值和<code>length-1</code>做按位与嘛，而对于<code>2</code>的幂次方来说，<code>length-1</code>，其实就是低位全是<code>1</code>，高位全是<code>0</code>，扩大两倍，只不过是最近的高位从<code>0</code>变成了<code>1</code>，也就是说，对新的位置的计算只需要考虑这个多出来的<code>1</code>，而这个多出来的<code>1</code>反映到哈希值中，就是哈希值多了一位对计算下标有影响的位，这一位如果是<code>0</code>，说明这个多出来的<code>1</code>没有影响，如果是<code>1</code>，说明有影响，且影响刚刚好就是右移原始容量这么多位置</p>
<p>比如原本是<code>16</code>，<code>16-1=15=1111</code>，现在扩容为<code>32</code>，<code>32-1=31=11111</code>，如果哈希值中多出来的这一位对应<code>2^4</code>是<code>1</code>，那么就右移<code>2^4=16</code>，否则不变。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><ol>
<li><p>首先计算哈希值，同时进行扰动操作</p>
<p><code>(key == null) ? 0 : (h= key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></p>
</li>
<li><p>如果数组为<code>null</code>或者长度为<code>0</code>，则需要初始化</p>
</li>
<li><p>根据哈希值计算下标，如果下标没有存数据，直接存，否则转4</p>
<p><code>tab[i = (n - 1) &amp; hash])</code>  </p>
</li>
<li><p>根据这个地方是链表还是红黑树做不同的插入操作</p>
<p>需要注意链表插入的时候，如果链表长度大于<code>8</code>，需要考虑转换为红黑树</p>
</li>
<li><p>如果元素数量超过负载时，进行扩容</p>
</li>
</ol>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><ol>
<li><p>结合扰动函数计算哈希值</p>
<p><code>(key == null) ? 0 : (h= key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></p>
</li>
<li><p><code>table</code>数组是否为空，为空则结束，否则转3</p>
</li>
<li><p>计算下标</p>
<p><code>tab[i = (n - 1) &amp; hash])</code>  </p>
</li>
<li><p>然后就是依据红黑树还是链表进行查找 | 遍历操作了</p>
</li>
</ol>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>除了删除<code>key</code>对应项外，还需要返回删除的<code>key</code>对应的<code>value</code></p>
<p>JDK 1.7底层是数组+链表，所以<code>remove</code>方法的实现如下</p>
<ol>
<li><p>首先根据<code>key</code>计算在数组中的下标</p>
</li>
<li><p>然后遍历链表，根据<code>key</code>和哈希值找到目标节点</p>
</li>
<li><p>判断是否是头结点</p>
<ul>
<li>不是，直接按照链表的方式进行移除</li>
</ul>
</li>
</ol>
<ul>
<li>是，将下一个节点放到数组中，相当于更新链表头结点</li>
</ul>
<ol>
<li>返回<code>value</code></li>
</ol>
<p>JDK 1.8底层是数组+链表和红黑树，区别主要在于需要根据底层数据结构的不同做不同处理</p>
<ol>
<li>首先根据<code>key</code>计算在数组中的下标，得到该位置的节点</li>
<li>然后判断节点<code>p</code>是不是就是要删除的节点<ol>
<li>是，暂存需要被删除的节点</li>
<li>不是，看存储结构是红黑树还是链表分别遍历，寻找并暂存需要被删除的节点</li>
</ol>
</li>
<li>删除找到的节点</li>
<li>返回被删除的节点</li>
</ol>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>性能由高到低</p>
<ol>
<li><p>迭代器 直接获取<code>EntrySet</code>，通过<code>hasNext</code>进行遍历</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强<code>for</code>循环获取<code>EntrySet</code> </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述1 2底层生成的代码实际上一致</p>
</blockquote>
</li>
<li><p><code>Stream API</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">      System.out.println(entry.getKey());</span><br><span class="line">      System.out.println(entry.getValue());</span><br><span class="line">&#125;);<span class="comment">// 以单线程版本 比较性能</span></span><br><span class="line"></span><br><span class="line">map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">  <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;);<span class="comment">// 多线程 性能必定最好</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器 获取<code>KeySet</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强<code>for</code>循环获取<code>KeySet</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述4 5生成的代码一致</p>
</blockquote>
</li>
<li><p><code>lambda:forEach</code>遍历<code>key</code>和<code>value</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>为什么Map.Entry比KeySet快呢？</strong></p>
<p>因为获取<code>KeySet</code>返回<code>key</code>遍历了一遍，通过<code>map.get(key)</code>获取所有的<code>value</code>又要去查一遍</p>
<p>而<code>Map.entry</code>是一次查询就保存了下来，不需要第二次遍历</p>
<p><strong>安全性</strong></p>
<p>迭代器方式可以边遍历，边删除</p>
<p>增强<code>for</code>循环、<code>lambda</code>不行，<code>lambda</code>可以先使用<code>removeIf</code>进行删除，<code>stream</code>可以用<code>filter</code>进行过滤，再遍历</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code>实际上就是对<code>HashMap</code>做了一层包装，也就是说<code>HashSet</code>内部持有一个<code>HashMap</code>，对<code>HashSet</code>的方法调用基本都会转为对<code>HashMap</code>的方法调用，但是需要注意的是，<code>HashSet</code>的去重功能依赖于<code>HashMap</code>的<code>key</code>，所以<code>HashSet</code>的<code>value</code>在<code>HashMap</code>中是<code>key</code>，<code>value</code>则是同一个<code>final static</code>的<code>Object</code>对象</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>额外设置<code>LinkedList</code>进行有序性功能增强的<code>HashMap</code>，自然也是没有进行多线程安全控制的，具体来讲就是通过双向链表将所有<code>entry</code>进行连接，保证元素的迭代顺序和插入的顺序一致，同时遍历时间只与<code>entry</code>的数目相关，和<code>table</code>的大小无关</p>
<p><code>Entry</code>实际上是<code>Node</code>的子类，并扩展了<code>before</code>和<code>after</code>两个指针用于维护双向链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">      Entry&lt;K,V&gt; before, after;</span><br><span class="line">      Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/58446/image-20230915190459398.png" alt="image-20230915190459398"></p>
<h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><ol>
<li>从哈希表角度看，冲突链表尾插法</li>
<li>从双向链表角度看，插入新元素，是插入到双向链表的尾部</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/58446/image-20230915210503389.png" alt="image-20230915210503389"></p>
<h4 id="FIFO缓存"><a href="#FIFO缓存" class="headerlink" title="FIFO缓存"></a>FIFO缓存</h4><p><code>LinkedHashMap</code>提供一个叫<code>removeEldestEntry</code>的方法用来设置是否要移除最老的项，也就是最早插入的项，只要继承<code>LinkedHashMap</code>并将其重写比如元素数量超过多少就返回<code>true</code>，这样<code>LinkedHashMap</code>会自动删除<code>head</code>指向的元素，实际上就是最先插入的元素，这样就能实现<code>FIFO</code>的缓存策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">  <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><p>在FIFO实现的基础上，只要将<code>accessOrder</code>设置为<code>true</code>，那么访问一个节点后，<code>afterNodeAccess</code>方法就会自动将该节点移到链表的最后，相当于就是最新插入的项，这样就实现了<code>LRU</code>的删除最久未使用的策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">  <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">        a.before = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        last = b;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = p;</span><br><span class="line">    ++modCount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p><code>LinkedHashSet</code>也是对<code>LinkedHashMap</code>进行了一层包装，<code>LinkedHashSet</code>持有一个<code>LinkedHashMap</code>的成员变量，对<code>LinkedHashSet</code>的方法调用实际上就是对<code>LinkedHashMap</code>的方法的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125;</span><br><span class="line"><span class="comment">// 继承了HashSet</span></span><br></pre></td></tr></table></figure>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p><code>Weak</code>的意思就是<code>HashMap</code>中对<code>key</code>的引用是一种弱引用，弱引用的特性在于不管内存空间是否足够，只要垃圾回收器扫描到仅有弱引用指向的对象，就会立马将其回收，所以<code>WeakHashMap</code>可以用来做缓存，由垃圾回收器管理缓存对象的有效时间，缓存命中可以提高访问效率，<code>miss</code>也不会报错，再去查就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  V value;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">  Entry&lt;K,V&gt; next;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不存在<code>WeakHashMap</code>，但是可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</span><br><span class="line">        new WeakHashMap&lt;Object, Boolean&gt;());</span><br></pre></td></tr></table></figure>
<p>封装一个<code>WeakHashSet</code></p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p><code>TreeMap</code>底层用红黑树实现，使得大部分方法的时间开销都是<code>O(logn)</code>，并且红黑树本身是一种二叉搜索树，自然能够维护顺序，该顺序是基于<code>key</code>的自然顺序或者传入<code>Comparator</code>的自定义顺序</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</p>
<p><strong>特点</strong></p>
<ol>
<li>节点要么是红，要么是黑</li>
<li>根节点是黑，所有叶子节点（<code>Null</code>）是黑的</li>
<li>红色节点不能连续出现</li>
<li>对于每个节点，从该节点到叶子节点，黑色节点的个数一致，所以新插入的节点必须是红色</li>
</ol>
<p><img src="/posts/58446/image-20230915195709110.png" alt="image-20230915195709110"></p>
<p><strong>调整</strong></p>
<p>左旋、右旋、改颜色，左旋就是将<code>x</code>的右子树逆时针旋转，将右孩子节点变为<code>x</code>的父节点，<code>x</code>变为左孩子，然后还涉及到一些引用的修改，右旋就是反过来</p>
<p><strong>节点后继</strong></p>
<p>节点后继就是树中大于t的最小元素</p>
<ol>
<li>如果有右子树，就是右子树的最小元素</li>
<li>没有右子树，就是祖先节点中第一个向左走的节点</li>
</ol>
<p><img src="/posts/58446/image-20230915200343434.png" alt="image-20230915200343434"></p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p><code>TreeSet</code>也是对<code>TreeMap</code>进行包装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-String类型详解</title>
    <url>/posts/47305.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><code>String</code>在使用时经常会认为是一种基本数据类型，但实际上<code>String</code>是引用类型，并且比较特殊，可以通过<code>“”</code>或者<code>new</code>的方式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h3><ol>
<li>形式上：字符是单引号引起来的单个字符，字符串则是双引号引起来的若干个字符</li>
<li>含义上：字符相当于<code>ASCII</code>值对应的整数，可以参与表达式运算，比如我们经常用到的字符-‘a’得到字符在数组中从0开始的下标；字符串则表示字符串在内存中的存储地址</li>
<li>占据内存大小：字符占据固定2个字节的内存空间，字符串根据字符串长度占据若干字节[<code>String</code>的底层存储改为了<code>byte</code>]</li>
</ol>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><h4 id="如何保证String的不可变"><a href="#如何保证String的不可变" class="headerlink" title="如何保证String的不可变"></a>如何保证String的不可变</h4><ol>
<li><code>String</code>类被<code>final</code>修饰，不能被继承，无法通过继承破坏其不变性</li>
<li>内部使用<code>char</code> | <code>byte</code>数组存储数据，数组也是<code>final</code>的，无法改变指向</li>
<li><code>String</code>类没有提供任何方法能够获取数组或者修改数组内容</li>
</ol>
<p>但是，实际上通过反射机制是可以破坏<code>String</code>的不变性的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;    <span class="comment">//实例化一个String类对象</span></span><br><span class="line">Class&lt;?&gt; cls = String.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">value.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">byte</span>[] arr = (<span class="type">byte</span>[]) value.get(str); <span class="comment">//反射获取字节数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">109</span>; <span class="comment">// 修改值</span></span><br><span class="line">System.out.println(str); <span class="comment">// mello</span></span><br></pre></td></tr></table></figure>
<h4 id="为什么需要保证String的不可变"><a href="#为什么需要保证String的不可变" class="headerlink" title="为什么需要保证String的不可变"></a>为什么需要保证String的不可变</h4><ol>
<li><strong>安全性</strong>：<code>String</code>类型是频繁使用的类型，经常会用于存储一些敏感信息，比如用户名、密码等等，如果<code>String</code>可变，那么攻击者可能先使用合法的数据通过安全检查，然后修改对象进行一些危险操作</li>
<li><strong>节约内存消耗</strong>：只要一个<code>String</code>对象创建过了[引号]，那么内容相同的字符串可以使用字符串常量池中的同一个对象，避免创建多个重复字符串对象，如果<code>String</code>对象可变，那么一个地方变，就会导致其他地方也会发生变化，那就无法支持常量池机制了</li>
<li><strong>线程安全</strong>：<code>String</code>的不可变使其天生具备线程安全的性质，如果线程尝试修改<code>String</code>，则会创建一个新的<code>String</code>对象，不存在并发修改的问题，因此可以在不同的线程中使用</li>
<li><strong>节省计算开销</strong>：哈希表中一般都用<code>String</code>作为<code>key</code>，而用<code>String</code>作为<code>key</code>，哈希值只需要计算一次就可以缓存起来，下次可以直接拿缓存值来计算下标</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构其实就是一个数组，只是数组类型由<code>char[]</code>改为了<code>byte[]</code></p>
<p><strong>JDK9为什么要将String的底层实现由char[]改为byte[]</strong></p>
<p>这是因为每个字符<code>char</code>由2个字节组成，而开发环境中经常使用的是<code>Latin1</code>编码中的字符，只需要一个字节就可以存储，如果用<code>char</code>数组来存储就有一半的存储空间被浪费了，如果用<code>byte</code>数组来存储就不会浪费。但是，对于一些不属于<code>Latin1</code>编码的字符，比如中文，<code>String</code>同样会将其转换为字节存储到字节数组中，只是编码不是<code>Latin1</code>，而是<code>UTF16</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (COMPACT_STRINGS) &#123; <span class="comment">// 默认为true 先用Latin1编码转换为字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] val = StringLatin1.toBytes(codePoints, offset, count);</span><br><span class="line">    <span class="keyword">if</span> (val != <span class="literal">null</span>) &#123; <span class="comment">// 转换成功</span></span><br><span class="line">        <span class="built_in">this</span>.coder = LATIN1;</span><br><span class="line">        <span class="built_in">this</span>.value = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.coder = UTF16; <span class="comment">// 转换失败 用UTF16编码进行转换</span></span><br><span class="line"><span class="built_in">this</span>.value = StringUTF16.toBytes(codePoints, offset, count);</span><br></pre></td></tr></table></figure>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>字符串常量池和缓冲池差不多，存储了两种对象</p>
<ol>
<li>字符串</li>
<li>堆中字符串对象的引用</li>
</ol>
<p>在JDK1.8之后，包括1.8，字符串常量池逻辑上存储在虚拟机的方法区[元空间和堆共同实现]中，物理上存储在堆中</p>
<h3 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String StringBuffer StringBuilder"></a>String StringBuffer StringBuilder</h3><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ol>
<li><p><strong>不可变性</strong></p>
<p><code>String</code>不可变，我们修改<code>String</code>会产生一个新的String对象，然后将引用指向它</p>
<p><code>StringBuffer</code>和<code>StringBuilder</code>可变</p>
</li>
<li><p><strong>线程安全</strong></p>
<p><code>String</code> 不可变，天生是线程安全的</p>
<p><code>StringBuffer</code> 是线程安全的，内部使用 <code>synchronized</code> 进行同步</p>
<p><code>StringBuilder</code> 不是线程安全的</p>
</li>
<li><p><strong>应用场景</strong></p>
<p>字符串一般不会发生变化，用<code>String</code>即可</p>
<p>如果业务逻辑涉及到大量对字符串的修改，比如拼接字符串，但是只需要单线程，那么用<code>StringBuilder</code></p>
<p>如果需要并发访问，则需要使用<code>StringBuffer</code>，但是运行速度会变慢，因为会检查是否拥有锁</p>
</li>
</ol>
<h4 id="StringBuilder和StringBuffer的底层实现"><a href="#StringBuilder和StringBuffer的底层实现" class="headerlink" title="StringBuilder和StringBuffer的底层实现"></a>StringBuilder和StringBuffer的底层实现</h4><p>这两个实际上都是<code>AbstractStringBuilder</code>的子类，存储了一个<code>byte</code>类型的数组，所以添加元素时可能会扩容，扩容的大小默认是2倍+2，然后使用<code>Arrays.cppyOf</code>方法进行复制</p>
<p>比较重要的还有一个<code>toString</code>方法返回一个<code>String</code>，内部实际上就是根据编码类型，是<code>Latin1</code>还是<code>UTF16</code>，调用<code>newString()</code>方法，最后调用的实际上是<code>String</code>接收<code>byte[]</code>数组的构造函数，创建了一个堆中的<code>String</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">  <span class="keyword">return</span> isLatin1() ? StringLatin1.newString(value, <span class="number">0</span>, count)</span><br><span class="line">                    : StringUTF16.newString(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">newString</span><span class="params">(<span class="type">byte</span>[] val, <span class="type">int</span> index, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(val, index, index + len),</span><br><span class="line">                    LATIN1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StringBuffer</code>相对于<code>StringBuilder</code>就是存在并发控制的方法添加了<code>synchronized</code>关键字实现线程安全，比如扩容方法，<code>trimToSize</code>方法</p>
<h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>该方法是<code>String</code>对象的方法，用于保证相同内容的字符串常量引用同一个常量池中的对象</p>
<p><strong>如果字符串常量池已经包含一个等于(通过equals方法比较)此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中对象的引用地址）添加（或者叫复制）到字符串常量池中并返回，这么做是为了节约堆空间，毕竟都在堆中。</strong></p>
<blockquote>
<p>比如我们用<code>new</code>的方法创建两个内容相同的<code>String</code>对象，那么他们是不相等的，而如果我们调用<code>intern()</code>返回的字符串对象则和原来的字符串对象是一个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false new创建不一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);  <span class="comment">// true 双引号创建一样</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s5 &amp;&amp; s5 == s6);  <span class="comment">// true 都是常量池中的&quot;aaa&quot;</span></span><br><span class="line">System.out.println(s5 == s1) <span class="comment">// false 一个是常量池 一个是堆</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// false str1 str2指向堆中不同对象</span></span><br><span class="line">System.out.println(str1 == str2.intern()); <span class="comment">// false str1指向堆中对象 str2.intern()指向字符串常量池中&quot;ab&quot;</span></span><br><span class="line">System.out.println(str1.intern() == str2.intern()); <span class="comment">// str1 str2发现ab在常量池中有，就把引用返回 两个都是指向字符串常量池的ab 自然相等</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">// false 堆和字符串常量池</span></span><br><span class="line">System.out.println(str1.intern() == str3); <span class="comment">// true str1.intern()和str3都指向字符串常量池中的&quot;ab&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作优化"><a href="#操作优化" class="headerlink" title="操作优化"></a>操作优化</h3><ol>
<li><p>如果拼接的字符串都是直接量，编译器会优化为一个完整的字符串</p>
<blockquote>
<p><code>String s1 = &quot;a&quot; + &quot;b&quot;</code>，编译器会优化为<code>String s1 = &quot;ab&quot;</code>，所以不会在常量池中尝试创建”a”和”b”</p>
</blockquote>
</li>
<li><p>如果存在变量，会使用<code>StringBuilder</code>进行优化，创建一个<code>StringBuilder</code>对象，调用其<code>append</code>方法</p>
<p><strong>既然已经使用StringBuilder进行优化了，为什么多次拼接操作时，直接使用StringBuilder比使用String快？</strong></p>
<p>因为每次进行<code>+=</code>操作，虽然会进行优化，但是都得创建一个<code>StringBuilder</code>对象，调用<code>append</code>方法，再<code>toString</code>返回<code>String</code>对象</p>
</li>
</ol>
<h3 id="语句分析"><a href="#语句分析" class="headerlink" title="语句分析"></a>语句分析</h3><p><strong>intern()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>首先尝试创建<code>“1”</code>，最后s3是一个堆中的<code>String</code>对象，值是<code>11</code></p>
</li>
<li><p>在字符串常量池中没有<code>11</code>，就会创建一个指向堆中<code>s3</code>的引用，代表字符串<code>11</code></p>
</li>
<li><p><code>s4</code>指向字符串常量池中的<code>11</code>，其实就是指向堆中的<code>s3</code></p>
</li>
<li><p>自然<code>s3</code>和<code>s4</code>相等</p>
</li>
</ol>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">s3.intern();</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>s3</code>和<code>s4</code>不相等</p>
<hr>
<p><strong>java原生字符串常量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">System.out.println(str.intern() == str); <span class="comment">// false 因为java已经在字符串常量池中就有的 intern返回的是字符串常量池的引用 str指向的是堆中的对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">System.out.println(str1.intern() == str1); <span class="comment">// true 计算机软件是没有的，所以intern就是指向堆中的计算机软件，str1也是指向堆中的计算机软件</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ja&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;va&quot;</span>);</span><br><span class="line">System.out.println(test.intern() == test); <span class="comment">//false intern返回的是常量池中的java test是堆中的对象</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>String创建了多少对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“a”) + <span class="keyword">new</span> <span class="title class_">String</span>(“b”);</span><br><span class="line">s2.intern();</span><br></pre></td></tr></table></figure>
<ol>
<li><code>&quot;a&quot; &quot;b&quot;</code>会尝试在字符串常量池中创建对象，最多创建2个</li>
<li><code>new String</code>一个<code>a</code>和<code>b</code>，2个</li>
<li>涉及到<code>String</code>对象的拼接，需要用到<code>StringBuilder</code>，1个</li>
<li><code>StringBuilder</code>的<code>toString()</code>方法会新建一个<code>String</code>，并且没有使用引号（<code>byte</code>数组），不会尝试在字符串常量池中创建对象，1个</li>
<li><code>intern()</code>: 字符串常量池如果有<code>&quot;ab&quot;</code>，就返回这个<code>ab</code>，否则返回堆中<code>&quot;ab&quot;</code>对象的引用，不管咋样，都没有创建对象</li>
</ol>
<p>总共创建[4,6]个对象</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;A&quot;</span>+<span class="string">&quot;B&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>没有进行优化，所以<code>&quot;A&quot; | &quot;B&quot; | &quot;AB&quot;</code>： 如果字符串常量池都没有，最多创建三个</p>
</li>
<li><p><code>new</code>创建1个</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-synchronized详解</title>
    <url>/posts/26243.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>synchronized</code>是java内存模型提供的一种实现互斥同步的关键字， <code>synchronized</code> 可以保证在同一时刻，只有一个线程可以执行某个方法或者某个代码块（方法或者代码块中存在共享数据的操作，实现原子性以及有序性），同时<code>synchronized</code>还具备另外一个重要的作用，就是可保证一个线程对共享变量的修改(主要是共享数据的变化)被其他线程所看到（保证可见性）。</p>
<ol>
<li>这是一种非公平锁 | 排它锁</li>
<li>方法不管执行完毕还是异常，都会释放锁</li>
<li>作用在类实例对象 或者 类Class对象，不同类实例不会互斥， 类实例和类Class对象也不会互斥</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>synchronized</code>可以作用在</p>
<ol>
<li>静态方法，锁的对象是类Class对象</li>
<li>非静态方法，锁的对象是类实例对象</li>
<li>代码块，锁的对象可能是类实例对象，也可能是类Class对象</li>
</ol>
<p>具体示例见<a href="./4986.html">线程安全实践</a>，需要额外注意</p>
<ol>
<li>锁对象不能为空，因为锁的信息都保存在对象头里</li>
<li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li>
<li>避免死锁，需要能够破坏循环等待条件</li>
<li>能用java.util.concurrent包中的各种各样的类开发就不要用<code>ReentrantLock</code>或者<code>synchronized</code>关键字。实在不行，只要不需要使用<code>ReentrantLock</code>的高级功能，就可以使用<code>synchronized</code>，因为代码量少，避免出错</li>
</ol>
<p><strong>双重检验锁实现单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取实例的方法内部需要双重判断和synchronized加锁。</strong></p>
<p>如果只有一层判断会怎样，假设内部不检验，单线程不会出现问题，但是多线程有问题，假设现在有线程1和线程2：</p>
<p>线程1和线程2都发现没有实例化，都经过了第一层检测，然后线程1获得锁，创建了一个实例，没问题，释放锁，线程2获取锁，又创建了一个实例，单例就被破坏了</p>
<p>所以内部需要再加一层判断，这样线程2即便获得锁也不会重复创建</p>
<p>那么能不能把锁加在外面呢？</p>
<p>理论上锁加在外面肯定可以避免这种问题，但是锁加在外面，每次获取实例即便已经创建好了也得申请锁，没有必要</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>底层实际上使用了<code>monitorenter</code>和<code>monitorexit</code>指令获取和释放与对象绑定的一个<code>monitor</code>，而<code>monitor</code>在同一时刻只能被一个线程所获取</p>
<p><strong>执行monitorenter</strong></p>
<ol>
<li>monitor计数器为0，意味着目前没有被任何线程持有，当前申请的线程可以获取，计数器+1</li>
<li>monitor计数器&gt;0，说明已经被某线程持有了<ol>
<li>如果持有锁的线程恰好还是当前申请的线程，那么就是重入锁，计数器+1</li>
<li>否则，就需要等待</li>
</ol>
</li>
</ol>
<p><strong>执行monitorexit</strong></p>
<p>释放monitor的所有权，并将计数器-1，如果-1之后不是0，那么说明是重入的，当前线程还是持有该monitor，不断释放直到计数器变为0才是真正的释放锁。</p>
<p><img src="/posts/26243/image-20230921142331437.png" alt="image-20230921142331437"></p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>内存屏障能够保证同步代码块如果修改了共享变量，必须在释放锁前刷新到主存，如果需要用到共享变量，那么也需要全部强制从主存中读取共享变量。</p>
<p><img src="/posts/26243/image-20230921150646240.png" alt="image-20230921150646240"></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>与<code>synchronized</code>直接相关的happens-before规则为</p>
<p>监视器锁规则：对一个监视器锁的解锁，happens- before于随后对这个监视器锁的加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MonitorTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorExam1</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;  <span class="comment">//1</span></span><br><span class="line">        a++;                             <span class="comment">//2</span></span><br><span class="line">    &#125;                                    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;  <span class="comment">//4</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;                       <span class="comment">//5</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;                                    <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MonitorExam1</span> <span class="variable">me1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MonitorExam1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; me1.writer());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; me1.reader());</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start(); <span class="comment">// 输出1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// t2.start(); t1.start() 则输出0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程t1执行<code>writer()</code>方法，随后线程t2执行<code>read()</code>方法。根据happens-before规则可以得到如下happens-before关系：</p>
<ol>
<li>根据程序次序规则，1→2,2→3；4→5，5→6，并且先执行t1再执行t2</li>
<li>根据监视器锁规则，必须先释放锁，才能获取锁</li>
</ol>
<p><img src="/posts/26243/image-20230921145008245.png" alt="image-20230921145008245"></p>
<p>底层实际上还是基于<code>monitorenter</code>和<code>monitorexit</code>的内存屏障来禁止指令重排</p>
<p><img src="/posts/26243/image-20230921145649150.png" alt="image-20230921145649150"></p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>见<a href="./38827.html">可重入 vs 非可重入锁</a></p>
<p>原理很简单，就是计数器+1,-1的操作</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="优化目的"><a href="#优化目的" class="headerlink" title="优化目的"></a>优化目的</h4><p>因为<code>synchronized</code>本身需要底层<code>monitorenter</code>和<code>monitorexit</code>获取和释放监视器锁，而监视器锁又是基于操作系统的mutex lock实现的，需要系统调用，涉及到用户态内核态的切换，并且可能阻塞和唤醒线程，开销比较大</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>减少不必要的紧连在一起的加锁、释放锁操作，将多个连续的锁扩展成一个范围更大的锁</p>
<p><code>StringBuffer</code>可以认为是一种线程安全的<code>String</code>，线程安全是通过<code>synchronized</code>关键字实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码执行了三次<code>append()</code>操作，每次都需要加锁释放锁，JVM就会将锁进行粗化，将同步的范围扩展到这一系列操作的外围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">test04</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">  	<span class="comment">// 类似这里加锁</span></span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">  	<span class="comment">// 这里释放锁</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析：JVM会判断在一段程序中的同步明显不会逃逸出去而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步，就会进行锁消除。</p>
<p>主要是对Java原生API进行优化，因为在我们自己的程序中，什么时候需要进行同步肯定预先有所考虑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">  	<span class="comment">// 下列变量都是方法的局部变量 分配在栈上</span></span><br><span class="line">  	<span class="comment">// 不可能被别的线程访问到 自然不需要锁</span></span><br><span class="line">  	<span class="comment">// JVM就会对其进行锁消除优化</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    stringBuffer.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p>java中的对象，不管是Class对象还是类实例对象，在内存中都是按照对象头、实例数据以及对齐填充三个部分进行布局的，对象头中包括MarkWord（哈希值、GC年龄分代、锁状态标记、线程持有的锁、偏向线程ID）和类型指针（指向元空间中类对象所属类的元数据信息），而加锁实际上就是对同一个对象的对象头中的MarkWord中的字段进行CAS操作。</p>
<p>锁升级的优化，归根结底在于尽量避免一上来就是<strong><a href="# 优化目的">重量级锁</a></strong></p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>在进入同步块之前，会先尝试加上偏向锁，在对象头中标记为当前线程ID，这样当一个线程多次进入同步块，就无需重复获取锁，甚至连CAS操作都不需要，极大减少了性能开销，因此偏向锁适用于一个线程多次获取一个锁的情况，实际上大多数业务场景虽然进行了同步，但是大部分都是同一个线程反复获取锁</p>
<ol>
<li>偏向锁标志是未偏向状态，使用 CAS 将 MarkWord 中的线程ID设置为自己的线程ID：<ol>
<li>成功，则获取偏向锁成功。</li>
<li>失败，则进行锁升级。</li>
</ol>
</li>
<li>偏向锁标志是已偏向状态<ol>
<li>MarkWord 中的线程 ID 是自己的线程 ID，成功获取锁</li>
<li>MarkWord 中的线程 ID 不是自己的线程 ID，需要进行锁升级</li>
</ol>
</li>
</ol>
<p>锁升级需要进行偏向锁的撤销</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>轻量体现在仅仅通过CAS操作获取锁</p>
<p>如果有其他线程试图获取锁，那么就会从偏向锁升级为自旋锁 也就是 轻量级锁，自旋锁其实就是进行一定时间的自旋尝试，也就是忙等待，直到获取到锁或者达到自旋上限。这样可以避免线程进入阻塞状态，减少线程切换的开销，这种锁适用于同步块执行体比较简单的情况，这样能够很快从自旋状态恢复</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>如果自旋尝试失败，就会升级为重量级锁，等待的线程会进入阻塞状态，也就是原本的<code>synchronized</code>，此时需要通过操作系统的mutex lock实现锁的获取和释放，因为涉及到内核态和用户态的切换，性能较低</p>
<h3 id="synchronized-vs-ReentrantLock"><a href="#synchronized-vs-ReentrantLock" class="headerlink" title="synchronized vs ReentrantLock"></a>synchronized vs ReentrantLock</h3><p><code>ReentrantLock</code>原理解析见<a href>ReentrantLock详解</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>synchronized</th>
<th>lock</th>
</tr>
</thead>
<tbody>
<tr>
<td>锁的释放和获取</td>
<td>时机单一</td>
<td>通过<code>lock()</code>和<code>unlock()</code>方法灵活获取和释放锁，但是编码比较复杂</td>
</tr>
<tr>
<td>唤醒线程</td>
<td>唤醒所有等待的线程</td>
<td>结合<code>Condition</code>有选择的唤醒线程</td>
</tr>
<tr>
<td>中断等待线程</td>
<td>不支持</td>
<td>能够设置超时时间，能够响应等待线程的中断操作<code>lockInterruptibly()</code></td>
</tr>
<tr>
<td>公平 \</td>
<td>非公平</td>
<td>只支持非公平锁</td>
<td>支持公平和非公平</td>
</tr>
</tbody>
</table>
</div>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><p><strong><code>Synchronized</code>使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?</strong></p>
<ol>
<li>在满足业务需求的情况下，缩小锁的范围，比如单例的双重检验机制</li>
<li>将连续的申请锁和释放锁的操作扩展为一次锁获取和释放</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-volatile详解</title>
    <url>/posts/35561.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>synchronized</code>能够保证并发的原子性、有序性和可见性，但是可能会升级为重量级锁，对系统性能影响较大。因此java内存模型又额外提供了<code>volatile</code>关键字，旨在确保有序性和可见性，由于不会涉及线程阻塞和唤醒，不会发生用户态内核态切换，因此性能更好。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>volatile</code>只能对变量进行声明，确保对该变量的读写操作不会被重排序，并且满足可见性，简单示例见<a href="./4986.html">线程安全实践</a>，如下是双重检验实现单例模式中<code>volatile</code>的应用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将单例声明为<code>volatile</code>的意义在于：<code>new</code>一个实例分为以下3步</p>
<ol>
<li>分配内存空间</li>
<li>初始化实例对象</li>
<li>将引用指向这个内存空间</li>
</ol>
<p>2和3的顺序可能会发生变化，变为1→3→2，多线程下会发生问题</p>
<p>比如线程1执行完1和3 线程2发现引用不为空，返回引用，但是此时单例对象实际上还没有初始化，因此需要用<code>volatile</code>防止<code>new</code>实例的三个指令的重排序</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>volatile</code>底层实现可见性和有序性的关键在于内存屏障，通过对<code>volatile</code>变量的读写操作添加内存屏障，写操作后添加写屏障，读操作前添加读屏障，保证有序性和可见性</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x000000000295158c</span>: lock cmpxchg %rdi,(%rdx)  <span class="comment">//在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span></span><br></pre></td></tr></table></figure>
<p>插入内存屏障保证可见性，内存屏障能够使得对共享变量的更新，马上同步到主存，同时由于操作系统的MESI协议，会将其他处理器中缓存了该内存地址的数据标记为失效状态，这样，如果别的线程需要对该共享变量进行读取，并且该线程的处理器缓存命中了，就会因为已经被标记为无效，所以读取的就必须是主存的数据</p>
<p><strong>缓存一致性</strong></p>
<p>CPU读取内存中的数据是以cache line为最小单位的，也就是缓存行，一般是64字节。缓存一致性协议就是保证多核心的缓存数据的一致，一般需要做到</p>
<ol>
<li>写传播：某个CPU的缓存数据更新时，需要传播给别的核心</li>
<li>事务串行化：若干个CPU对数据的操作的实际执行顺序，必须在所有核心看来都是一样的</li>
</ol>
<p>具体见<a href>CPU缓存一致性</a></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h5 id="开发视角"><a href="#开发视角" class="headerlink" title="开发视角"></a>开发视角</h5><p><code>volatile</code>的happens-before规则：对一个<code>volatile</code>域的写，先于任意后续对这个<code>volatile</code>域的读</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设线程A先执行writer方法，然后线程B执行reader方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;              <span class="comment">// 1 线程A修改共享变量</span></span><br><span class="line">        flag = <span class="literal">true</span>;        <span class="comment">// 2 线程A写volatile变量</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3 线程B读同一个volatile变量</span></span><br><span class="line">        	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;        <span class="comment">// 4 线程B读共享变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序次序规则：1→2；3→4</li>
<li><code>volatile</code>规则：2→3</li>
<li>传递性：1→4</li>
</ol>
<p>只有<code>a</code>修改了，<code>flag</code>置为<code>true</code>后，<code>i</code>才会被赋值为正确的<code>a</code></p>
<h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><p><img src="/posts/35561/image-20230922155104875.png" alt="image-20230922155104875"></p>
<p>具体涉及到四种屏障，可以简单理解为：</p>
<p>写屏障确保不会把写屏障包裹的volatile写指令和外部指令重排序</p>
<p>读屏障确保不会将读屏障之后的指令与volatile读指令重排序</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>使用<code>volatile</code>需要注意</p>
<ol>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
<li>只有在状态真正独立于程序其他内容时，才考虑使用<code>volatile</code></li>
</ol>
<h4 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> shutdownRequested;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; shutdownRequested = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>待补充…</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-代理机制详解</title>
    <url>/posts/56443.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>代理机制是什么？为什么需要代理机制？如何实现的？有哪些具体应用？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>代理，实际上应该是计算机网络中的名词，是一种常见的网络安全工具，它的作用是在通信双方之间建立一个中介服务，从而实现某些安全、性能、业务处理的功能。简单理解就是委托代理人和对方进行交互，按照服务对象不同，可以分为正向代理和反向代理</p>
<ol>
<li><strong>正向代理</strong>：为客户端服务的代理，隐藏客户端的IP地址、位置信息，比如我们使用的VPN就是正向代理，利用代理服务器可以访问国外网址的特性，把自己的请求发给代理服务器，委托代理服务器进行访问</li>
<li><strong>反向代理</strong>：为服务器服务的代理，比如代理服务器直接负责完成重定向操作，或者提供负载均衡、缓冲等服务，同时还能隐藏服务端的IP地址</li>
</ol>
<p><strong>java中的代理实际上也是类似的，目的是为了在执行真正对象的方法的四周，执行代理的业务逻辑，比如日志记录、性能监控等，类似重定向、负载均衡，可以分为静态代理和动态代理两类</strong></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理很简单，一般需要三个角色，<strong>接口类</strong>、<strong>接口实现类</strong>、<strong>接口代理类</strong></p>
<p>接口实现类和接口代理类都需要实现接口类，然后接口代理类持有一个接口实现的对象</p>
<p><strong>IHelloService[接口类]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> staticProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>HelloServiceImpl[接口实现类]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> staticProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IHelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>HelloServiceProxy[接口代理类]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> staticProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">IHelloService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IHelloService IHelloService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloServiceProxy</span><span class="params">(IHelloService IHelloService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.IHelloService = IHelloService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before say hello...&quot;</span>);</span><br><span class="line">        IHelloService.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;After say hello...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IHelloService</span> <span class="variable">IHelloService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line">        <span class="type">HelloServiceProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceProxy</span>(IHelloService);</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">        <span class="comment">// Before say hello...</span></span><br><span class="line">        <span class="comment">// Hello World!</span></span><br><span class="line">        <span class="comment">// After say hello...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理就比较复杂了，实际上动态代理的目的就是<strong>减少重复编码</strong>，比如<strong>我们要执行相同的代理业务逻辑，不可能为每个业务接口都实现一个代理类，所以就引入了动态代理，一般分为JDK动态代理和CGLIB动态代理</strong></p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p><strong>使用</strong></p>
<ol>
<li>首先，定义一个需要<strong>被代理的接口类</strong>，<strong>接口的实现类</strong>可有可无</li>
<li>其次，实现<code>InvocationHandler</code>接口自定义自己的<strong>调用处理器</strong>，重写<code>invoke()</code>方法，添加<strong>方法执行前的处理逻辑</strong>，然后可以通过<code>method.invoke()</code>方法调用<strong>接口实现类的方法</strong>，再添加<strong>方法执行后的处理逻辑</strong></li>
<li>最后，调用<code>Proxy.newProxyInstance()</code>方法，传入<strong>接口的类加载器</strong>、<strong>存储被代理接口的数组</strong>以及一个<strong>调用处理器实例</strong>，返回一个接口的<strong>动态代理对象</strong></li>
</ol>
<p>后续对这个动态代理对象的方法调用，都会转为执行调用处理器的<code>invoke()</code>方法，完成我们附加的执行前动作和执行后动作</p>
<p><strong>原理</strong></p>
<p><img src="/posts/56443/image-20230910160901398.png" alt="image-20230910160901398"></p>
<p>可以发现JDK动态代理的关键类包括<code>Proxy</code>这个类和<code>InvocationHandler</code>这个接口，<code>Proxy</code>类持有一个<code>InvocationHandler</code>的成员变量叫<code>h</code></p>
<p>在运行时，<code>Proxy.newProxyInstance()</code>方法返回的这个<strong>动态代理对象</strong>是一个叫<code>$Proxy0</code>的类对象，是动态生成的，该类对象<strong>继承</strong><code>Proxy</code>类，所以会<strong>持有</strong>传入的<strong>调用处理器</strong>实例，同时<strong>实现</strong>了被代理的接口类，因此也重写了接口的所有方法，对这些方法的调用都会先执行<strong>所持有的调用处理器</strong>实例的<code>invoke()</code>方法，这也就是动态代理的底层原理</p>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>不像JDK动态代理只能应用在实现接口的类上</p>
<p><img src="/posts/56443/image-20230910161556429.png" alt="image-20230910161556429"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="MyBatis映射器代理的实现"><a href="#MyBatis映射器代理的实现" class="headerlink" title="MyBatis映射器代理的实现"></a>MyBatis映射器代理的实现</h4><p>比较重要的几个类包括<code>MapperProxy</code>、<code>MapperProxyFactory</code>、<code>MapperRegistry</code></p>
<p><strong>名词说明</strong></p>
<ul>
<li><strong>接口名</strong>=<strong>接口全限定名</strong>=<code>mapper.xml</code>文件的<code>namespace</code></li>
<li><strong>sql</strong>语句<code>statementID=</code>接口中的<strong>方法名</strong></li>
</ul>
<p><strong>流程说明</strong></p>
<ol>
<li>解析时，解析完一个<strong>mapper.xm</strong>l的所有<strong>sql</strong>语句后，<strong>sql</strong>语句会被封装为一个<code>mappedStatement</code>对象存储在<code>mappedStatements</code>的映射表中，<code>key</code>是<strong>sql</strong>语句的<code>namespace+statementID</code>，然后会创建一个<code>namespace</code>对应的代理工厂<code>MapperProxyFactory</code>存储到<code>MapperRegistry</code>中，其实也是映射表，<code>key</code>就是<code>namespace</code></li>
<li><code>MapperProxy</code>是一个实现了<code>InvocationHandler</code>接口的调用处理器类，重写<code>invoke()</code>方法，实现后续基于接口名+方法名执行<strong>mapper.xml</strong>文件对应的<strong>sql</strong>语句</li>
<li><code>sqlSession</code>调用<code>getMapper(Class&lt;T&gt; type)</code>方法，传入接口名，调用<code>Configuration</code>的<code>getMapper()</code>方法，进一步调用<code>MapperRegistry</code>的<code>getMapper()</code>方法，在这里通过<strong>接口名</strong>获取<strong>接口代理工厂</strong>，通过代理工厂先实例化一个<code>MapperProxy</code>对象，然后调用<code>Proxy</code>的<code>newProxyInstance()</code>方法传入类加载器、被代理接口数组、<code>MapperProxy</code>对象返回<strong>动态代理对象</strong></li>
<li>我们调用<strong>动态代理对象</strong>的方法时，就会被<code>MapperProxy</code>的<code>invoke()</code>方法拦截</li>
</ol>
<h4 id="MyBatis插件的实现"><a href="#MyBatis插件的实现" class="headerlink" title="MyBatis插件的实现"></a>MyBatis插件的实现</h4><p>插件，能够在SQL执行过程中的某一处节点进行拦截，包括参数处理器[<code>ParameterHandler</code>]、结果集处理器[<code>ResultSetHandler</code>]以及语句处理器[<code>StatementHandler</code>]还有就是执行器[<code>Executor</code>]，其实就是提供了对参数设置、结果集映射、sql语句构建和执行等关键节点的拦截和处理</p>
<p><strong>编写插件</strong></p>
<p>我们需要重写拦截器接口的<code>intercept()</code>方法，在这个方法内，编写需要附加的处理过程，调用<code>invocation.proceed()</code>方法推进拦截器链的执行，然后通过注解的形式来说明需要拦截哪个接口的哪些方法以及参数即可，当然还得在<code>XML</code>配置文件中通过<code>plugin</code>标签配置我们写的插件</p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>MyBatis解析XML文件构造拦截器链，然后在上述对象创建时，以动态代理的形式将拦截器包装到对象外层，以责任链的形式推进执行拦截器链。底层实际上通过JDK的动态代理，实现对上述对象执行的拦截，具体来讲就是</p>
<p><strong>Configuration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    <span class="comment">// 原始逻辑没有那么简单，需要考虑原始执行器类型，是否需要装饰Cacheing功能 这里进行简化了</span></span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    <span class="keyword">return</span> (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>InterceptorChain</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorChain</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">pluginAll</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有执行器 封装一层动态代理对象 有点类似装饰器模式</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Interceptor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要我们重写的方法，封装插件业务逻辑</span></span><br><span class="line">  Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Plugin</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plugin</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(type.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">Plugin</span>(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="literal">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> <span class="title class_">Invocation</span>(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象的创建是以动态代理的方式实现的，也就是说<strong>对每个对象、每个插件对象都调用<code>Proxy.newProxyInstance()</code>方法进行代理封装</strong></p>
<p>执行对象的方法时，会被拦截器关联的调用处理器类<code>Plugin</code>捕获，通过注解检查当前方法是否需要拦截，需要则调用拦截器的<code>intercept()</code>方法，插件的业务逻辑就在该方法中，该方法最后会调用<code>invocation.proceed()</code>方法实现拦截器链的推进，拦截器处理完毕后，<code>Plugin</code>的<code>invoke()</code>方法会调用<code>method.invoke()</code>方法执行原来的方法</p>
<p><strong>缺点</strong></p>
<ol>
<li>每个插件都要创建一个Plugin对象，存储到拦截器链中</li>
<li>所有可能被拦截的类都会执行拦截器链，拦截器链逐步推荐，依次判断要不要执行插件中的拦截方法</li>
</ol>
<p>总体来说，插件一旦太多就会比较影响性能</p>
<h4 id="Spring-AOP的实现"><a href="#Spring-AOP的实现" class="headerlink" title="Spring AOP的实现"></a>Spring AOP的实现</h4><p><a href="/posts/17849.html">详见-Spring-AOP</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-内存模型详解</title>
    <url>/posts/33105.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="内存模型的目标"><a href="#内存模型的目标" class="headerlink" title="内存模型的目标"></a>内存模型的目标</h4><ol>
<li>线程通信：线程之间如何交换信息</li>
<li>线程同步：控制不同线程之间操作的相对顺序</li>
</ol>
<h4 id="内存模型的实现方式"><a href="#内存模型的实现方式" class="headerlink" title="内存模型的实现方式"></a>内存模型的实现方式</h4><ol>
<li><strong>共享内存</strong>：共享内存存储共享变量，线程通过读写共享变量来隐式进行通信，并且实现同步也需要程序员显式声明同步代码块</li>
<li><strong>消息传递</strong>：通过明确的信息发送进行通信，信息发送必须在信息接收前进行，所以是隐式同步</li>
</ol>
<p>java的内存模型采用的是共享内存的实现方式，主要需要处理可见性和指令重排两个问题</p>
<h4 id="java内存模型抽象"><a href="#java内存模型抽象" class="headerlink" title="java内存模型抽象"></a>java内存模型抽象</h4><p>java内存模型决定一个线程对共享变量的修改何时对另外一个线程可见，以此实现线程的通信和同步。抽象来讲，java内存模型定义了线程和主存之间的关系：线程间共享变量是存储在主内存中的，主要是堆中的共享变量，每个线程还有私有的本地内存（实际上不是内存，而是CPU高速缓存、寄存器等），本地内存中存储了该线程需要进行读写的共享变量的副本。</p>
<p><img src="/posts/33105/image-20230917184815776.png" alt="image-20230917184815776"></p>
<p>线程A与线程B如果要实现通信，需要2个步骤</p>
<ol>
<li>线程A将修改的共享变量副本写回到主内存</li>
<li>线程B从主内存读取到最新的共享变量</li>
</ol>
<p>JMM通过控制线程本地内存和主内存的交互实现可见性，需要防止<strong>指令重排</strong>，并且提供<strong>happens-before</strong>规则供开发人员使用</p>
<h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p>栈中的变量是线程私有的，本身就不会在多线程间共享，无需考虑可见性。因此，需要考虑可见性的实际上是堆中的共享变量。</p>
<p><strong>大家都用的是堆中的共享变量，为什么还会出现可见性问题呢？</strong></p>
<p>因为堆中共享变量实际上是存储在内存中的，计算机为了性能，是不会与内存直接打交道的，而是与高速缓存进行交互，因为高速缓存的访问性能是远远高于内存的。</p>
<p>既然CPU直接交互的是高速缓存，那就意味着每次修改，直接修改的是高速缓存中的值，而并非堆中共享变量的值，这就造成更新不及时，可见性无法保证。</p>
<p>那么想要实现可见性的最暴力的方法，就是每次修改都立马写回主存，每次读取都直接读取主存的值，这种方法虽然能够保证可见性，但是受制于内存的访问效率，性能大大降低。</p>
<p><strong>内存模型的作用之一就是对本地内存和主存之间交互的约束和规范，兼顾性能和可见性。</strong></p>
<h3 id="指令重排问题"><a href="#指令重排问题" class="headerlink" title="指令重排问题"></a>指令重排问题</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p><strong>为什么指令重排能够提高性能呢？</strong></p>
<p>操作系统现在的指令执行一般都是以流水线形式进行的，也就是说指令1还没执行完，指令2就可以开始执行了。但是操作系统执行指令时，最害怕中断，因为中断之后进行恢复的代价是比较大的，指令重排能够显著减少中断的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = b+c;</span><br><span class="line">d = e+f;</span><br></pre></td></tr></table></figure>
<p>上述代码的执行首先需要加载b和c，然后执行<code>add(b,c)</code>，但是b和c需要加载完才能执行<code>add(b,c)</code>，也就是需要停顿，并且后续加载e和f也会被延迟</p>
<p>实际上，我们可以加载b、c后，不用等加载完，就马上加载e、f，然后再去执行<code>add(b,c)</code>和<code>add(e,f)</code>。</p>
<p><img src="/posts/33105/image-20230921123721729.png" alt="image-20230921123721729"></p>
<p><strong>有哪些指令重排</strong></p>
<ol>
<li>编译器优化重排，编译器在不改变单线程程序语义as-if-serial的前提下，重排执行顺序</li>
<li>指令并行重排，处理器采用流水线技术将多条指令重叠执行，需要确保不存在<strong>数据依赖性</strong></li>
<li>内存系统重排，处理器存在读写缓冲区，加载和存储操作可能乱序执行</li>
</ol>
<p><strong>数据依赖</strong></p>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
</div>
<p>上述操作，如果发生指令重排序，都会导致结果不一样，编译器和处理器在进行指令重排序时会考虑这种数据依赖关系，确保即便发生指令重排，结果也和原始执行顺序的结果一致，也就是as-if-serial语义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>  <span class="operator">=</span> <span class="number">3.14</span>;    <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>   <span class="operator">=</span> <span class="number">1.0</span>;     <span class="comment">// B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<p>C依赖于A和B，那么不管怎么重排序，A和B都要先于C执行</p>
<p><strong>但是，上述这种对数据依赖关系的考虑只针对单线程场景，多线程之间的数据依赖关系是无法考虑到的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="literal">true</span>;             <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Public <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">// 3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a * a;        <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程A调用<code>writer()</code>方法，线程B调用<code>reader()</code>方法，线程B读取到的<code>i</code>一定是1吗？</p>
<p>不一定，因为1和2不存在数据依赖，可以指令重排序，3和4也不存在数据依赖，也可以指令重排序，因此可能出现问题</p>
<p><strong>考虑2→3→4→1的执行序列，线程B读取到的就是0</strong></p>
<p><img src="/posts/33105/image-20230917192527575.png" alt="image-20230917192527575"></p>
<p><strong>内存模型的另外一个作用就是对于正确同步的多线程程序，程序的执行将具有顺序一致性，即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。</strong></p>
<p>正确同步，就需要使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>等关键字</p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><ul>
<li>在一个线程中写一个变量</li>
<li>在另一个线程读同一个变量</li>
<li>而且写和读没有通过同步来排序</li>
</ul>
<p>满足上述条件就说明发生了数据竞争，程序的运行结果就可能违背预期</p>
<h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>如果发生了数据竞争，但是程序是正确同步的，那么java内存模型能够确保程序的执行满足顺序一致性，即与顺序一致性内存模型的执行结果一致，而顺序一致性内存模型具备如下两大特性：</p>
<ol>
<li>一个线程内的所有操作必须按照程序的顺序来执行</li>
<li>所有线程看到的执行顺序是唯一的</li>
</ol>
<p>顺序一致性内存模型可以看做是并发控制的标准，java内存模型和处理器内存模型都是以顺序一致性内存模型作为参考，并考虑到执行性能而进行适当放松。</p>
<blockquote>
<p>类似数据库中的事务隔离级别，串行化基本能够保证不发生并发访问错误，但是执行效率大大降低，因此MySQL不推荐为了防止幻读而将事务隔离级别提高到串行化。</p>
</blockquote>
<h4 id="同步控制下的执行特性"><a href="#同步控制下的执行特性" class="headerlink" title="同步控制下的执行特性"></a>同步控制下的执行特性</h4><h5 id="顺序一致性内存模型-1"><a href="#顺序一致性内存模型-1" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h5><p>线程A和线程B各自需要先后执行三个操作，并且进行了同步（A获取锁执行后释放锁，B再执行），那么执行顺序为</p>
<p><img src="/posts/33105/image-20230917193800878.png" alt="image-20230917193800878"></p>
<h5 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h5><p>java内存模型在同步控制下，保证执行结果和顺序一致性模型的执行结果一致，并且不允许内部指令逃逸出同步块，但是对于同步块内部指令的执行不保证局部有序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/33105/image-20230917194622865.png" alt="image-20230917194622865"></p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>差别主要在于局部有序性，java内存模型只需保证基于数据依赖关系的指令重排，而不强求按照程序顺序进行执行</p>
<h4 id="未同步控制的执行特性"><a href="#未同步控制的执行特性" class="headerlink" title="未同步控制的执行特性"></a>未同步控制的执行特性</h4><h5 id="顺序一致性内存模型-2"><a href="#顺序一致性内存模型-2" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h5><p>如果没有进行同步，则执行顺序可能是</p>
<p><img src="/posts/33105/image-20230917193834571.png" alt="image-20230917193834571"></p>
<p>A线程、B线程内都是有序的，而全局不是有序的，执行的结果也是无法预知的</p>
<h5 id="java内存模型-1"><a href="#java内存模型-1" class="headerlink" title="java内存模型"></a>java内存模型</h5><p>JMM对于没有进行同步或者未正确同步的程序只提供<strong>变量读取最小安全性的保证</strong>，即读取到的变量无法保证实时性，要么是之前某个线程写入的值，要么是默认值（0，null，false），但是肯定不会是无中生有的值。为了实现这个最小安全性，JVM 在堆上分配对象时，首先会清零内存空间（分配内存空间+初始化零值），然后才会在上面分配对象（JVM 内部会同步这两个操作）。</p>
<h5 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h5><ul>
<li><p>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</p>
</li>
<li><p>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。</p>
<p>  比如，在当前线程把写过的数据缓存在本地内存，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。</p>
</li>
<li><p>JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。</p>
</li>
</ul>
<h3 id="64位数据读写原子性"><a href="#64位数据读写原子性" class="headerlink" title="64位数据读写原子性"></a>64位数据读写原子性</h3><p>计算机中，数据是通过总线在处理器和内存之间进行传递的，每次数据传递都是一个总线事务（读事务 | 写事务），具备事务的原子性特征，并且总线会同步所有的总线事务，在任意一个处理器执行总线事务时，其他处理器、IO设备对内存的读写操作会被禁止。简单来说，就是总线事务是串行执行的，只要是一个事务内的操作，都能满足原子性。</p>
<p>在一些32位处理器上，最多支持32位数据的计算，那么对于64位数据进行读写就需要较大的开销保证原子性。</p>
<p>因此，java内存模型对这类处理器，不强求对64位数据，比如long | double型变量的读写具备原子性，也就是说，为了提高执行效率，java内存模型一般会把64位数据的读写操作分为高32位和低32位两部分执行，而这就可能导致读写操作被分配到不同事务中执行，原子性就无法保证，可能出现无法预料的错误。</p>
<p><img src="/posts/33105/image-20230918100116986.png" alt="image-20230918100116986"></p>
<h3 id="语言层面内存模型的必要性"><a href="#语言层面内存模型的必要性" class="headerlink" title="语言层面内存模型的必要性"></a>语言层面内存模型的必要性</h3><p>实际上操作系统已经参考顺序一致性内存模型实现了不同的处理器内存模型了，那为什么java还要额外设计一层内存模型呢？</p>
<ol>
<li>大部分处理器内存模型更偏重性能，java内存模型需要通过额外插入内存屏障阻止部分指令重排序，进一步加强同步控制</li>
<li>不同处理器内存模型之间也有区别，java内存模型屏蔽了不同处理器内存模型的差异，为java程序员呈现了一个一致的内存模型</li>
</ol>
<h3 id="java内存模型-2"><a href="#java内存模型-2" class="headerlink" title="java内存模型"></a>java内存模型</h3><p>java提供的内存模型需要考虑</p>
<ol>
<li>程序员对内存模型的使用：程序员要求内存模型易于理解，不会出现预期不到的并发错误——强内存模型</li>
<li>编译器和处理器对内存模型的实现：编译器和处理器需要内存模型对代码优化的约束越小越好，尽可能提高性能——弱内存模型</li>
</ol>
<p>java内存模型的核心就是上述需求的平衡，为此将指令重排序划分为两类，并对编译器和处理器做不同约束，同时提供happens-before规则满足开发需求：</p>
<ol>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序（插入内存屏障）。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）</li>
</ol>
<p><img src="/posts/33105/image-20230918102930312.png" alt="image-20230918102930312"></p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>JMM确保在不同编译器和处理器平台上，通过禁止特定类型的编译器、处理器重排序，实现内存可见性保证，禁止指令重排需要插入内存屏障（读-Load 写-Store），主要有以下四种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barriers</td>
<td>Load1; <br>LoadLoad; <br>Load2</td>
<td>确保Load1数据的读取，先于 Load2 及所有后续读取指令。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; <br>StoreStore; <br>Store2</td>
<td>确保Store1数据写内存，先于 Store2 及所有后续写入指令。</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; <br>LoadStore; <br>Store2</td>
<td>确保Load1数据的读取，先于 Store2 及所有后续的写入。</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td></td>
<td>该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody>
</table>
</div>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p><strong>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系，但是存在happens-before并不意味着java就得按照其指定的顺序执行，如果重排后执行的结果不变也是可接受的，其实也是as-if-serial语义，只是针对的是正确同步的多线程程序</strong></p>
<p>具体规则如下：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens- before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens- before于随后对这个监视器锁的加锁。</li>
<li>volatile 变量规则：对一个volatile域的写，happens- before于任意后续对这个volatile域的读。</li>
<li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>
</ul>
<p>总得来说，java内存模型遵循一个规范：单线程场景下，只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。对于多线程场景，则提供synchronized、volatile、final等关键字提供开发人员进行同步控制。</p>
<p><img src="/posts/33105/image-20230918104737960.png" alt="image-20230918104737960"></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-对java编译与解释并存的理解</title>
    <url>/posts/274.html</url>
    <content><![CDATA[<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>java开发工具包（JDK，Java Development Kit），包含了java的开发工具，比如javac编译器、打包工具等，也包含JRE，能够创建、编译、运行程序，是提供给java开发人员的</p>
<h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>java运行时环境（JRE，Java Runtime Environment），实际上是JDK的子集，包括java虚拟机、java类库、java命令及一些基础构件，用于运行java程序，但是不能用于创建新程序</p>
<hr>
<p>实际上，JDK和JRE是Oracle提供的java平台的标准产品。一般来说，如果只是运行java程序，那么只需要安装JRE，但是如果需要进行开发，那么就需要安装JDK了。但是也存在特殊情况：</p>
<blockquote>
<p>比如，使用JSP部署Web应用程序，虽然看起来只需要运行java程序，但是依然需要JDK。因为JSP文件本质上是包含了java代码的HTML文件，在运行时需要将JSP文件进行编译，再执行，这就需要用到JDK</p>
</blockquote>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>java虚拟机（JVM，Java Virtual Machine）就是运行java字节码的平台，针对不同的系统有不同的实现，目的是输入相同的字节码，能够得到在不同平台上运行并且结果一致的机器码。</p>
<p><img src="/posts/274/image-20230904184902797.png" alt="image-20230904184902797"></p>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>java字节码其实就是虚拟机能看得懂的代码，也就是<code>.class</code>文件，字节码不面向处理器，只面向虚拟机，通过字节码，在一定程度上解决了解释型语言执行效率低的弊端，同时保留了其平台无关性的优势，实现一次编译，随处运行</p>
<h3 id="java语言的特点"><a href="#java语言的特点" class="headerlink" title="java语言的特点"></a>java语言的特点</h3><p>编译与解释并存是java语言独有的特性，除此之外，java还有如下特点：</p>
<ol>
<li><p>面向对象，将实体抽象为对象，基于对象属性通过执行方法来解决问题，具备封装、继承和多态三大特点</p>
<p>面向对象编程：先抽象出对象，然后以组合、编排对象的方法来解决问题。</p>
<p>面向过程编程：把解决问题的过程，拆成一个个方法，通过一个个方法的调用解决问题</p>
</li>
<li><p>平台无关性</p>
</li>
<li><p>支持网络、多线程编程</p>
</li>
</ol>
<h3 id="java实现平台无关性"><a href="#java实现平台无关性" class="headerlink" title="java实现平台无关性"></a>java实现平台无关性</h3><p>java程序从源代码到执行一般包括两个步骤：</p>
<ol>
<li>JDK的javac编译器将源代码<code>.java</code>文件编译为java字节码<code>.class</code>文件</li>
<li>JVM接受字节码为输入，解释或者编译将其转换为机器码，再执行</li>
</ol>
<p><img src="/posts/274/image-20230904190618109.png" alt="image-20230904190618109"></p>
<p>平台无关性的关键在于<strong>字节码和java虚拟机</strong></p>
<p>字节码不面向系统，只面向虚拟机，而java虚拟机则是运行字节码的平台，该平台针对不同的系统有不同实现，提供不依赖于操作系统和硬件的运行环境，确保输入相同的字节码能够依据不同的系统得到运算结果一致的机器码，通过字节码和机器码实现平台无关性，也就是一次编译，随处运行</p>
<p><strong>可以说编译与解释并存是实现平台无关性的原因</strong></p>
<h3 id="java的编译与解释并存"><a href="#java的编译与解释并存" class="headerlink" title="java的编译与解释并存"></a>java的编译与解释并存</h3><h4 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h4><p>一般我们将编程语言分为编译型语言和解释型语言</p>
<ul>
<li><p><strong>编译型语言</strong>：程序在执行前一次性编译，将源代码编译为可执行的机器码，运行时直接使用编译的结果，执行效率较高，但是开发效率较低，难以跨平台</p>
</li>
<li><p><strong>解释型语言</strong>：程序不需要编译，在执行时再逐行解释为机器语言，执行效率较低，但是更为灵活</p>
</li>
</ul>
<blockquote>
<p>比如阅读外文文献，编译就是请翻译家一次性翻译为中文译本，直接阅读中文译本；解释则是临时请一个翻译家，翻译一句，读一句</p>
</blockquote>
<p>java编译与解释并存的目的在于既要保留跨平台的优势，又要尽可能优化执行效率，可以从两个角度进行理解</p>
<h4 id="编译前端和编译后端"><a href="#编译前端和编译后端" class="headerlink" title="编译前端和编译后端"></a>编译前端和编译后端</h4><p>编译前端，java通过javac将源代码编译成字节码（<code>.class</code>文件），此为编译；</p>
<p>编译后端，默认情况下JVM会将字节码逐行解释为对应机器码进行执行，此为解释。</p>
<p><strong>这是整个java程序执行层面的编译与解释并存</strong></p>
<h4 id="解释执行和编译执行"><a href="#解释执行和编译执行" class="headerlink" title="解释执行和编译执行"></a>解释执行和编译执行</h4><p>此外，为了提高编译后端的执行效率，除了解释执行的方式，编译后端还引入了即时编译和提前编译两种编译执行方式，即时编译是在运行时探测热点代码编译为机器码，并进行优化，需要一段时间进行预热；而提前编译则是在运行前，将字节码全部编译为机器码，相当于提前预热。</p>
<p><strong>这是编译后端层面的编译与解释并存</strong></p>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><h4 id="为什么不完全采用提前编译"><a href="#为什么不完全采用提前编译" class="headerlink" title="为什么不完全采用提前编译"></a>为什么不完全采用提前编译</h4><p>java语言支持一定的动态特性，比如CGLIB实现动态代理的底层原理实际上是运行时直接在内存中生成修改后的字节码<code>.class</code>文件，如果完全采用提前编译，就无法支持这种动态特性了</p>
<h4 id="即时编译如何探测热点代码-热点探测"><a href="#即时编译如何探测热点代码-热点探测" class="headerlink" title="即时编译如何探测热点代码[热点探测]"></a>即时编译如何探测热点代码[热点探测]</h4><p>热点代码一般包括多次调用的方法和多次执行的循环体，探测手段有基于采样和基于计数器</p>
<ol>
<li>采样的方法比较简单，通过周期性检查<strong>各个线程的调用栈顶</strong>来甄别热点代码，简单高效但是不够精确</li>
<li>计数器的方法简单来讲，就是设定阈值，<strong>一段时候内调用次数</strong>超过阈值的方法会提交给编译器进行编译，执行时会判断是否存在已编译版本，如果有，直接执行编译的版本，而不再以解释方式执行<ol>
<li>调用次数是相对的，也就是说存在<strong>半衰周期</strong>，并非永久叠加，半衰周期后都没达到阈值就减半</li>
<li>方法执行有<strong>方法调用计数器</strong>，方法内多次执行的循环体也有<strong>回边计数器</strong>，两者之和再和阈值比较</li>
</ol>
</li>
</ol>
<p><img src="/posts/274/image-20230904194513928.png" alt="image-20230904194513928"></p>
<h4 id="java和c-的对比"><a href="#java和c-的对比" class="headerlink" title="java和c++的对比"></a>java和c++的对比</h4><ol>
<li><p>虽然都是面向对象的语言，都支持封装、继承和多态，但是java是纯面向对象的，c++为了兼容c既支持面向对象也支持面向过程</p>
<p> 比如java没有类就无法通过编译，无法正常执行</p>
</li>
<li><p>java只允许类的单继承，但是可以实现多个接口，c++允许多继承</p>
</li>
<li><p>java能够基于字节码+虚拟机实现平台无关性，但是c++依赖于特定的平台</p>
</li>
<li><p>java是编译与解释并存，c++则是纯编译</p>
</li>
<li><p>java不提供指针直接访问内存，引用可以理解为一种安全指针，而c++提供指针操作</p>
</li>
<li><p>java有自动垃圾回收机制，不需要像c++那样手动释放无用内存</p>
</li>
<li><p>java语言的字符串或者字符数组没有结束符</p>
<blockquote>
<p>java中的一切都是对象，字符串或者字符数组作为对象，已经提供获取长度的方法[字符串的length()]或者长度属性[数组的length属性]，那么自然也就不需要结束符表示字符串 | 字符数组的结束了</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-多线程并发问题</title>
    <url>/posts/41833.html</url>
    <content><![CDATA[<h3 id="多线程并发问题"><a href="#多线程并发问题" class="headerlink" title="多线程并发问题"></a>多线程并发问题</h3><p>多线程并发的问题根源在于多线程交互，包括共享变量、多线程协作等，如果多线程之间完全没有交互，那么肯定是不会出现问题的。依赖于共享变量、线程协作，会导致线程不安全、死锁等问题。</p>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>参考数据库的事务的一致性，线程是否安全指的就是多个线程对同一份共享变量的修改、读取操作是否能够保证数据的一致性。线程不安全时，可能导致数据混乱、更新错误或者丢失等问题</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadUnsafeExample</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadUnsafeExample</span> <span class="variable">threadUnsafeExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafeExample</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                threadUnsafeExample.add();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(threadUnsafeExample.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p><strong>一个线程对某个共享变量做了修改，其余访问该变量的线程能够立马看见</strong></p>
<p>但是CPU高速缓存可能导致可见性无法满足，CPU高速缓存是为了平衡内存和CPU的速度差异而设置的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>
<p>假设线程1由CPU1执行，线程2由CPU2执行。线程1所在的CPU1会把共享变量以cache line的形式读到高速缓存，线程1修改后，没来得及写回到内存，导致线程2所在的CPU2也是读取内存中的老的数据，也就是<code>j=i=0</code>。</p>
<p>其实上述问题发生不仅仅是因为CPU高速缓存，如果线程1和线程2是串行执行的，线程1所有操作都完成，再到线程2执行，那么也不会出现问题，但是操作系统是分时复用的，所以多线程安全还需要<strong>原子性</strong>保证。</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p><strong>一个操作是原子性的，那么其所有子操作要么全部执行，要么都不执行</strong></p>
<p>操作系统的分时复用可能导致破坏原子性，比如<code>i+=1</code>的操作涉及到3条指令，分别是</p>
<ol>
<li><strong>读取</strong>：将变量i的值从内存读取到CPU寄存器（可以认为是更快的一种存储设备）</li>
<li><strong>修改</strong>：在CPU寄存器中将i的值+1</li>
<li><strong>写回</strong>：将最后的结果写回到主存（实际上可能是写到高速缓存）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>由于分时复用，三条指令可能不是紧贴着执行的，假设两个线程都执行<code>i+=1</code>，线程1读取后切换到线程2执行，线程2读取、修改、写回去，再切换回线程1修改、写回去，就会导致丢失一次+1</p>
<p>即便保证操作是原子性的，依然可能因为<strong>指令重排（有序性）</strong>导致多线程不安全</p>
<h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p><strong>程序执行的顺序按照代码编写的先后顺序执行</strong></p>
<p>指令重排序可能导致并发下的有序性被破坏，编译器、处理器为了提高性能，往往会对指令进行重排序，虽然单线程下重排序需要保证执行的结果和按照代码顺序执行的结果保存一致，但是多线程下却没有义务保证这种串行语义的一致性</p>
<p>指令重排序导致出现问题的经典例子就是单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不对<code>uniqueInstance</code>变量进行<code>volatile</code>声明，则构造<code>uniqueInstance</code>的过程可能会发生指令重排序，应该该操作涉及到以下三个步骤</p>
<ol>
<li>分配内存空间</li>
<li>初始化实例对象</li>
<li>将引用指向这个内存空间</li>
</ol>
<p>2和3的顺序可能会发生变化，变为1→3→2，多线程下会发生问题</p>
<p>比如线程1和线程2都想要获取单例，首先线程1执行，发现单例为空，尝试初始化，执行完1和3，切换到线程2执行，线程2发现引用不为空，返回引用并使用，但是此时单例对象实际上还没有初始化，就会出错</p>
<h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><ol>
<li><p><strong>互斥同步</strong>，一种悲观的并发策略，认为只要不加控制就会出现并发问题，所以需要用<a href="./38827.html">锁机制</a>使得同步块任意时刻只有一个线程执行</p>
</li>
<li><p><strong>非阻塞同步</strong>，互斥同步最主要问题就是线程阻塞和唤醒带来的性能损失，非阻塞同步就是乐观锁，也就是说先操作，如果没有其他线程竞争，那么操作就成功了，否则采取补偿措施[不断重新操作，直到成功]</p>
<p> 需要硬件支持的原子性操作来完成操作检测，最典型的就是<code>CAS</code>，比较并交换，需要三个操作数，内存地址，旧的值，新的值，只有当旧的值等于内存地址中的值，才能将新的值写到内存中</p>
</li>
<li><p><strong>无同步</strong>，方法本来就不涉及共享变量，无需同步</p>
<p> 比如局部变量存储在虚拟机栈这种，属于线程私有</p>
<p> 比如<code>ThreadLocal</code>类将变量的可见范围限制在一个线程内，自然不存在线程安全问题</p>
</li>
</ol>
<p>详见<a href="./4986.html">线程安全实践</a></p>
<h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>java提供<a href="./33105.html">内存模型</a>实现多线程安全，实际上是互斥同步方案的体现，本质上就是保证可见性、原子性和有序性，实现方法包括<code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字和happens-before规则：</p>
<ol>
<li>原子性：实际上只有读取和赋值操作是原子性的，而大范围的原子操作，JMM提供了<code>synchronized</code>关键字</li>
<li>可见性：提供了<code>volatile</code>关键字，告诉JVM该变量是不稳定的共享变量[普通的共享变量什么时候写回到主存是不确定的]，所有对该变量的更新会被立马写到主存中，其他线程访问该变量，也是直接去主存访问。当然，<code>synchronized</code>也能够确保可见性。</li>
<li>有序性：<code>volatile</code>能够在一定程度保证有序性，<code>synchronized</code>确保同步块任意时刻只有一个线程执行，也能够保证有序性</li>
</ol>
<p>详见<a href>synchronized详解</a>、<a href>volatile详解</a>、<a href>final详解</a>以及<a href="./33105.html">happens-before详解</a></p>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>多个线程同时阻塞，并且构成循环等待链，导致没有任何一个线程能够被唤醒继续执行。</p>
<p><img src="/posts/41833/image-20230917163452796.png" alt="image-20230917163452796"></p>
<p>需要满足以下四个条件</p>
<ol>
<li>互斥条件：一个资源同一时刻只能一个线程持有</li>
<li>请求与保持条件：线程对持有的资源不会主动释放</li>
<li>不剥夺条件：线程不能剥夺别的线程持有的资源</li>
<li>循环等待条件：线程之间对资源的需求形成了循环等待关系</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 try to get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1 get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 try to get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">      	<span class="comment">// Thread1 get resource1</span></span><br><span class="line">				<span class="comment">// Thread2 get resource2</span></span><br><span class="line">				<span class="comment">// Thread1 try to get resource1</span></span><br><span class="line">				<span class="comment">// Thread1 try to get resource2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h4><p>和解决进程死锁不同，线程死锁的解决一般是破坏循环等待条件，也就是每个线程获取资源的顺序是固定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 try to get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1 get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 try to get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Thread1 get resource1</span></span><br><span class="line"><span class="comment">//        Thread1 try to get resource2</span></span><br><span class="line"><span class="comment">//        Thread1 get resource2</span></span><br><span class="line"><span class="comment">//        Thread2 get resource1</span></span><br><span class="line"><span class="comment">//        Thread1 try to get resource2</span></span><br><span class="line"><span class="comment">//        Thread2 get resource2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-对象详解</title>
    <url>/posts/39626.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelfClass</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelfClass</span>();</span><br><span class="line"><span class="type">SelfClass</span> <span class="variable">c2</span> <span class="operator">=</span> c1.getClass().newInstance();</span><br></pre></td></tr></table></figure>
<p>类对象是java能够实现各种业务逻辑的基础，是类的实例化对象，例如上述左边的c实际上是对象引用，存储在栈内存中，而new出来的SelfClass对象才是该类的一个实例，一般来说，存储在堆内存中，对象实例和对象引用的关系是一对多。</p>
<p><img src="/posts/39626/image-20230908160020627.png" alt="image-20230908160020627"></p>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol>
<li>该对象所属类的加载的检查——类加载检查</li>
<li>内存空间的分配——分配内存空间</li>
<li>类对象属性的设置——初始化零值 和 执行init方法</li>
<li>类对象的基本信息的存储——设置对象头</li>
</ol>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/posts/39626/image-20230908161418147.png" alt="image-20230908161418147"></p>
<p>具体如下：</p>
<ol>
<li><p><strong>类加载检查</strong></p>
<p>虚拟机首先检查是否能在常量池中定位到这个类的符号引用，然后检测这个类有没有被加载过，如果没有需要执行类加载过程[加载→验证→准备→解析→初始化]</p>
</li>
<li><p><strong>分配内存</strong></p>
<p>虚拟机会为年轻的对象分配内存，内存大小在类加载时就可以确定了，实际上就是从java堆中分出来一块固定大小的内存空间。</p>
</li>
<li><p><strong>初始化零值</strong></p>
<p>虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），其实就是字段数据类型的零值，比如int的0，boolean的false，引用类型的null，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，</p>
</li>
<li><p><strong>设置对象头</strong></p>
<p>对象头存储对象自身的运行时数据（哈希码、垃圾回收年龄分代、锁状态等）以及类型指针（对象指向类的元数据信息的值，虚拟机基于此可以确定这个对象属于哪个类），这些都会存放到对象头中，需要进行设置</p>
</li>
<li><p><strong>执行init方法</strong></p>
<p>到这才是代码控制的步骤，也就是依据代码进行成员非静态变量的赋值和执行构造方法</p>
</li>
</ol>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>分配的方式有指针碰撞和空闲列表两种，取决于java堆是否规整，也就是是否存在碎片，而这又是由垃圾回收算法决定的，比如复制算法能够避免碎片的产生</p>
<p><strong>指针碰撞</strong>：适用于没有内存碎片的情形，实际上就是用一个分界指针将正在使用的内存和空闲的内存进行划分，内存分配只需要将指针往空闲内存那边移动相应内存大小即可</p>
<p><strong>空闲列表</strong>：适用于堆不规整的情形，虚拟机会维护一个表，记录哪些内存块是可用的，分配的时候找一块足够大的内存块就行，然后更新这个表</p>
<h4 id="内存分配的并发问题"><a href="#内存分配的并发问题" class="headerlink" title="内存分配的并发问题"></a>内存分配的并发问题</h4><p>内存分配是存在并发问题的，虚拟机通过TLAB+CAS进行处理</p>
<p>TLAB的意思就是Thread Local Allocation Buffer，线程本地分配的缓冲区，也就是说虚拟机会为每个线程在Eden区分配一块私有的内存供其创建对象，如果这个空间不够再用CAS来保证并发控制</p>
<p>CAS的意思是Compare and Swap，简单来说就是一种乐观锁，假设操作时不会出现并发问题，不加锁，操作结束后，再去检查操作是否成功，成功就ok，不成功就多次重试</p>
<p>这里成功的检测，最简单的方法就是比较旧值和期待的值是否相等，但是这样会有ABA的问题，所以java提供了一个AtomicStampedReference来解决该问题</p>
<h4 id="内存空间分配位置"><a href="#内存空间分配位置" class="headerlink" title="内存空间分配位置"></a>内存空间分配位置</h4><p>一般来说，都是分配在堆中；但是也有可能在栈上分配，随着方法的返回而销毁，无需垃圾回收。</p>
<p>对于一些在方法内部定义的类对象，如果只在内部使用，没有被外部引用，则认为没有逃逸，没有逃逸的类对象不会在堆中存储，而是存储在方法的栈中。</p>
<h4 id="对线内存布局"><a href="#对线内存布局" class="headerlink" title="对线内存布局"></a>对线内存布局</h4><ul>
<li><p><strong>对象头</strong></p>
<ol>
<li>存储对象自身的运行时数据（哈希码、垃圾回收年龄分代、锁状态等）</li>
<li>类型指针（对象指向类的元数据信息[元空间]的指针，虚拟机基于此可以确定这个对象属于哪个类）</li>
</ol>
</li>
<li><p><strong>实例数据</strong></p>
<p>对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容</p>
</li>
<li><p><strong>对齐填充</strong></p>
<p>占位作用，因为对象的起始地址必须是8的倍数，对象头是8的1倍或者2倍，但是实例数据无法保证，需要对其进行对齐</p>
</li>
</ul>
<h3 id="对象访问定位的两种方式"><a href="#对象访问定位的两种方式" class="headerlink" title="对象访问定位的两种方式"></a>对象访问定位的两种方式</h3><p>通过栈上的reference来定位堆上的对象实例，有句柄和直接指针两种方式</p>
<h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>堆中额外存储一个句柄池，栈上的reference指向句柄，句柄存储了到堆中对象实例数据的指针和到元空间中对象的类信息的指针，优势在于<strong>对象被移动不影响reference，只需要修改句柄的指向</strong></p>
<p><img src="/posts/39626/image-20230908162849900.png" alt="image-20230908162849900"></p>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>reference存储的就是堆中对象实例数据的指针，通过对象实例数据的对象头中存储的类型指针能够找到对象在元空间中存储的类的元数据信息，优势在于<strong>一次指针操作就可以拿到对象实例数据，效率高</strong></p>
<p><img src="/posts/39626/image-20230908163050408.png" alt="image-20230908163050408"></p>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><p><strong>成员变量和局部变量的区别</strong></p>
<p>我们这里暂时不考虑静态的成员变量</p>
<p><strong>形式上</strong>：成员变量在类中定义，属于类，局部变量在方法中定义，或者作为方法的入参</p>
<p>修饰符：成员变量可以用 public | private | static 等进行修饰，但是局部变量只能用final修饰，表示值不能变 或者引用不能指向别的地方</p>
<p><strong>存储方式</strong>：局部变量存储在栈内存，成员变量存储在堆内存</p>
<p><strong>生命周期</strong>：成员变量依赖于类对象，类对象销毁即消失，局部变量依赖于方法，方法返回即消失</p>
<p><strong>初始化</strong>：成员变量如果没有初始化，则依据类型进行默认初始化，局部变量不会默认初始化</p>
<p><strong>命名</strong>：在一个类方法中，局部变量可以和类的成员变量同名，但是局部变量优先，如果需要访问成员变量，可以用this</p>
<hr>
<p><strong>局部变量为什么要初始化</strong></p>
<p>局部变量也就是类方法中的变量，局部变量运行时存储在栈中，数量多，生命周期短，如果交给虚拟机进行初始化，代价太大，但是不初始化就使用有不安全，因此就要求局部变量要初始化，当然全局变量也是需要初始化的，但是全局变量的初始化由虚拟机完成，因为全局变量数量少很多，初始化代价可以接受</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-并发基础</title>
    <url>/posts/16745.html</url>
    <content><![CDATA[<h3 id="线程-进程-程序"><a href="#线程-进程-程序" class="headerlink" title="线程 进程 程序"></a>线程 进程 程序</h3><ul>
<li>程序是静态的，是存储在磁盘中，包含数据和指令的文件，可以认为程序是静态的进程</li>
</ul>
<ul>
<li>进程是程序的一次执行过程，总体上可以认为包含创建、运行和销毁三个阶段，是系统资源分配的基本单位，也就是说进程享有CPU、内存、输入输出设备等资源的使用权，进程会按照程序的指令，依次进行执行，进程之间一般不会互相干扰。</li>
<li>线程则是更小的执行单位，是进程的一个执行序列，也被称为轻量级进程，是CPU调度的基本单位，一个进程可以创建多个线程，这些线程共享进程的资源，同时能够互相协作</li>
</ul>
<p>在Java中，启动<code>main</code>函数，其实就是启动了JVM的进程，<code>main</code>函数所在的线程就是进程创建的一个线程，也叫主线程</p>
<h3 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h3><p>现代操作系统中，线程是CPU调度的最小单位，比如Intel Core i9-13900K拥有24核心和32线程</p>
<ul>
<li>并行：同一时刻，多个线程均在执行，需要多核CPU的支持</li>
<li>并发：同一时刻，只能一个线程执行，但是在一段时间内，两个线程都有使用CPU，并发依赖于线程上下文切换</li>
</ul>
<p><img src="/posts/16745/image-20230917142225931.png" alt="image-20230917142225931"></p>
<p><strong>并发的意义</strong></p>
<p>考虑一个应用程序，需要能够执行某些耗时比较长的任务，同时渲染界面响应用户请求，如果是单线程非并发执行，那么执行任务时，程序就会假死，虽然一直在运行，但是无法即时响应用户请求</p>
<p><strong>多线程的意义</strong></p>
<p>首先，从开销来看：线程是轻量级的进程，一般来说，线程的创建、销毁以及同一进程的线程的上下文切换的开销比进程要小得多，所以现在的操作系统都以线程作为最小的调度单元，多核CPU时代意味着多个线程能够同时运行，不需要频繁切换线程来执行。</p>
<p>其次，从CPU的利用率角度来看：如果是单核CPU，单线程在使用IO时，CPU就会空闲，此时可以将CPU让给另外一个线程执行，提高CPU利用率；如果是多核CPU，单线程只能用到一个CPU，利用率低，性能也没有充分利用起来，而进程创建多个线程一起执行，就能充分利用CPU的多个核心，大大提高计算效率</p>
<p>因此，多线程的出现是开发高并发系统的基础，比如现在淘宝、京东这种体量的应用程序，单线程是不可能支撑起来的</p>
<p>但是，需要注意多线程并发不一定就能提高运行效率，如果是CPU密集型的多个任务，多线程并发就会导致线程频繁切换，会增加系统开销。如果存在IO密集型的任务，那么IO线程在执行IO任务时，可以切换给别的任务执行，就能提高CPU利用率，增加性能</p>
<p><img src="/posts/16745/image-20230917143144811.png" alt="image-20230917143144811"></p>
<p>此外，多线程并发也会导致线程不安全的问题</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p><strong>并发意味着线程不是一直处于运行状态的，是存在状态转换的</strong></p>
<p><img src="/posts/16745/image-20230916193111039.png" alt="image-20230916193111039"></p>
<p><strong>new</strong>：线程刚刚被创建，但是没有调用<code>start</code>方法</p>
<p><strong>runnable</strong>：线程等待执行，或者正在执行，也就是ready和running</p>
<blockquote>
<p>当线程调用 <code>start()</code>方法后，线程则处于就绪状态，等待操作系统分配CPU时间片，分配后则进入running运行状态。</p>
<p>当调用<code>yield()</code>方法后，只是谦让的允许当前线程让出CPU，但具体让不让不一定，由操作系统决定。如果让了，那么当前线程则会处于<code>ready</code>状态参与后续CPU竞争，直至执行</p>
<p>其实<code>yield()</code>调用的效果相当于<code>sleep(0)</code></p>
</blockquote>
<p><strong>blocked</strong>：阻塞状态，特指阻塞于锁，是被动的，<code>synchronized</code></p>
<p><strong>wait</strong>：等待事件的发生，是主动的，系统不会调度，需要依靠其他线程通知才能回到runnable状态</p>
<p><strong>timed_wait</strong>：超时等待状态，指定时间让出CPU资源，线程不执行，等待一段时间后会自动返回runnable状态</p>
<p><strong>terminated</strong>：线程执行完毕 | 异常，进入终止状态</p>
<hr>
<p><strong>如果一个线程调用两次start方法会怎么样</strong></p>
<p>第二次调用会抛出异常<code>IllegalThreadStateException</code>，也就是说java中的线程只能调用一次<code>start()</code>方法，调用<code>start()</code>方法的意思就是将线程从new状态转换为runnable状态，再调用<code>start()</code>时，线程可能处于runnable、wait、blocked等非new的状态，相当于已经运行了的线程再启动一次，不符合线程的执行流程，因此<code>start()</code>的源码中会先判断线程的状态是不是new，如果不是会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">  	<span class="comment">// A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="sleep-vs-wait"><a href="#sleep-vs-wait" class="headerlink" title="sleep vs wait"></a>sleep vs wait</h4><ol>
<li><p><code>sleep</code>不会释放锁，而<code>wait</code>会释放锁</p>
<p> 为什么要释放锁，如果不释放，别的线程无法进入同步块，也就无法执行<code>notify|notifyAll</code>方法唤醒挂起的线程，造成死锁</p>
</li>
<li><p><code>sleep</code>通常用于暂停执行，相当于使其睡眠，而<code>wait</code>则通常用于线程间交互，相当于使其挂起</p>
</li>
<li><p><code>sleep</code>必须传入时间，超时即唤醒；<code>wait</code>可传可不传，不传的话，线程不会自动苏醒，需要别的线程调用<code>notify | notifyAll</code>方法</p>
</li>
<li><p><code>sleep</code>是<code>Thread</code>的静态本地方法，但是<code>wait</code>却是<code>Object</code>类的方法</p>
<p> 因为<code>wait</code>需要释放当前线程持有的对象锁，需要对对象进行操作，因此需要定义在<code>Object</code>中</p>
<p> 而<code>sleep</code>不需要释放对象锁，自然没有必要放在<code>Object</code>中</p>
</li>
</ol>
<hr>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p><strong>sleep(0)的意义</strong></p>
<p><code>sleep()</code>函数其实就是告诉系统接下来一段时间我不参与CPU调度，那么如果时间是0，也就是告诉系统马上触发一次CPU调度</p>
<p>比如单核CPU环境下，我们在大循环里面，写一个<code>sleep(0)</code>，就可以让出CPU给别的线程，比如界面绘制的线程，防止出现线程假死</p>
<p><strong>调用Thread.sleep(1000)，1000ms后线程会不会被执行</strong></p>
<p>调用<code>Thread.sleep(1000)</code>相当于告诉操作系统，未来的1000ms内我不参与CPU调度，但是过去了1000ms，可能另外一个线程正在使用CPU，操作系统不会进行CPU调度，睡眠的线程不一定会被执行，就算触发了CPU调度，也不一定就调度到当前这个线程</p>
<p>类似，<code>resume</code>函数也只是告诉操作系统，我要参与CPU调度了，但是不一定马上获取CPU时间片</p>
<hr>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p><strong>并发依赖于线程上下文切换</strong></p>
<p>想要实现并发，就需要能够通过CPU调度算法切换当前执行的进程，比如时间片轮转法，每个线程只能使用一小段CPU时间，然后不管执行完没有都要释放CPU使用权，而CPU能够继续执行下一个线程的后续指令，就需要能够获取下个线程上次暂存的 执行状态，所以上下文切换笼统来讲就是线程执行过程中的状态信息的切换，在切换到别的线程执行时，需要暂存当前线程的上下文，并加载下个线程的上下文</p>
<p>线程上下文切换的内容根据切换线程的关系会有所不同</p>
<ol>
<li><strong>不同进程</strong>，线程切换和进程切换一样，代价比较大，包括虚拟内存（表）、全局变量、寄存器等</li>
<li><strong>相同进程的不同线程</strong>，线程切换主要是线程私有的资源，包括程序计数器、栈信息等</li>
</ol>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>本质上都是通过<code>Thread</code>的<code>start()</code>方法来启动线程，但是可以有三种方法来编写线程的执行任务</p>
<h4 id="多线程编程方式"><a href="#多线程编程方式" class="headerlink" title="多线程编程方式"></a>多线程编程方式</h4><p><strong>继承Thread类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承Thread类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is child thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现Runnable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">// 本质上还是提交给Thread来执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现Callable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallerTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,i am running!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        FutureTask&lt;String&gt; task=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">CallerTask</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待执行完成，并阻塞等待获取返回结果</span></span><br><span class="line">            String result=task.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>实现接口 vs 继承Thread</strong></p>
<p>实现接口一般来说更常用</p>
<ol>
<li>java支持多实现，不支持多继承</li>
<li>为了实现多线程编程而继承整个Thread类太臃肿了</li>
</ol>
</blockquote>
<p><strong>线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTaskRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前任务由&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTaskCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前任务由&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">MyTaskRun</span>());</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">MyTaskRun</span>());</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">MyTaskRun</span>());</span><br><span class="line">        <span class="type">Future</span> <span class="variable">result</span> <span class="operator">=</span> executor.submit(<span class="keyword">new</span> <span class="title class_">MyTaskCall</span>());</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="start-vs-run"><a href="#start-vs-run" class="headerlink" title="start() vs run()"></a>start() vs run()</h4><p>理论上是可以的，正常我们是<code>new</code>一个<code>Thread</code>，线程进入新建状态，然后调用<code>thread</code>的<code>start</code>方法，该方法启动线程使其进入就绪状态，等待分配CPU时间片，这是一次多线程的执行。但是直接调用<code>run</code>方法，就是把该方法当做一个普通方法来执行，也就是说是在main线程下执行的，这就不是多线程了。</p>
<h4 id="runnable-vs-callable"><a href="#runnable-vs-callable" class="headerlink" title="runnable vs callable"></a>runnable vs callable</h4><ol>
<li><code>Runnable</code>的方法是<code>run()</code>，没有返回值，不允许通过<code>throws</code>抛出异常，异常只能内部处理；<code>Callable</code>的方法是<code>call()</code>，有返回值，允许<code>throws</code>抛出异常</li>
<li><code>Thread</code>只能直接接受<code>Runnable</code>的任务来执行，<code>Callable</code>需要包装成<code>FutureTask</code>才能以<code>Thread</code>的方式执行，线程池可以接受<code>Runnable</code>和<code>Callable</code>，线程池的<code>execute</code>方法只能接受<code>Runnable</code>，而<code>submit</code>则允许提交<code>Runnable</code>和<code>Callable</code>，但是接受<code>Callable</code>会返回<code>FutureTask</code>对象，而接受<code>Runnable</code>则返回<code>Null</code></li>
</ol>
<h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h4><p>接收参数：</p>
<ol>
<li><code>execute</code>只能接收<code>Runnable</code>类型的参数，没有返回值，如果需要返回值，可以通过共享变量 | 回调函数</li>
<li><code>submit</code>能够兼容<code>Runnable</code>类型和<code>Callable</code>类型，并且会返回一个<code>FutureTask</code>对象，通过这个对象可以<code>get()</code>阻塞获取返回值|异常或者<code>cancel()</code>中断执行，当然如果是<code>Runnable</code>类型，则返回<code>Null</code></li>
</ol>
<p>异常：</p>
<ol>
<li><code>execute</code>只能接收<code>Runnable</code>的任务，遇到异常直接抛出，在<code>run</code>方法内部通过<code>try catch</code>捕获和处理</li>
<li><code>submit</code>能够接收<code>Callable</code>的任务，遇到异常，会封装到<code>FutureTask</code>对象中，可以通过<code>FutureTask</code>对象的<code>get</code>方法进行捕获，然后处理</li>
</ol>
<p>阻塞：</p>
<ol>
<li><code>execute</code>无法阻塞，提交任务即返回</li>
<li><code>submit</code>可以设置阻塞的超时时间，先阻塞，超时之后取消任务并抛出异常</li>
</ol>
<p>应用场景</p>
<ol>
<li><code>execute</code>一般是用于提交<code>runnable</code>的任务</li>
<li><code>submit</code>一般用于提交<code>callable</code>的任务</li>
</ol>
<h4 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h4><ol>
<li><p>等待</p>
<ul>
<li><code>wait()</code>：当一个线程A调用一个共享变量的<code>wait()</code>方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：<ul>
<li>别的线程调用了共享对象 <code>notify()</code>或者 <code>notifyAll()</code>方法；</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>  - `wait(long)`：超时版本的`wait()`方法，如果超时也会结束阻塞状态


  - `join()`：如果一个线程A执行了`thread.join()`语句，其含义是：当前线程A等待`thread`线程终止之后才从`thread.join()`返回继续执行。
</code></pre><ol>
<li><p>唤醒</p>
<ul>
<li><code>notify()</code>：一个线程A调用共享对象的 <code>notify()</code> 方法后，会唤醒一个在这个共享变量上调用 <code>wait</code> 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li>
<li><code>notifyAll()</code> ：不同于在共享变量上调用 <code>notify()</code> 函数会唤醒被阻塞到该共享变量上的一个线程，<code>notifyAll()</code>方法则会唤醒所有在该共享变量上由于调用 <code>wait</code> 系列方法而被挂起的线程。</li>
</ul>
</li>
<li><p>谦让</p>
<ul>
<li><code>yield()</code>：<code>Thread</code>类中的静态方法，当一个线程调用 <code>yield</code> 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示</li>
</ul>
</li>
<li><p>中断</p>
<p> 准确来说，java中的线程中断不算协作，并且通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理，线程的中断方式如下</p>
<pre><code> 1. `interrupt()`方法中断线程，如果线程处于阻塞、等待状态就可以中断，会抛出`InterrruptedException`，如果是IO阻塞或者锁的阻塞，则无法中断
 2. 线程池的中断可以通过`shutdownNow()`方法进行中断，实际上就是遍历调用每个线程的`interrupt()`方法
</code></pre></li>
<li><p>休眠</p>
</li>
</ol>
<ul>
<li><code>sleep(long)</code> :<code>Thread</code>类中的静态方法，当一个执行中的线程A调用了<code>Thread</code>的<code>sleep</code>方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与CPU的调度，获取到CPU资源后就可以继续运行。</li>
</ul>
<p>详见<a href=".\26948.html">线程协作实践</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-数据类型详解</title>
    <url>/posts/62901.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>java和c++不一样，c++虽然也是面向对象编程，但是为了兼容c语言，所以也可以支持面向过程编程，而java则是纯面向对象编程，可以说所有数据结构在java中都是一种类</p>
<h3 id="java数据类型"><a href="#java数据类型" class="headerlink" title="java数据类型"></a>java数据类型</h3><p>实际上，java虽然主要都是引用类型，但是也存在8种基本数据类型，可以分为整型、浮点型、字符型和布尔型4类</p>
<h4 id="为什么保留基本数据类型"><a href="#为什么保留基本数据类型" class="headerlink" title="为什么保留基本数据类型"></a>为什么保留基本数据类型</h4><ol>
<li>计算性能，特别是以数值计算为主的应用</li>
<li>存储性能，int只需要4字节，而Integer则需要16字节</li>
</ol>
<p>当然实际上，也是可以在语法层面进行处理实现纯粹的引用类型的，比如对外只提供引用类型进行使用，底层将其转换为基本数据类型进行计算</p>
<h4 id="基本数据类型和引用类型的区别"><a href="#基本数据类型和引用类型的区别" class="headerlink" title="基本数据类型和引用类型的区别"></a>基本数据类型和引用类型的区别</h4><ol>
<li>基本数据类型，默认值依据类型决定，比如int的默认值是0，引用类型，是一种类，默认值是null，同时具备一些方法和属性，比如Object的原生方法</li>
<li>基本数据类型存储在栈中的，而引用类型一般存储在堆中，除非逃逸失败</li>
<li>基本数据类型的使用我们可以直接定义变量名赋值即可，引用类型则需要用new或者反射来创建新对象</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="基本数据类型及对应包装器类"><a href="#基本数据类型及对应包装器类" class="headerlink" title="基本数据类型及对应包装器类"></a>基本数据类型及对应包装器类</h4><p>java的基本数据类型及对应的包装器类如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>数据长度（字节）</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>Character</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>Double</td>
</tr>
</tbody>
</table>
</div>
<p><strong>什么是拆箱和装箱</strong></p>
<p>装箱就是指将基本数据类型包装为对应的包装类型的过程，拆箱就是反过来的过程</p>
<blockquote>
<p><code>Integer x = 2</code> 就是装箱</p>
<p><code>int y = x</code> 就是拆箱</p>
</blockquote>
<p>实际上，装箱调用的是包装器的<code>valueOf</code>方法，拆箱则调用包装器的<code>xxxValue</code>方法，比如<code>Integer.valueOf</code>和<code>Integer.intValue</code>方法</p>
<h4 id="java是值传递还是引用传递"><a href="#java是值传递还是引用传递" class="headerlink" title="java是值传递还是引用传递"></a>java是值传递还是引用传递</h4><p>java中的参数是以值传递的形式传入方法中的，而不是引用传递</p>
<p>虽然是值传递，但是比如传递类对象、数组等引用类型对象时，传递进去的是地址的值，所以方法内操作的是该地址存储的对象，实现了类似引用传递的效果</p>
<blockquote>
<p>比如传递一个整型数组，内部修改了这个数组，实际上就是修改了传进去的数组</p>
</blockquote>
<h4 id="缓冲池-常量池是什么"><a href="#缓冲池-常量池是什么" class="headerlink" title="缓冲池 | 常量池是什么"></a>缓冲池 | 常量池是什么</h4><p>缓存池就是存储一些基本类型的包装器类型对应的对象，除了Double和Float没有[浮点型数值变化大，难以确定哪些数值是经常使用的]，其他类型都有</p>
<blockquote>
<p>比如boolean类型在缓冲池中就有true和false两个对象，short和int类型则在-128到127之间存在Integer的对象</p>
</blockquote>
<p><strong>为什么是-128到127？</strong></p>
<p>范围的设置需要综合考虑性能和资源的平衡，所以不能无限存储，同时-128到127已经包括了开发经常需要使用的数据范围</p>
<p><strong>具体的体现呢？</strong></p>
<p>比如Integer.valueOf()方法的具体实现是首先判断值是不是在缓冲池，如果在就直接返回，不在则会新建一个，因此如果输入在-128到127之间，那么返回的就是缓冲池中同一个对象的引用，而如果不在这个范围内，则会新建，两次调用的返回值就不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">321</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">3L</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d); <span class="comment">// true 位于范围内</span></span><br><span class="line">        System.out.println(e==f); <span class="comment">// false 位于范围外</span></span><br><span class="line">        System.out.println(c==(a+b)); <span class="comment">// true a+b转换为int型 ==会进行自动拆箱</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">// true 都是3这个Integer对象</span></span><br><span class="line">        System.out.println(g==(a+b)); <span class="comment">// true 自动拆箱 变为long和int的数值比较</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">//  false 一个Long的3和一个Integer的3</span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">// true 向上转型→long 自动装箱→Long</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么浮点数会有精度丢失的风险"><a href="#为什么浮点数会有精度丢失的风险" class="headerlink" title="为什么浮点数会有精度丢失的风险"></a>为什么浮点数会有精度丢失的风险</h4><p>其实和计算机保存浮点数的机制有关，计算机都是用二进制进行数据保存的，比如需要保存10进制的0.3时[乘2取整法]，因为无法用有限位的$\frac{1}{2^n}$来表示，所以二进制表示是无限的</p>
<blockquote>
<p>0.3×2×2=1.2取整数为01</p>
<p>0.2×2×2×2=1.6取整数为001</p>
<p>0.6×2=1.2取整数为1</p>
<p>0.2×2×2×2=1.6取整数为001</p>
<p>后续无限循环1001</p>
<p>…</p>
<p>最后只能无限接近0.3，而无法精确表达0.3</p>
</blockquote>
<p>而计算机保存一个数据时，其宽度又是有限的，必然需要进行截断，所以就会导致精度损失</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型主要就是类对象和数组</p>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>深拷贝就是拷贝一个和原来对象一模一样的对象进行返回</p>
<p>浅拷贝就是直接返回这个对象的引用</p>
<p>因此对深拷贝的操作不会影响原来的对象，但是对浅拷贝的操作则会影响原来的对象</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>向下转型：高精度类型→低精度类型，比如long转为int，无法隐式执行，必须强制执行</p>
<p>向上转型：低精度类型→高精度类型 | 子类对象赋值给父类引用，是隐式执行的</p>
<p><strong>为什么+=不需要我们执行强制类型转换？</strong></p>
<p>因为+=操作本身已经进行了显式转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">x+=<span class="number">3.4</span> <span class="comment">// x = 6</span></span><br></pre></td></tr></table></figure>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><p><strong>金额相关的属性应该用什么类型</strong></p>
<p>比较注重精确度，可以用BigDecimal，但是会带来内存和性能的一定损耗，需要注意的是构造BigDecimal一般需要用String作为输入</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-泛型机制详解</title>
    <url>/posts/63184.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>java的泛型是什么？为什么要引入泛型？泛型如何使用？有哪些具体使用实例？什么是泛型擦除</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>java的泛型其实就是将被操作的数据类型指定为一个参数，是可以在使用时才决定具体类型的，java的泛型支持包括泛型类、泛型接口和泛型方法</p>
<p>泛型类：定义类时指定泛型，允许类属性、方法返回值和入参的类型是泛型</p>
<p>泛型接口：类似泛型类</p>
<p>泛型方法：定义方法时定义泛型，调用方法时通过传入Class<T>对象指定具体类型，允许返回值的类型、入参类型使用指定的具体类型</T></p>
<p><strong>为什么有了泛型类，还需要泛型方法？</strong></p>
<p>泛型方法和泛型类的粒度不同，可能存在某种业务场景，我只需要某几个方法用到泛型，而整个类不存在需要使用泛型的成员变量，而且也不是所有方法都需要使用泛型，那这个时候使用泛型类就不太合适，比如<a href="# MyBatis中MapperRegistry的实现">示例3</a></p>
<h4 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h4><p>java的泛型实际上是伪泛型，也就是在语法上支持泛型，而在编译期间就会擦除所有泛型信息，将其替换为具体的类型，也就是对应的原始类型，这也就是我们说的类型擦除，而真实泛型则是编译后也会保留泛型信息</p>
<p>关于原始类型，如果无限定那么就是<code>Object</code>，如果比如<code>extends SelfClass</code>，那么就是<code>SelfClass</code>，原始类型一般是各种类型的最小公共祖先类，一直到<code>Object</code></p>
<hr>
<ol>
<li>我们定义两个<code>list</code>，具体类型指定为<code>String</code>和<code>Integer</code>，但是实际上通过<code>getClass()</code>方法获取这两个<code>list</code>的类型都是<code>list</code>，也就是说<code>String</code>和<code>Integer</code>被擦除了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> ArrayList&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> ArrayList&lt;String&gt; arrayList2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> System.out.println(arrayList1.getClass()); <span class="comment">// class java.util.ArrayList</span></span><br><span class="line"> System.out.println(arrayList2.getClass()); <span class="comment">// class java.util.ArrayList</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li>通过反射其实也能验证，我们定义一个<code>Integer</code>的<code>list</code>，直接添加一个<code>String</code>是添加不了的，但是通过反射获取该类的<code>add</code>方法，进行调用添加<code>String</code>是可行的</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line"> ArrayList&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">// arrayList1.add(&quot;123&quot;); 报错 需要的类型Integer 提供的类型String</span></span><br><span class="line"> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> arrayList1.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"> method.invoke(arrayList1, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"> System.out.println(arrayList1.get(<span class="number">0</span>)); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>利用泛型可以实现</p>
<ol>
<li><p>代码复用，也就是说多种数据类型能够使用相同的代码</p>
</li>
<li><p>支持在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的</p>
</li>
</ol>
<blockquote>
<p>比如 ArrayList的引用如果不指定泛型，那么任何对象都可以传入，取出元素时就需要进行强制类型转换，且可能导致ClassCastException</p>
<p>指定String泛型，编译时就强制要求只有字符串能够存入，取出时也是String类型</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h4><p><strong>支持编译时类型检查的优势</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; extends... implements ...&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基于泛型 可以实现从存储E或者E的子类的对象集合进行ArrayList的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于泛型 可以获取具体类型的元素 类似的还有add set方法</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        Objects.checkIndex(index, size);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MyBatis中TypeHandler的实现"><a href="#MyBatis中TypeHandler的实现" class="headerlink" title="MyBatis中TypeHandler的实现"></a>MyBatis中TypeHandler的实现</h4><p><strong>如何基于泛型和映射表实现策略模式，TypeHandler的作用在于java类型和jdbc类型之间的转换</strong></p>
<p><strong>基类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseTypeHandler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">TypeReference</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">TypeHandler</span>&lt;T&gt; &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里其实也体现模板模式</span></span><br><span class="line">    <span class="comment">// 所有类型进行转换时都需要进行以下步骤</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 1. 检查参数是否为空</span></span><br><span class="line">        <span class="comment">// 2. 为空并且jdbc类型也为空 则报错 所有可以为Null的参数需要指定对应JDBC类型</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 否则说明参数为空 jdbc类型不为空 设置参数为Null</span></span><br><span class="line">        ps.setNull(i, jdbcType.TYPE_CODE);</span><br><span class="line">        <span class="comment">// 4. 参数不为空 进行参数类型转换</span></span><br><span class="line">        setNonNullParameter(ps, i, parameter, jdbcType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法 交给子类实现 参数类型为泛型 实现策略模式</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>String类型处理器实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="comment">// 入参类型为String</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, String parameter, JdbcType jdbcType)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Boolean类型处理器实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BooleanTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;Boolean&gt; &#123;</span><br><span class="line">  <span class="comment">// 入参类型为Boolean</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, Boolean parameter, JdbcType jdbcType)</span></span><br><span class="line">      <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ps.setBoolean(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如何选择合适的处理器<code>TypeHandlerRegistry</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TypeHandlerRegistry</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 注册类型处理器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="literal">null</span>) &#123;</span><br><span class="line">    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">null</span> || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">      map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(jdbcType, handler);</span><br><span class="line">    typeHandlerMap.put(javaType, map);</span><br><span class="line">  &#125;</span><br><span class="line">  allTypeHandlersMap.put(handler.getClass(), handler);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 获取类型处理器</span></span><br><span class="line">  <span class="keyword">public</span> TypeHandler&lt;?&gt; getMappingTypeHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&lt;?&gt;&gt; handlerType) &#123;</span><br><span class="line">  	<span class="keyword">return</span> allTypeHandlersMap.get(handlerType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反射构造类型处理器</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; TypeHandler&lt;T&gt; <span class="title function_">getInstance</span><span class="params">(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (javaTypeClass != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(Class.class);</span><br><span class="line">        <span class="keyword">return</span> (TypeHandler&lt;T&gt;) c.newInstance(javaTypeClass);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Failed invoking constructor for handler &quot;</span> + typeHandlerClass, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;?&gt; c = typeHandlerClass.getConstructor();</span><br><span class="line">      <span class="keyword">return</span> (TypeHandler&lt;T&gt;) c.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Unable to find a usable constructor for &quot;</span> + typeHandlerClass, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如何使用类型注册机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TypeHandler&lt;?&gt; resolveTypeHandler(Class&lt;?&gt; javaType, Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&lt;?&gt;&gt; typeHandlerType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeHandlerType == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取对应java类型的类型处理器</span></span><br><span class="line">    TypeHandler&lt;?&gt; handler = typeHandlerRegistry.getMappingTypeHandler(typeHandlerType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 没获取到 说明还没实例化 那就先实例化</span></span><br><span class="line">      handler = typeHandlerRegistry.getInstance(javaType, typeHandlerType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MyBatis中MapperRegistry的实现"><a href="#MyBatis中MapperRegistry的实现" class="headerlink" title="MyBatis中MapperRegistry的实现"></a>MyBatis中MapperRegistry的实现</h4><p><strong>泛型方法存在的必要性，MapperRegistry是存储映射器代理工厂实例的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 向注册机中注册DAO接口类对应的映射器代理工厂实例</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">loadCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> <span class="title class_">MapperProxyFactory</span>&lt;&gt;(type));</span><br><span class="line">        <span class="type">MapperAnnotationBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperAnnotationBuilder</span>(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据DAO接口类型获取映射器代理工厂，并返回实例化后的动态代理对象</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><p><strong>java泛型的上下限是什么</strong></p>
<p>通过extends和super限制了泛型具体类型的上限和下限</p>
<p><code>T extends Number</code>：<code>T</code>只能是<code>Number</code>或者<code>Number</code>的子类</p>
<p><code>? super String</code>：<code>?</code>只能是<code>String</code>或者<code>String</code>的父类，其实就是<code>Object</code></p>
<p><code>function(List&lt;? extends Animal &gt; animals)</code>：传入的<code>list</code>的泛型类型只要是<code>Animal</code>或者其子类都可以</p>
<p>方法定义如果是<code>function(List&lt;Animal&gt; animals)</code>：那么传入<code>List&lt;Dog&gt;</code>就会报错</p>
<hr>
<p><strong>为什么基本类型不能作为泛型</strong></p>
<p>因为当类型擦除后，原始类型变为<code>Object</code>，但是<code>Object</code>类型的引用不能指向<code>int</code>数据类型的值，只能指向<code>Integer</code>的值。</p>
<p>我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作</p>
<hr>
<p><strong>既然类型擦除会消除所有泛型信息，那么为什么不能在String的列表中添加整型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br><span class="line">list1.add(<span class="number">1</span>); <span class="comment">//编译不通过</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">// 返回类型就是String  </span></span><br><span class="line"></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); </span><br><span class="line">list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">// 返回类型就是Object</span></span><br></pre></td></tr></table></figure>
<p>其实就是体现了泛型的编译时的类型检测，而类型检测是针对引用的，而无关真正的引用对象，比如<code>ArrayList&lt;Integer&gt; list1</code>，检查的就是这个<code>list1</code>，规定了只能传入<code>Integer</code>，传入<code>String</code>就会报错</p>
<hr>
<p><strong>如何理解不能用泛型类进行实例化</strong></p>
<p>比如<code>T t = new T();</code>是错误的</p>
<p>因为在 java 编译器没法确定泛型参数化类型，也就找不到对应类的.class文件[类字节码文件]，所以自然就不行了。   如果我们确实需要实例化一个泛型，应该如何做呢？可以通过泛型方法+反射实现，传入具体的类名，内部调用类的<code>newInstance</code>实例化泛型的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T <span class="title function_">newTclass</span> <span class="params">(Class &lt; T &gt; clazz)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">  <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何理解泛型类中的静态变量和静态方法</strong></p>
<p>静态变量和静态方法不能使用泛型类定义的泛型，因为静态变量在类实例化对象前就需要初始化，而静态方法在类实例化对象前也允许被调用，没有实例化对象，就无法确定泛型的类型，静态变量和静态方法自然不能使用泛型类定义的泛型</p>
<p>但是静态方法如果被定义为泛型方法，则是可行的，泛型方法的泛型是方法定义的泛型，通过传入参数的形式来指定，不是类的泛型，不需要类实例化对象来指定类型</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-线程协作实践</title>
    <url>/posts/26948.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>当多个线程一起实现某个业务功能时，线程之间就需要协调一定的执行顺序，比如a线程负责任务1，b线程负责任务2，a、b线程可以并发执行，但是b线程最后一部分工作需要在a线程完成后才能继续执行，那么就需要协调a、b线程的执行顺序</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>在线程<code>a</code>内，调用了<code>b.join()</code>，那么线程<code>a</code>会暂时挂起，直到线程<code>b</code>执行完毕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread before&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread after&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">    		thread.join(); <span class="comment">// 等待thread执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">      	<span class="comment">// main begin</span></span><br><span class="line">      	<span class="comment">// thread before</span></span><br><span class="line">      	<span class="comment">// thread after</span></span><br><span class="line">				<span class="comment">// main end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h3><p>等待和唤醒是相对的，当前线程等待就得有另外一个线程进行唤醒，否则程序就永远等待下去了，并且一般配合<code>synchronized</code>一起使用</p>
<p><strong>生产者线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Object lock;    <span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Object lock)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.lock=lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeFood</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (Main.foods.size()==<span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在等待食物&quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在吃&quot;</span>+Main.foods.poll());</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Consumer consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsumerThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.consumer = <span class="keyword">new</span> <span class="title class_">Consumer</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            consumer.consumeFood();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Object lock;    <span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Object lock)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.lock=lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeFood</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (Main.foods.size()==<span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在等待食物&quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在吃&quot;</span>+Main.foods.poll()+<span class="string">&quot;,还剩&quot;</span>+Main.foods.size()+<span class="string">&quot;这么多食物&quot;</span>);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Consumer consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsumerThread</span><span class="params">(Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.consumer = <span class="keyword">new</span> <span class="title class_">Consumer</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            consumer.consumeFood();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadCooperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; foods = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, String&gt; idToFood = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="number">0</span>, <span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        put(<span class="number">1</span>, <span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">        put(<span class="number">2</span>, <span class="string">&quot;西瓜&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 生产者消费者模式</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ProducerThread</span>(lock), <span class="string">&quot;生产者1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ConsumerThread</span>(lock), <span class="string">&quot;消费者1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await signal signalAll"></a>await signal signalAll</h3><p>JUC提供了<code>Condition</code>类实现线程之间的协作。可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或 <code>signalAll()</code>方法唤醒等待的线程。相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活。</p>
<p>写两个线程，其中一个线程打印1-52，另外一个线程打印A-Z，打印顺序为12A34B56C…5152Z</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ArrayList&lt;T&gt; arrayList;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">globalSequence</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 全局sequence</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">localSequence</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 局部sequence</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Print</span><span class="params">(ArrayList&lt;T&gt; arrayList, <span class="type">int</span> length, <span class="type">int</span> priority, <span class="type">int</span> total)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (localSequence&lt; arrayList.size()) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (globalSequence % total == priority) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                        System.out.println(arrayList.get(localSequence++));</span><br><span class="line">                    &#125;</span><br><span class="line">                    globalSequence++;</span><br><span class="line">                    c.signalAll();</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">52</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Character&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            strings.add((<span class="type">char</span>) (i+<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Print&lt;Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Print</span>&lt;&gt;(numbers, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        Print&lt;Character&gt; p2 = <span class="keyword">new</span> <span class="title class_">Print</span>&lt;&gt;(strings, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-类详解</title>
    <url>/posts/37249.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>java是纯面向对象的编程语言，所有类，包括我们自己编写的类，都是Object的子类</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是对具有相同特征的实体的抽象，是面向对象编程的核心，基于类我们才能实现封装、继承、多态等面向对象的三大特性。</p>
<h4 id="封装-继承-多态"><a href="#封装-继承-多态" class="headerlink" title="封装 | 继承 | 多态"></a>封装 | 继承 | 多态</h4><p><strong>封装</strong>：将实体抽象成一个对象，并将其所具备的属性和方法封装在一起，使其构成一个不可分割的独立实体，对外隐藏内部细节，只提供必要的方法供外部使用</p>
<blockquote>
<p>手机不知道里面有哪些元器件，一般也不能随意拆开，元器件就是属性，一般不直接对外暴露，但是只要手机没坏，我们就可以通过触摸屏使用手机，也就是手机对外提供的方法：响应触屏操作</p>
</blockquote>
<p><strong>继承</strong>：实现了IS-A的关系，拥有父类所有属性和方法，但是私有属性和方法无法访问，同时拥有自己的特征[属性和方法]；</p>
<blockquote>
<p>猫是一种动物，猫继承了动物类，也就有了动物的属性和方法，但是猫也有自己的特征，比如叫声不一样</p>
</blockquote>
<p><strong>多态</strong>：分为运行时多态和编译时多态，编译时多态一般就是方法重载，根据方法的参数不同，执行不同的方法；运行时多态则需要实现继承、重写和向上转型，指对象引用所指向的具体类型在运行时才能确定，一般是父类的引用指向子类的对象</p>
<blockquote>
<p>父类数组，存储子类对象，遍历执行时会调用子类重写的方法</p>
</blockquote>
<h4 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h4><ul>
<li><strong>重写</strong> ：继承关系中，覆盖原来的实现，也就是说子类实现了一个和父类完全一样的方法，需要满足访问权限子类大于父类，也就是访问权限变松，子类返回类型是父类同类型或者子类型，使用 @Override 注解</li>
<li><strong>重载</strong>：一个类中参数列表不同的同名方法，参数列表不同指的是参数类型、个数、顺序至少有一项不同，返回值不同不算重载，无法通过编译，因为不知道要调用哪个方法</li>
</ul>
<h4 id="类的访问修饰符"><a href="#类的访问修饰符" class="headerlink" title="类的访问修饰符"></a>类的访问修饰符</h4><p>访问修饰符可以修饰类的属性和方法，其目的在于保证封装这个特性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类(不同包)</th>
<th>不同包(其他类)</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>protected</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
</tr>
<tr>
<td>default</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>private</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>
</div>
<p><strong>父类和子类的访问权限关系</strong></p>
<ul>
<li><p>子类访问权限比父类更松</p>
<p>父类: <code>private</code> </p>
<p>子类: <code>public</code></p>
</li>
<li><p>子类的方法返回值类型是父类的方法返回值类型的子类或者同类</p>
<p>父类: <code>Object</code></p>
<p>子类: <code>String</code></p>
</li>
<li><p>子类抛出的异常范围&lt;父类抛出的异常范围</p>
<p>父类: <code>Exception</code></p>
<p>子类: <code>IOException</code></p>
</li>
</ul>
<h4 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h4><p>类主要有三种关系，泛化（继承）、实现（接口）、组合 | 聚合（成员变量）</p>
<h5 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h5><p>泛化（继承）指的是子类继承父类（具体类 | 抽象类），表示一种IS-A的关系</p>
<p>子类会拥有父类的所有属性和方法，但是无法访问private的方法</p>
<blockquote>
<p>就像你虽然继承了家族遗产，但是没有给你密码，你也用不了</p>
</blockquote>
<p>泛化的实现有两种</p>
<ol>
<li>extends，直接继承具体父类或者抽象父类</li>
<li>组合的方式，父类对象作为子类的成员变量（其实不能确定是不是一种泛化的实现，有点偏代理的感觉）</li>
</ol>
<blockquote>
<p>java中类加载的双亲委派机制，子类加载器和父类加载器就是以组合的方式实现类继承效果的，子类加载器在加载类时，会先委托给父类加载器进行加载</p>
</blockquote>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>实现指的是类实现接口，具备接口所规范的某种功能</p>
<p>类实现接口，会拥有接口所定义的方法、属性</p>
<p>需要注意接口中</p>
<ol>
<li><p>方法默认是public，但是也允许private进行修饰</p>
<p> <strong>需要显式声明，已声明则必须实现</strong></p>
</li>
<li><p>属性默认是public static final，并且不允许修改</p>
<p><strong>默认的意思是，即便不加修饰符，也会在编译时自动补全</strong></p>
</li>
<li><p>方法可不实现，也可以有实现[需要用default修饰，之前只能抽象方法]</p>
</li>
</ol>
<p>实际上，接口的规范是在JDK8和9时新增了默认实现、私有方法和静态方法</p>
<p><strong>私有方法只能接口内部调用，有什么作用呢？</strong></p>
<p>比如接口提供了3个方法的默认实现，3个方法有重复代码段，首先想到的就是将其抽象为一个方法，但是该方法默认是public，实现该接口的类就能直接使用该方法了，安全性遭到破坏，所以就引入了private的default方法</p>
<h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>一般是以成员变量的形式实现的，组合的作用很多</p>
<ol>
<li>实现继承关系，比如java类加载器的双亲委托机制</li>
<li>代理模式，比如静态代理显式持有被代理对象，通过被代理对象调用原本的方法；JDK动态代理是动态生成被代理接口的实现类，该类持有调用处理器执行附加的额外逻辑</li>
<li>装饰器模式，比如MyBatis中，CacheingExecutor持有一个名为delegate的成员变量，delegate是基本的三种执行器，通过delegate能够调用原始执行器的相关方法</li>
</ol>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数的作用就是执行类的初始化工作，名字和类名一致，无返回值，但是不能用void声明，new的时候自动调用，当然也可以通过反射机制获取类的构造函数，用newInstance方法调用</p>
<p><strong>没有构造函数会有问题吗</strong></p>
<p>没问题，执行默认的无参构造函数[自动生成的]，但是如果我们自己实现了构造函数，那么就不会有默认的无参构造函数，此时new对象如果不传参就会报错</p>
<p><strong>定义无参、不做事的构造函数的原因</strong></p>
<p>在构造子类对象时，如果没有显式地用super调用父类的构造方法，则会默认执行父类的无参构造方法，而如果父类没有无参构造方法[有可能存在自动生成的默认构造函数]，则会报错，因此可以在父类定义一个不做事且无参的构造方法[已经定义了有参构造函数，额外定义一个无参、不做事的构造函数]</p>
<p><strong>构造器链是什么</strong></p>
<p>当你在一个构造函数中调用另一个构造函数，就是构造器链。这种情况只在重载了类的构造器的时候才会出现</p>
<blockquote>
<p>比如 一个类是用户 包括 设置用户名、ID、密码、头像的构造函数 A和一个设置用户名、ID、密码、头像、性别的构造函数B</p>
<p>B的代码中可以调用构造函数A，避免写太多的this.x=x</p>
</blockquote>
<h3 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h3><p>类生命周期一般包括：加载→连接:[验证→准备→解析]→初始化→[使用→卸载]，其中加载到初始化，统称为<strong>类加载过程</strong></p>
<p>虽然生命周期包括上述阶段，但是实际上为了支持java语言的动态性，解析阶段有可能是在初始化之后才开始的</p>
<h4 id="类加载目标"><a href="#类加载目标" class="headerlink" title="类加载目标"></a>类加载目标</h4><p>类加载，就是把类对应的.class文件加载到内存中（类的元数据、类的静态变量、类的Class对象），方便我们后续使用</p>
<p><img src="/posts/37249/image-20230907141755084.png" alt="image-20230907141755084"></p>
<ol>
<li>安全检查</li>
<li>把.class文件扔到内存中，要不然使用的时候找不到[<strong>类的元数据</strong>]</li>
<li>提供程序员访问类信息的入口[<strong>class对象</strong>]</li>
<li>分配内存，存储类的静态变量，设置静态变量的值[<strong>静态变量</strong>]</li>
<li>确定类的方法怎么调用，静态变量怎么访问[<strong>类的元数据</strong>]</li>
</ol>
<h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><ol>
<li><p>加载阶段：通过类全名找到.class文件，将其转换为运行时数据结构[常量池、类字段、类方法]，装载到元空间中，并在堆中生成一个class对象[只是一个指针，指向元空间的类元数据]作为访问入口[<code>getClass()</code> | <code>Class.forname()</code>]</p>
</li>
<li><p>验证阶段：被加载的类是否规范，是否满足虚拟机安全性的约束</p>
</li>
<li><p>准备阶段：为类静态变量分配内存，并依据类型设置初始值，比如int为0，boolean为false</p>
<blockquote>
<p>static final修饰的直接赋值为具体值</p>
</blockquote>
</li>
<li><p>解析阶段：将常量池内的符号引用替换为直接引用[指针或者偏移量]，方便后续调用</p>
<blockquote>
<p>程序执行方法时，需要知道方法在哪里可以调用，虚拟机为每个类准备了一个方法表，只要知道方法的偏移量就能定位调用到这个方法，解析就是将符号引用替换为在方法表中的位置的过程</p>
</blockquote>
</li>
<li><p>初始化阶段：真正执行类中定义的Java程序代码[实际上是字节码]，到这里才会给静态变量赋我们给的初始值，并且通过锁的机制保证只初始化一次</p>
<p><strong>什么时候会触发类的初始化呢？</strong>就是看啥时候需要访问类的静态变量或者调用静态方法</p>
<ol>
<li>new一个类的实例</li>
<li>访问类的静态变量</li>
<li>调用类的静态方法</li>
<li>初始化A类时，如果发现A类的父类没有初始化，就得先初始化父类</li>
<li>通过反射调用类</li>
</ol>
</li>
</ol>
<p><img src="/posts/37249/image-20230907162658407.png" alt="image-20230907162658407"></p>
<h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>首先，类卸载意味着类的class对象，类的元数据都被垃圾回收，需要满足以下条件：</p>
<ol>
<li>所有实例对象都已被回收，堆中没有任何类的对象或者子类对象</li>
<li>该类对应的Class对象没有在其他地方被引用，无法通过反射访问该类</li>
<li>该类的类加载器已经被回收</li>
</ol>
<p>一般不会发生类卸载，因为虚拟机的类加载器[BootstrapClassLorder | ExtesionClassLorder | AppClassLorder]不会被回收（但是我们自定义的类加载器加载的类可能会被回收），所以不满足类卸载的第3个条件，自然不会卸载</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>类加载器就是专门负责加载类的类，主要方法是<code>findClass()</code>和<code>loadClass()</code>，需要将.class文件装载到虚拟机，在堆中生成一个代表该类的从class对象。</p>
<h4 id="类加载策略"><a href="#类加载策略" class="headerlink" title="类加载策略"></a>类加载策略</h4><ol>
<li><p><strong>全盘负责</strong>：负责加载该类的类加载器默认会一并负责加载该类所依赖和引用的其它类</p>
</li>
<li><p><strong>缓存机制</strong>：保证所有加载过的类不会重复加载，加载前先去缓存中看能不能找到这个类，找不到才去加载</p>
</li>
<li><p><strong>双亲委派机制</strong>：如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p>
<blockquote>
<p>比如我们自己编写一个Objec类，程序运行时，就会有两个Object，双亲委派能够确保加载的是原生的Object。这是因为加载时，首先找AppClassLorder，AppClassLorder找ExtensionClasslorder，最后找到BootstrapClassLoader进行加载，它发现Object已经加载过了，就不会加载了</p>
</blockquote>
</li>
<li><p><strong>按需加载</strong>：虚拟机启动的时候不会一次性加载所有类，而是按需动态加载，也就是在具体用到的时候再加载</p>
</li>
</ol>
<h4 id="内置类加载器"><a href="#内置类加载器" class="headerlink" title="内置类加载器"></a>内置类加载器</h4><ol>
<li><strong><code>BootstrapClasslorder</code>(启动类加载器)</strong>：最顶层的加载类，getParent()获取到的是null[C++实现，自然没有父类]，主要用来加载JDK内部的核心类库</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 JDK扩展目录下的jar包，父类是BootstrapClasslorder</li>
<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类，其实就是用户自定义的类，父类是ExtensionClassLoader</li>
</ol>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>比如我们可以对.java文件进行加密，类加载器先要解密才能加载</p>
<p>自定义首先需要继承classlorder这个类，有两个方法可以重写</p>
<ol>
<li><code>findClass()</code>:根据类的二进制名称来查找类</li>
<li><code>loadClass()</code>:加载指定二进制名称的类，实现了双亲委派机制 </li>
</ol>
<p>一般来说，只需要重写<code>findClass</code>方法即可，如果需要打破双亲委派机制，那么可以重写<code>loadClass</code>方法，没事不要打破</p>
<h4 id="双亲委派实现"><a href="#双亲委派实现" class="headerlink" title="双亲委派实现"></a>双亲委派实现</h4><p>双亲委派在类加载器的<code>loadClass</code>()中实现，具体如下</p>
<p><img src="/posts/37249/image-20230907190903948.png" alt="image-20230907190903948"></p>
<p>基于上述实现流程，当一个类加载器收到类加载请求时，首先判断是否加载过，没有加载过的话，就把这个请求委派给它的父类加载器去完成，形成一个双亲委派的链条。</p>
<p><img src="/posts/37249/image-20230907195941754.png" alt="image-20230907195941754"></p>
<p>只有父类加载器在它的搜索范围内无法找到所需的类时，子加载器才会尝试自己去加载这个类，而子类 父类的关系实际上是组合，以成员变量的方式实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object是java所有类的父类，拥有很多原生方法，按照对象操作、线程操作等可以进行划分</p>
<p><img src="/posts/37249/image-20230908143053788.png" alt="image-20230908143053788"></p>
<h4 id="equals-对比"><a href="#equals-对比" class="headerlink" title="equals 对比 =="></a>equals 对比 ==</h4><ol>
<li><p><code>==</code>是操作符，<code>equals</code>是<code>Object</code>的原生方法</p>
</li>
<li><p>判断对象是否相等的逻辑不同</p>
<ol>
<li><p>基本数据类型，只能用<code>==</code>判断两个值是否相等，无法调用<code>equals</code>方法</p>
</li>
<li><p>引用类型，<code>==</code>判断是否引用了同一个对象，比较的是内存地址，<code>equals</code>是判断引用的对象是否等价，如果没有重写<code>equals</code>方法，等价于<code>==</code>判断</p>
<blockquote>
<p>一般需要重写该方法，根据依据内容是否相等来判断，比如Integer类就重写了该方法，依据值进行比较</p>
<ol>
<li>同一个对象的引用，返回true</li>
<li>不同类型 或者 入参为空，返回false</li>
<li>进行类型转换，判断每个字段是否相等，全部相等返回true</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">      <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="equals-和-hashCode"><a href="#equals-和-hashCode" class="headerlink" title="equals 和 hashCode"></a>equals 和 hashCode</h4><p><code>hashCode</code>返回一个整型的哈希值，用于计算对象在哈希表中的索引位置，主要作用在于寻址，减少查询时间而不是用来判断是否相等的</p>
<blockquote>
<p>比如，在<code>list</code>中如果要判断元素是否存在，需要遍历，但是用<code>hashset</code>可以快速定位到桶[链表 | 红黑树]的位置，这个桶里如果都没有，那么不可能存在</p>
<p>上述实现可行的原因在于：<strong>对象相等→哈希值相等→位于同一个桶</strong></p>
</blockquote>
<p><code>hashCode</code>基于内容计算哈希值的，虽然相等的概率很小，但是也是有可能的</p>
<p><strong>为什么两个不同对象的哈希值</strong></p>
<p>实际上是因为不管我们的计算方式多么复杂，取值范围依然是无限大的，但是哈希值的范围只是一个整型，所以肯定会存在哈希冲突，下面是两个String字符串拥有相同的哈希码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;FB&quot;</span>; <span class="comment">// new String的方式也是一样的 因为byte数组是一样的</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Ea&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode1</span> <span class="operator">=</span> str1.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode2</span> <span class="operator">=</span> str2.hashCode();</span><br><span class="line">    System.out.println(<span class="string">&quot;Hash code for str1: &quot;</span> + hashCode1); <span class="comment">// 都是2236</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hash code for str2: &quot;</span> + hashCode2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals</code>判断两个对象是否等价，等价的对象哈希值必定相等，但是哈希值相同的两个对象，不一定等价，也就是所谓的哈希冲突</p>
<p>重写<code>equals</code>方法，需要重写<code>hashCode</code>()方法，保证哈希值一样</p>
<blockquote>
<p>比如业务逻辑上，我们重写<code>equals</code>方法实现“如果学生的所有字段的值都一致，那就是同一个对象”，但是没有重写<code>hashCode</code>方法：假设此时，我们需要将学生置于<code>HashSet</code>中进行注册信息的去重，那么因为<code>HashSet</code>是先用哈希值计算下标，再调用<code>equals</code>比较是否相等，而原生<code>hashCode</code>方法基于内存地址计算哈希值，自然不相等，那就无法实现去重的功能了</p>
</blockquote>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><p><code>clone</code>方法是<code>Object</code>的<code>protected</code>方法，负责深拷贝（新对象），无法直接调用。</p>
<ol>
<li><p>为什么不能访问protected方法呢？protected不是允许不同包的子类调用吗？</p>
<p>因为protected所允许的不同包的子类调用是指 在子类中可以访问继承来的成员，用该成员可以访问protected方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Main</span> <span class="variable">main1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">		<span class="type">Main</span> <span class="variable">main2</span> <span class="operator">=</span> main1.clone(); <span class="comment">// 报错:clone()在java.lang.Object中具有protected访问权限</span></span><br><span class="line">		<span class="type">Main</span> <span class="variable">main3</span> <span class="operator">=</span> main1.copy(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Main <span class="title function_">copy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException&#123;</span><br><span class="line">		<span class="keyword">return</span> (Main) <span class="built_in">this</span>.clone(); <span class="comment">// 允许调用 成功执行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何实现深拷贝呢？</p>
<p>需要实现<code>cloneable</code>接口然后重写<code>clone</code>方法，但是<code>clone</code>方法不是这个接口定义的，而是<code>Object</code>类中的一个<code>protected</code>方法，<code>cloneable</code>只是一个规定，这种方法复杂还有风险，一般使用拷贝构造函数或者拷贝工厂来实现深拷贝，比如对于一个类，拷贝构造函数就是实例化一个类对象，按照类原本的字段值进行赋值，然后返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">(Main main)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = main.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>(main1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="hashCode-的乘数31"><a href="#hashCode-的乘数31" class="headerlink" title="hashCode()的乘数31"></a>hashCode()的乘数31</h4><p>以<code>String</code>对象的哈希计算为例：<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></p>
<p>每个值都需要和31相乘，为什么选择31呢？</p>
<p>实际上需要考虑</p>
<ol>
<li>哈希冲突：太小哈希冲突比较严重，质数难以整除任何数，也不会被任何数整除，哈希冲突概率很小，下标分布更为均匀</li>
<li>信息保留：取值太大，哈希值可能超过int型的表示范围，导致丢失信息</li>
<li>优化：任意数与$2^n$相乘，可以用左移操作进行优化$31×i=(32-1)×i=2^5×i-i=(i&lt;&lt;5)-i$，因为不能直接用偶数，所以选择差值为1的质数</li>
</ol>
<p>综上所述，选择31</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>this是指向自己的指针，一般用于</p>
<ol>
<li>避免属性和入参重名</li>
<li>调用另外一个构造函数，形成构造器链</li>
</ol>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ul>
<li><p><code>super()</code>访问父类构造函数，委托父类进行初始化工作</p>
</li>
<li><p><code>super.func()</code>访问父类的方法，比如子类重写了某个方法，用super可以访问父类的实现</p>
</li>
<li><code>super.x</code>访问父类的非私有属性，私有属性无法访问</li>
</ul>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>数据：<code>final</code>将数据声明为不可变的。基本类型，值不可变；引用类型，不能引用其他对象[但被引用的对象的内容可修改]</p>
<p>方法：该方法不能被子类重写，如果有相同签名的方法，实际上是新的方法，<code>private</code>的方法隐式指定为<code>final</code></p>
<p>类：类不允许被继承</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>静态变量</strong>：该变量是属于类的，而不属于类对象，类所有实例共享静态变量，可以直接通过类名进行访问，内存中只存在一份，在类加载的准备阶段为静态变量准备内存空间，并赋予基于类型的初始值，然后在初始化阶段修改为真正的初始值</p>
<p><strong>静态方法</strong>：也是属于类的，因此必须实现，并且在类没有实例化前就能调用，因此只能访问静态变量和调用静态方法</p>
<p><strong>静态语句块</strong>：类初始化时运行一次，先于构造方法执行，主要用于一次性地对类进行初始化设置</p>
<p><strong>静态内部类</strong>：非静态内部类依赖于外部类的实例，而静态内部类不需要，因此静态内部类不能访问外部类的非静态的常量和方法</p>
<p>上述概念都需要用<code>static</code>进行声明</p>
<p><strong>初始化顺序</strong>：</p>
<ol>
<li>静态变量和静态代码块的执行顺序取决于代码顺序</li>
<li>实例变量和普通语句块</li>
<li>构造函数</li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li>属于类，不需要创建类对象就可以访问</li>
<li>全局唯一，可以用来表示全局状态</li>
<li>不同线程可以共享</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>不会自动摧毁</li>
<li>多线程需要考虑并发问题</li>
</ol>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><p><strong>数组类是如何创建的？</strong></p>
<p>数组类不是由classlorder创建的，而是虚拟机在需要的时候自动创建的，而数组类通过getClasslorder方法获取到的类加载器和该数组的元素类型的类加载器一致</p>
<hr>
<p><strong>如何判断两个类是否是一样的</strong></p>
<p>不仅仅依靠类的全名，还要看类的加载器是否一致</p>
<hr>
<p><strong>什么叫类优先原则</strong></p>
<p>子类（实现类）继承了父类并实现了接口；父类和接口中声明了同名同参数的方法。</p>
<p>默认情况下，子类（实现类）在没有重写此方法的情况下，调用的是父类的方法，而不是接口中的方法，通过接口名.super.方法名，可以调用接口的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SelfClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelfInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SelfInterface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SelfClass</span> <span class="keyword">implements</span> <span class="title class_">SelfInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringHashExample</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringHashExample</span>();</span><br><span class="line">        str.test(); <span class="comment">// 打印SelfClass</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>抽象类和接口的区别</strong></p>
<p><strong>关键字</strong>：接口用<code>interface</code>来定义，用<code>implements</code>来实现；抽象类用<code>abstract</code>定义，用<code>extends</code>来继承</p>
<p><strong>类关系</strong>：接口允许多实现，抽象类只能单继承</p>
<p><strong>修饰符</strong>：接口方法的修饰符默认为<code>public</code>[也可以<code>private</code>]，抽象方法不能为<code>private</code>，因为本来就是给子类去实现的</p>
<p><strong>成员变量</strong>：抽象类可以有普通成员变量，起到占位符的作用，相当于约定有这么个属性，接口的成员变量只能是<code>public static final</code></p>
<p><strong>作用</strong>：抽象类是IS-A的关系，比如狗是一种动物，是对公共属性和方法的抽取；接口则是对能力的抽取，也可以作为一种规范和约束</p>
<p><strong>为什么要使用接口</strong></p>
<p>主要是因为类只能单继承，接口允许多实现，使用起来更加方便，比如JDK动态代理就是基于接口的实现类定义的</p>
<hr>
<p><strong>什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?</strong></p>
<p>不可变就是指对象一旦被创建，状态不能被改变，任何修改实际上都是创建一个新的对象，比如String、Integer或者其他包装类</p>
<p>怎么创建呢？需要满足以下原则</p>
<ol>
<li>类的所有属性是final的，并且是private的</li>
<li>类是final的，限制子类继承父类改变父类的不可变性质</li>
<li>类不提供对属性的set方法供外部使用</li>
<li>类的字段如果需要访问，则提供字段的深拷贝</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>java-线程安全实践</title>
    <url>/posts/4986.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>实现线程安全的方法包括</p>
<ol>
<li><p><strong>互斥同步</strong></p>
</li>
<li><p><strong>非阻塞同步</strong></p>
</li>
<li><p><strong>无同步</strong></p>
</li>
</ol>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>一种悲观的并发策略，认为只要不加控制就会出现并发问题，所以需要用<a href="./38827.html">锁机制</a>使得同步块任意时刻只有一个线程执行</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>JVM实现的<code>synchronized</code>关键字，拓展见<a href>synchronized详解</a></p>
<p><img src="/posts/4986/image-20230918145637269.png" alt="image-20230918145637269"></p>
<h5 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SynchronizedTest</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;-&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> java.util.concurrent.Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            synchronizedTest1.func1();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            synchronizedTest1.func1();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>正在打印 <span class="number">0</span> </span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">0</span> </span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">1</span> </span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">1</span> </span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">2</span> </span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">2</span> </span><br></pre></td></tr></table></figure>
<h5 id="语句块-this-非静态方法"><a href="#语句块-this-非静态方法" class="headerlink" title="语句块(this) | 非静态方法"></a>语句块(this) | 非静态方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SynchronizedTest</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> java.util.concurrent.Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            synchronizedTest1.func1();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            synchronizedTest1.func1();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>正在打印 <span class="number">0</span></span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">1</span></span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">2</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">0</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">1</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h5 id="this-class-静态方法"><a href="#this-class-静态方法" class="headerlink" title="this.class | 静态方法"></a>this.class | 静态方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SynchronizedTest</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> java.util.concurrent.Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            synchronizedTest.func1();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            SynchronizedTest.func2();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>正在打印 <span class="number">0</span></span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">1</span></span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">2</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">0</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">1</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h5 id="class-和-this"><a href="#class-和-this" class="headerlink" title=".class 和 this"></a>.class 和 this</h5><p>类的class和类的实例是不冲突的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SynchronizedTest</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">&quot;正在打印 &quot;</span>+i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> java.util.concurrent.Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            synchronizedTest1.func1();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            SynchronizedTest.func2();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>正在打印 <span class="number">0</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">0</span></span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">1</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">1</span></span><br><span class="line"><span class="number">14</span>正在打印 <span class="number">2</span></span><br><span class="line"><span class="number">15</span>正在打印 <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><code>ReentrantLock</code>是 java.util.concurrent(J.U.C)包中的锁，拓展见<a href>ReentrantLock详解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockTest</span> <span class="variable">lockExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockTest</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">        executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要问题就是线程阻塞和唤醒带来的性能损失，因此java对synchronized进行了锁升级机制的优化。此外，非阻塞同步也是一种实现线程安全的方法，非阻塞同步实际上是乐观锁，也就是说先操作，如果没有其他线程竞争，那么操作就成功了，否则采取补偿措施[不断重新操作，直到成功]</p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>Comapre and Swap | Set，是一条依靠硬件实现的CPU的原子指令，作用是原子性地更新值，实际上这是一种乐观锁，就是说我们假设不会出现并发问题，自己管自己操作，操作完再检测是否有效。</p>
<p>检测最简单的办法就是读取的时候保存一下更新前的值，写回去的时候看一下当前内存中的值和之前拿出去的值是否一致，如果一致，则认为中间没有别的线程操作过，当前线程的更新操作就是有效的。因此，CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>
<h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>J.U.C包里面的整数原子类 <code>AtomicInteger</code>，提供<code>compareAndSet</code>() 和 <code>getAndIncrement()</code> 等方法都使用了 Unsafe 类的 CAS 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var1表示内存地址 var2表示偏移量 var4表示需要增加的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2); <span class="comment">// 内存中获取的旧值</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4)); <span class="comment">// 如果var5+var4 = 当前内存值+var4 那么就更新成功</span></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用AtomicInteger实现多线程安全并发+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                a.incrementAndGet();</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                a.incrementAndGet();</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20000</span></span><br><span class="line">b = <span class="number">13153</span></span><br></pre></td></tr></table></figure>
<h4 id="CAS的缺陷"><a href="#CAS的缺陷" class="headerlink" title="CAS的缺陷"></a>CAS的缺陷</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>CAS有可能出现ABA问题，也就是说CAS只是单纯比较旧值是否被改变，如果一开始是A，一个线程读取到A，此时内存中的A被修改为B又被修改回了A，对于这个线程来说，他认为A是没有被修改的，但是实际上修改了两次，只是恰好还是原来的值，解决办法是用版本号，比如1A→2B→3A，java提供<code>AtomicStampedReference</code>解决这个问题。此外，<code>AtomicMarkableReference</code>直接维护一个boolean类型的变量表示值是否有修改，也能解决ABA问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASR</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;,初始值 a = &quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedRef.getStamp(); <span class="comment">//获取当前版本</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">//等待1秒 ，以便让干扰线程执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isCASSuccess</span> <span class="operator">=</span> atomicStampedRef.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>);  <span class="comment">//此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;,CAS操作结果: &quot;</span> + isCASSuccess);</span><br><span class="line">        &#125;, <span class="string">&quot;主操作线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread <span class="title function_">second</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// 确保thread-first 优先执行</span></span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;,【increment】 ,值 = &quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">2</span>, <span class="number">1</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;操作线程&quot;</span> + Thread.currentThread() + <span class="string">&quot;,【decrement】 ,值 = &quot;</span> + atomicStampedRef.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;干扰线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        first().start();</span><br><span class="line">        second().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">操作线程Thread[主操作线程,<span class="number">5</span>,main],初始值 a = <span class="number">1</span></span><br><span class="line">操作线程Thread[干扰线程,<span class="number">5</span>,main],【increment】 ,值 = <span class="number">2</span></span><br><span class="line">操作线程Thread[干扰线程,<span class="number">5</span>,main],【decrement】 ,值 = <span class="number">1</span></span><br><span class="line">操作线程Thread[主操作线程,<span class="number">5</span>,main],CAS操作结果: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="自旋无用开销"><a href="#自旋无用开销" class="headerlink" title="自旋无用开销"></a>自旋无用开销</h5><p>CAS使用自旋避免阻塞，如果长时间执行不成功，会给CPU会带来较长时间的无用执行开销，浪费CPU性能</p>
<h5 id="多个变量原子性"><a href="#多个变量原子性" class="headerlink" title="多个变量原子性"></a>多个变量原子性</h5><p>CAS本身只能保证单个共享变量的原子操作，java提供<code>AtomicReference</code>类保证引用对象的原子性，这样我们可以把多个共享变量包装到一个对象中实现原子性操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AR</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">2</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line">        <span class="type">AtomicReference</span> <span class="variable">ar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicReference</span>(p1);</span><br><span class="line">        ar.compareAndSet(p1,p2);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> (Person) ar.get();</span><br><span class="line">        System.out.println(p3.id+<span class="string">&quot;,&quot;</span>+p3.name); <span class="comment">// 2,test2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CAS无法保证严格安全"><a href="#CAS无法保证严格安全" class="headerlink" title="CAS无法保证严格安全"></a>CAS无法保证严格安全</h5><p>假设现在两个线程t1和t2通过CAS操作修改变量x的值，比如都是+1，现在t1修改成功准备写回到内存，经过判断发现旧值没变还是x，恰好这个时候切换到线程t2，线程t2也发现值没变，将x+1进行赋值，然后回到线程t1，也写回，就丢失了一次+1的更新。</p>
<p><img src="/posts/4986/image-20230926151130058.png" alt="image-20230926151130058"></p>
<h3 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h3><p>无同步实际上并不是用来解决多线程并发问题的，因为根本不存在多线程竞争，多线程之间不存在竞争数据。</p>
<h4 id="私有本地栈"><a href="#私有本地栈" class="headerlink" title="私有本地栈"></a>私有本地栈</h4><p>非静态方法的局部变量之间不会干扰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoSync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            a += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NoSync</span> <span class="variable">noSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoSync</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; noSync.test());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; noSync.test());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TL</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;Integer&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;睡眠1000ms后,thread2修改了变量值,但是不会影响thread1的变量:&quot;</span>+tl.get());</span><br><span class="line">            tl.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1将值修改为&quot;</span>+tl.get());</span><br><span class="line">            tl.remove(); <span class="comment">// 使用完记得remove</span></span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">      	<span class="comment">// thread1将值修改为2</span></span><br><span class="line">				<span class="comment">// 睡眠1000ms后,thread2修改了变量值,但是不会影响thread1的变量:1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><code>volatile</code>能够保证有序性和可见性，但是不能保证原子性，应该可以算无同步的一种</p>
<p><strong>源代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileExm1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// private volatile static boolean stop = false;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Thread-A</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread A&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop) &#123;&#125;</span><br><span class="line">System.out.println(Thread.currentThread() + <span class="string">&quot; 停止&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thread-main</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; 1s后将stop改为true了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main] 1s后将stop改为<span class="literal">true</span>了</span><br></pre></td></tr></table></figure>
<p><strong>源代码（volatile）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileExm1</span> &#123;</span><br><span class="line">    <span class="comment">// private static boolean stop = false;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Thread-A</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread A&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop) &#123;&#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; 停止&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Thread-main</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; 1s后将stop改为true了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[main,<span class="number">5</span>,main] 1s后将stop改为<span class="literal">true</span>了</span><br><span class="line">Thread[Thread A,<span class="number">5</span>,main] 停止</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建问题记录</title>
    <url>/posts/14401.html</url>
    <content><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><h4 id="npm镜像"><a href="#npm镜像" class="headerlink" title="npm镜像"></a>npm镜像</h4><p><strong>问题描述</strong></p>
<p>npm安装慢→出错</p>
<p><strong>解决方案</strong></p>
<p>npm设置国内镜像资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>查看当前镜像地址</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
<p>切换回原始镜像</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="hexo运行"><a href="#hexo运行" class="headerlink" title="hexo运行"></a>hexo运行</h4><p><strong>问题描述</strong></p>
<p>hexo : 无法加载文件 <code>C:\Users\xzp\AppData\Roaming\npm\hexo.ps1</code>，因为在此系统上禁止运行脚本。</p>
<p><strong>解决方案</strong></p>
<p>win10→设置（新版）→搜索powershell→勾选[允许本地powershell在不签名的情况下运行]→应用</p>
<p><img src="/posts/14401/image-20230825153555994.png" alt="image-20230825153555994"></p>
<h4 id="hexo环境"><a href="#hexo环境" class="headerlink" title="hexo环境"></a>hexo环境</h4><p><strong>问题描述</strong></p>
<p>运行时显示 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extends includes/layout.pug block content #recent-posts.recent-posts include includes/recent-posts.pug include includes/pagination.pug #aside_content.aside_content include includes/aside.pug</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong></p>
<p>没有pug 以及 stylus渲染器</p>
<p><strong>解决方案</strong></p>
<p>在hexo博客根目录运行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>问题描述</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;</span><br><span class="line">&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;</span><br><span class="line">&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong></p>
<p>缺少swig包</p>
<p><strong>解决方案</strong></p>
<p>在hexo博客根目录运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><h4 id="静态url生成有误"><a href="#静态url生成有误" class="headerlink" title="静态url生成有误"></a>静态url生成有误</h4><p><strong>问题描述</strong></p>
<p>点击 <code>Home</code> | 主页时报错 <code>Cannot GET /%20</code></p>
<p><strong>原因</strong></p>
<p>生成的静态html文件对应url多了一个空格[%20]</p>
<p><strong>解决方案</strong></p>
<p>找到主题<code>themes</code>的<code>_config.yml</code>文件中，找到<code>menu:</code>字段，删除后续内容里多余的空格</p>
<hr>
<p><strong>问题描述</strong></p>
<p>点击  日志 | posts 时 报错<code>Cannot GET /archives/%7C%7C%20archive</code></p>
<p><strong>原因</strong></p>
<p>生成的静态html文件对应url多了%7C%7C%20，根本原因在于<code>/themes/next/layout/_macro/sidebar.swig</code>文件中 || 正好对应了%7C%7C</p>
<p><strong>解决方案</strong></p>
<p>Next主题的问题，找到根目录 <code>/themes/next/layout/_macro/sidebar.swig</code>，进行如下修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">if</span> <span class="string">config.archive_dir</span> <span class="type">!=</span> <span class="string">&#x27;/&#x27;</span> <span class="string">and</span> <span class="string">site.posts.length</span> <span class="string">&gt;</span> <span class="number">0</span> <span class="string">%</span>&#125;</span><br><span class="line">      <span class="string">&lt;div</span> <span class="string">class=&quot;site-state-item</span> <span class="string">site-state-posts&quot;&gt;</span></span><br><span class="line">      &#123;<span class="string">%</span> <span class="string">if</span> <span class="string">theme.menu.archives</span> <span class="string">%</span>&#125;</span><br><span class="line">        <span class="string">&lt;a</span> <span class="string">href=&quot;&#123;&#123;</span> <span class="string">url_for(theme.menu.archives).split(&#x27;||&#x27;)[0]</span> <span class="string">|</span> <span class="string">trim</span> <span class="string">&#125;&#125;&quot;&gt;</span></span><br><span class="line">      &#123;<span class="string">%</span> <span class="string">else</span> <span class="string">%</span>&#125;</span><br><span class="line">        <span class="string">&lt;a</span> <span class="string">href=&quot;&#123;&#123;</span> <span class="string">url_for(config.archive_dir)</span> <span class="string">&#125;&#125;&quot;&gt;</span></span><br><span class="line">      &#123;<span class="string">%</span> <span class="string">endif</span> <span class="string">%</span>&#125;</span><br><span class="line">          <span class="string">&lt;span</span> <span class="string">class=&quot;site-state-item-count&quot;&gt;&#123;&#123;</span> <span class="string">site.posts.length</span> <span class="string">&#125;&#125;&lt;/span&gt;</span></span><br><span class="line">          <span class="string">&lt;span</span> <span class="string">class=&quot;site-state-item-name&quot;&gt;&#123;&#123;</span> <span class="string">__(&#x27;state.posts&#x27;)</span> <span class="string">&#125;&#125;&lt;/span&gt;</span></span><br><span class="line">        <span class="string">&lt;/a&gt;</span></span><br><span class="line">      <span class="string">&lt;/div&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">endif</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">if</span> <span class="string">config.archive_dir</span> <span class="type">!=</span> <span class="string">&#x27;/&#x27;</span> <span class="string">and</span> <span class="string">site.posts.length</span> <span class="string">&gt;</span> <span class="number">0</span> <span class="string">%</span>&#125;</span><br><span class="line">      <span class="string">&lt;div</span> <span class="string">class=&quot;site-state-item</span> <span class="string">site-state-posts&quot;&gt;</span></span><br><span class="line">        <span class="string">&lt;a</span> <span class="string">href=&quot;&#123;&#123;</span> <span class="string">url_for(config.archive_dir)</span> <span class="string">&#125;&#125;&quot;&gt;</span></span><br><span class="line">          <span class="string">&lt;span</span> <span class="string">class=&quot;site-state-item-count&quot;&gt;&#123;&#123;</span> <span class="string">site.posts.length</span> <span class="string">&#125;&#125;&lt;/span&gt;</span></span><br><span class="line">          <span class="string">&lt;span</span> <span class="string">class=&quot;site-state-item-name&quot;&gt;&#123;&#123;</span> <span class="string">__(&#x27;state.posts&#x27;)</span> <span class="string">&#125;&#125;&lt;/span&gt;</span></span><br><span class="line">        <span class="string">&lt;/a&gt;</span></span><br><span class="line">      <span class="string">&lt;/div&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">endif</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="翻页按钮显示"><a href="#翻页按钮显示" class="headerlink" title="翻页按钮显示"></a>翻页按钮显示</h4><p><strong>问题描述</strong></p>
<p>Next主题的翻页按钮 | 箭头显示异常</p>
<p><img src="/posts/14401/image-20230825161811326.png" alt="image-20230825161811326"></p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>在<code>themes\hexo-theme-next\layout_partials</code>下找到next的翻页组件——<code>pagination.swig</code></p>
</li>
<li><p>修改如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;<span class="operator">%</span> <span class="keyword">if</span> page.prev or page.next <span class="operator">%</span>&#125;</span><br><span class="line">  <span class="operator">&lt;</span>nav <span class="keyword">class</span>=&quot;<span class="title class_">pagination</span>&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#x27;<span class="operator">&lt;</span>i <span class="keyword">class</span><span class="operator">=</span><span class="string">&quot;fa fa-angle-left&quot;</span><span class="operator">&gt;&lt;/</span>i<span class="operator">&gt;</span>&#x27;,</span><br><span class="line">        next_text: &#x27;<span class="operator">&lt;</span>i <span class="keyword">class</span><span class="operator">=</span><span class="string">&quot;fa fa-angle-right&quot;</span><span class="operator">&gt;&lt;/</span>i<span class="operator">&gt;</span>&#x27;,</span><br><span class="line">        mid_size: <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="operator">&lt;/</span>nav<span class="operator">&gt;</span></span><br><span class="line">&#123;<span class="operator">%</span> endif <span class="operator">%</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;<span class="operator">%</span> <span class="keyword">if</span> page.prev or page.next <span class="operator">%</span>&#125;</span><br><span class="line">  <span class="operator">&lt;</span>nav <span class="keyword">class</span>=&quot;<span class="title class_">pagination</span>&quot;&gt;</span><br><span class="line">    &#123;&#123;</span><br><span class="line">      paginator(&#123;</span><br><span class="line">        prev_text: &#x27;<span class="operator">&lt;</span>&#x27;,</span><br><span class="line">        next_text: &#x27;<span class="operator">&gt;</span>&#x27;,</span><br><span class="line">        mid_size: <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="operator">&lt;/</span>nav<span class="operator">&gt;</span></span><br><span class="line">&#123;<span class="operator">%</span> endif <span class="operator">%</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="中文目录跳转"><a href="#中文目录跳转" class="headerlink" title="中文目录跳转"></a>中文目录跳转</h4><p><strong>问题描述</strong></p>
<p>Next主题，侧边栏目录中中文标题的目录锚点，点击无法正常跳转</p>
<p><strong>原因</strong></p>
<ol>
<li>F12，发现报错<code>Cannot read properties of &#39;top&#39; of undefined --- post-detail.js</code></li>
<li>定位问题位置 <code>post-detail.js</code></li>
<li>发现是解析utf-8编码出错</li>
</ol>
<p><strong>解决办法</strong></p>
<p><code>.\themes\next\source\js\src</code>打开<code>post-detail.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> targetSelector = <span class="title class_">NexT</span>.<span class="property">utils</span>.escapeSelector(<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">&lt;!-- 添加下面这行代码, 重新解析 <span class="variable constant_">URL</span> -&gt;</span><br><span class="line">&lt;!-- targetSelector = <span class="built_in">decodeURI</span>(<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>)) -&gt;</span><br><span class="line">targetSelector = <span class="built_in">decodeURI</span>(<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line"><span class="keyword">var</span> offset = $(targetSelector).<span class="title function_">offset</span>().<span class="property">top</span>;</span><br></pre></td></tr></table></figure>
<h4 id="插入表格异常"><a href="#插入表格异常" class="headerlink" title="插入表格异常"></a>插入表格异常</h4><p><strong>问题描述</strong></p>
<p>表格如果位于列表中则显示异常，不渲染</p>
<p><strong>解决方案</strong></p>
<p>表格单独布置</p>
<h4 id="Java分类404"><a href="#Java分类404" class="headerlink" title="Java分类404"></a>Java分类404</h4><p><strong>问题描述</strong></p>
<p>点击分类里的java，出现404</p>
<p><strong>解决方案</strong></p>
<p>之前java应该是Java，类型中修改为java，同时需要将分类文件夹的名字也改为java</p>
<p><img src="/posts/14401/image-20230915203553839.png" alt="image-20230915203553839"></p>
<h4 id="目录显示问题"><a href="#目录显示问题" class="headerlink" title="目录显示问题"></a>目录显示问题</h4><p><strong>问题描述</strong></p>
<p><img src="/posts/14401/image-20230916164110783.png" alt="image-20230916164110783"></p>
<p><strong>解决方案</strong></p>
<p>第2部分的目录标题等级排布有误，修改就好了</p>
<h4 id="generate编译问题"><a href="#generate编译问题" class="headerlink" title="generate编译问题"></a>generate编译问题</h4><p><strong>问题描述</strong></p>
<p>hexo YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key</p>
<p><strong>解决方案</strong></p>
<p>提示hexo的yml配置文件 冒号后面少了空格</p>
<p>到提示行将对应的空格补上即可</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><strong>问题描述</strong></p>
<h4 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h4><p><strong>解决方案</strong></p>
<ol>
<li><p>安装插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo<span class="literal">-asset-image</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改hexo根目录下<code>_config.yml</code>文件，将<code>post_asset_folder</code>的值置为<code>true</code></p>
</li>
<li><p>typora（或者其他md编写软件）将图片设置为优先使用相对位置，并且对图像做 复制到指定路径<code>./$&#123;filename&#125;/</code> 处理</p>
<p><img src="/posts/14401/image-20230825154720545.png" alt="image-20230825154720545"></p>
</li>
</ol>
<h4 id="多端同步"><a href="#多端同步" class="headerlink" title="多端同步"></a>多端同步</h4><p><strong>问题描述</strong></p>
<p>如何在多端上都能写博客并提交</p>
<p><strong>解决方案</strong></p>
<p>尝试使用坚果云直接同步hexo根目录，但是好像不能deploy，并且坚果云在同步时，deploy出现访问拒绝的错误</p>
<h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p><strong>问题描述</strong></p>
<p>行内公式<code>\$\$</code>不渲染 公式内有 `*` 不正常渲染</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>卸载原来的marked</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo<span class="literal">-renderer-marked</span> <span class="literal">--save</span></span><br><span class="line">npm install hexo<span class="literal">-renderer-kramed</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>博客开头开启数学公式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要用<code>*</code></p>
</li>
</ol>
<h4 id="图片去掉灰色边框"><a href="#图片去掉灰色边框" class="headerlink" title="图片去掉灰色边框"></a>图片去掉灰色边框</h4><p><strong>问题描述</strong></p>
<p>如何去掉图片默认的灰色边框</p>
<p><strong>解决方案</strong></p>
<p>找到<code>themes/next/source/css/_common/components/post/post-expand.styl</code>这个文件，做如下修改</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="教程主页"><a href="#教程主页" class="headerlink" title="教程主页"></a>教程主页</h3><p><a href="https://hexo.io/zh-cn/docs/">Hexo</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>问题处理</tag>
      </tags>
  </entry>
  <entry>
    <title>java-锁机制</title>
    <url>/posts/38827.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>多线程并发场景下，实现互斥同步的核心在于锁机制，java考虑性能、功能、应用需求，提供了各种各样的锁。</p>
<ol>
<li>是否强制锁住临界资源<ol>
<li>乐观锁</li>
<li>悲观锁</li>
</ol>
</li>
<li>获取不到锁时是否阻塞<ol>
<li>自旋锁 | 自适应自旋锁</li>
</ol>
</li>
<li>多线程竞争锁时是否允许插队<ol>
<li>公平锁</li>
<li>非公平锁</li>
</ol>
</li>
<li>一个线程能否多次获取同一把锁<ol>
<li>可重入锁</li>
<li>非可重入锁</li>
</ol>
</li>
<li>临界资源是否能够共享<ol>
<li>共享锁</li>
<li>独享锁</li>
</ol>
</li>
<li>锁升级机制涉及到的锁<ol>
<li>无锁</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ol>
</li>
</ol>
<h3 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs 悲观锁"></a>乐观锁 vs 悲观锁</h3><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，比如<code>synchronized | lock[ReentrantLock]</code>，适用于写操作比较多的场景，加锁能够保证写操作正确性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPublicResources</span><span class="params">()</span> &#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，最典型的就是CAS算法，比较内存中的值和旧值是否相等，相等则用新值更新，否则不断重新尝试，适用于读操作比较多的场景，不加锁能够显著提高读操作的性能，比如java中的<code>AtomicInteger</code>类就是基于CAS实现的原子性递增操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure>
<h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><p>一般来说，线程在尝试获取悲观锁时，如果发现获取不到就会阻塞，阻塞其实就是放弃CPU的使用权，将自己挂起直到别的线程释放锁进行唤醒。阻塞和唤醒一个线程需要操作系统进行CPU状态的切换，本身就比较耗费性能，而如果同步代码块的执行时间很短，很快就能获取到锁，那么就没必要阻塞等待唤醒了，当然这需要多核CPU的支持，这样线程1持有锁正在执行，线程2尝试获取锁失败也不需要放弃CPU使用权，等待一下就可以。因此，就引入了自旋锁，自旋实际上就是空转、循环的意思，如果自旋结束前，锁被释放了，那么就不必阻塞而直接获取同步资源了。</p>
<p><img src="/posts/38827/image-20230920154240733.png" alt="image-20230920154240733"></p>
<p>为什么引入自适应自旋锁呢？</p>
<p>其实根据自旋的定义会发现，自旋的时间实际上是被浪费的CPU时间，如果自旋时间过长，也会导致性能受到影响，所以一般会设置一定的自旋次数上限（默认10次），如果达到该上限，那么就会阻塞。而自适应自旋锁呢其实就是动态修改自旋次数上限，比如自旋等待刚刚成功获取到了锁，那么JVM会认为自旋等待获取到锁的概率比较大，就会增加次数上限；否则，JVM可能会忽略自旋锁阶段，直接进入线程阻塞，也就是重量级锁。</p>
<h3 id="公平锁-vs-非公平锁"><a href="#公平锁-vs-非公平锁" class="headerlink" title="公平锁 vs 非公平锁"></a>公平锁 vs 非公平锁</h3><p>公平锁就是申请锁的线程默认封装到先进先出队列中，锁释放后，先申请的线程先获取锁，能够确保线程不会饥饿，但是等待队列中的线程除了第一个线程，也就是获取到锁正在执行的线程，其余线程都需要阻塞，CPU唤醒线程的次数多，开销更大</p>
<p>非公平锁就是允许新来的线程在锁刚刚释放，没有安排给别的线程时插队，插队成功获取到锁，失败再去队列中等待，当然如果进入到队列了，那么其实也是公平锁。非公平锁意味着锁不是按照先来后到分配的，这就有可能导致等待队列中的线程饥饿，但是CPU要唤醒的线程数变少。</p>
<p><img src="/posts/38827/image-20230920161811828.png" alt="image-20230920161811828"></p>
<p>公平锁的实现就是加了一个<code>!hasQueuedPredecessors()</code>   的判断，这个判断的目的在于看当前线程是不是队列的首位，如果没有这个判断，那么就是新申请的线程也可以抢到锁，即不公平，而如果有这个判断，就限制必须是队列首位的线程才能获取锁，即公平锁</p>
<h3 id="可重入锁-vs-非可重入锁"><a href="#可重入锁-vs-非可重入锁" class="headerlink" title="可重入锁 vs 非可重入锁"></a>可重入锁 vs 非可重入锁</h3><p>可重入锁，又名递归锁，<code>synchronized</code>和<code>ReentrantLock</code>都是这种锁（<code>Reentrant</code>的意思就是可重入），其实就是，同一个线程在外层同步方法获取到锁时，调用到内层同步方法，如果锁对象是一样的，那么就可以自动获取内层的锁，不会因为之前获取锁导致计数器变为1而无法获取，避免出现死锁的问题</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">     doOthers();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例同步方法A调用实例同步方法B，如果是非可重入锁，就会死锁</p>
<p>因为对实例的锁已经被获取了，无法执行B，A等待B执行完毕才会释放锁，B又等待A释放锁才能执行，就死锁了</p>
</blockquote>
<p>其实源码简单来说就是</p>
<ol>
<li>计数器如果是0，说明没有线程获得锁，直接获取锁</li>
<li>如果是1，检测是不是申请锁的线程和持有锁的线程是不是一样，一样就再次获取锁，计数器+1；不一样就阻塞</li>
<li>释放锁也得依次-1，直到为0，完成所有锁的释放</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">  	<span class="comment">// 当前线程是不是持有锁的线程</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires; <span class="comment">// 如果是就可以继续+1</span></span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 获取锁成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(); <span class="comment">// 当前线程是不是持有锁的线程 不是就报错</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果c为0了 说明所有锁释放完毕 才是真正地释放锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不可重入锁是如果不是0就阻塞，释放锁则是判断如果是当前线程持有锁就直接置为0即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.compareAndSetState(<span class="number">0</span>,<span class="number">1</span>)) &#123; <span class="comment">// 直接尝试获取锁 原本必须是0 然后才能改成1</span></span><br><span class="line">        <span class="built_in">this</span>.owner = Thread.currentThread;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread() != <span class="built_in">this</span>.owner) &#123;</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="built_in">this</span>.owner = <span class="literal">null</span>;</span><br><span class="line">      	<span class="built_in">this</span>.setState(<span class="number">0</span>); <span class="comment">// 释放锁时直接置为0</span></span><br><span class="line">      	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独享锁-vs-排它锁"><a href="#独享锁-vs-排它锁" class="headerlink" title="独享锁 vs 排它锁"></a>独享锁 vs 排它锁</h3><p>独享锁也叫排它锁，锁一次只能被一个线程获取，比如<code>synchronized</code> 和 <code>ReentrantLock</code></p>
<p>共享锁就是说锁能够共享，获得共享锁的线程只能读，不能写，比如<code>ReentrantReadWriteLock</code></p>
<p>其实类似数据库中的S锁和X锁，读读不互斥，读写和写写还是互斥的</p>
<p><code>ReentrantReadWriteLock</code>设计了两种锁，<code>ReadLock</code>和<code>WriteLock</code>，也就是读锁和写锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;sync.acquireShared(<span class="number">1</span>);&#125; <span class="comment">// 读锁的获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;sync.acquire(<span class="number">1</span>);&#125; <span class="comment">// 写锁的获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细源码分析见<a href>ReentrantReadWriteLock详解</a></p>
<h3 id="无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁"><a href="#无锁-vs-偏向锁-vs-轻量级锁-vs-重量级锁" class="headerlink" title="无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁"></a>无锁 vs 偏向锁 vs 轻量级锁 vs 重量级锁</h3><p>见<a href>synchronized详解</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库重点知识解析-MySQL日志</title>
    <url>/posts/64597.html</url>
    <content><![CDATA[<h3 id="MySQL日志概述"><a href="#MySQL日志概述" class="headerlink" title="MySQL日志概述"></a>MySQL日志概述</h3><h4 id="何时记录日志"><a href="#何时记录日志" class="headerlink" title="何时记录日志"></a>何时记录日志</h4><p>MySQL执行更新语句时，包括增、删、改，会涉及到undo log（回滚日志）、redo log（重做日志）以及binlog（归档日志）</p>
<h4 id="有啥用"><a href="#有啥用" class="headerlink" title="有啥用"></a>有啥用</h4><ul>
<li>undo log：回滚日志，<strong>MySQL的Innodb存储引擎层</strong>生成的日志，用于实现<strong>事务原子性</strong>，主要用于<strong>事务回滚</strong>和<strong>MVCC</strong></li>
<li>redo log：重做日志，<strong>MySQL的Innodb存储引擎层</strong>生成的日志，用于实现<strong>事务持久性</strong>，主要用于<strong>突发性故障恢复</strong></li>
<li>binlog：归档日志，MySQL的Server层生成的日志，主要用于<strong>数据备份</strong>和<strong>主从复制</strong></li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h5><p>一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？——undo log</p>
<p>在事务提交前，就会先记录更新前的数据到undo log中，事务回滚或者提交前发生崩溃，就可以利用undo log来进行回滚</p>
<p><img src="/posts/64597/image-20230830124154016.png" alt="image-20230830124154016"></p>
<h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><p>每次update操作所产生的undo log，都会在涉及到的记录的隐藏列中undo log指针和事务ID的更新</p>
<ul>
<li><p>undo log指针：指向最近的undo log，其实就是旧值</p>
</li>
<li><p>事务ID：谁最后修改了这条记录</p>
</li>
</ul>
<p><img src="/posts/64597/image-20230830125236146.png" alt="image-20230830125236146"></p>
<p>通过事务id和指针，配合read view就可以实现读提交和可重复读的事务隔离级别，主要就是通过记录的事务id和read view中记录的事务id信息进行比对，检验<strong>可见性</strong>，<strong>不可见</strong>则通过指针去回溯版本链找到<strong>可见</strong>的记录</p>
<p>read view：事务创建的read view，包括创建者事务id，事务列表[存储当前事务创建时，有哪些事务处于活跃状态]，最小事务id[min(事务列表)]，最大事务id[max(事务列表)+1]</p>
<ul>
<li><strong>读提交</strong>：事务中的每次select操作，都会重新创建一次read view，这样，事务列表中的事务如果没有提交，则不可见，如果提交了，就会从事务列表中移除，就可见。</li>
<li><strong>可重复读</strong>：只在事务开始时创建read view，这样，不管事务列表中的事务有没有提交，都是不可见的</li>
</ul>
<h4 id="记录内容"><a href="#记录内容" class="headerlink" title="记录内容"></a>记录内容</h4><p>undo log主要针对事务的update操作，包括增、删、改</p>
<ul>
<li>增：记录<strong>主键ID</strong>，这样回滚的时候直接delete掉这个主键对应的记录</li>
<li>删：记录<strong>数据的全部内容</strong>，这样回滚的时候直接insert这条记录</li>
<li>改：记录<strong>更新字段的旧值</strong>，这样回滚的时候把对应字段update成旧值</li>
</ul>
<h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Buffer Pool其实就是数据库的缓存池，如果没有缓冲池，那么数据库的每次读写操作提交后都得把数据直接写回到磁盘，并且undo log也需要直接写回磁盘，但是这种方式显然是不可靠的：</p>
<p>以 <strong>数据库读写的最小单位是数据页</strong> 为前提[<strong>预读机制，基于局部访问性原理提高缓存命中率</strong>]，假设我们只是修改了数据页中某一条记录的某一个字段</p>
<ul>
<li>如果想要持久化，就得马上把整个数据页写回到磁盘，太浪费了</li>
<li>一个事务可能会涉及到在磁盘中非连续分布的多个页面，把这些页面都写回去，需要多次磁盘的随机I/O，而随机I/O是非常耗时的，写回的这个时间也是危险期，一旦发生故障，就会出现事务执行的中间状态</li>
</ul>
<p>所以就引入了Buffer Pool，数据库读写时一般需要先将数据从磁盘中读取到Buffer Pool，然后修改并缓存起来，等到时机合适再写回到磁盘。</p>
<h4 id="读写策略"><a href="#读写策略" class="headerlink" title="读写策略"></a>读写策略</h4><ol>
<li>读操作，没命中，直接读取Buffer Pool的数据，未命中，则去读取磁盘数据再存到Buffer Pool中</li>
<li>写操作，命中，直接修改Buffer Pool数据所在的页的内容，再将其设置为脏页[内存和磁盘数据不一致的页]，但是不会马上写回，而是由后台线程选择合适的时机写回；没命中，也是先去磁盘中取</li>
</ol>
<h4 id="缓存内容"><a href="#缓存内容" class="headerlink" title="缓存内容"></a>缓存内容</h4><p>因为以数据页为最小读写单元，所以数据库会申请一片连续的内存空间，并按照数据页的大小划分出若干页，就叫缓存页</p>
<ul>
<li>空闲页——Free链表</li>
<li>脏页——Flush链表</li>
<li>干净页——LRU链表，分为young区域和old区域，避免预读失效和缓存污染问题</li>
</ul>
<p>缓存的内容主要包括数据页、索引页和undo页，数据、索引需要持久化，但是undo页是干啥的呢？</p>
<p>undo页就是存储前面讲的undo log的</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>基于Buffer Pool，数据库读写效率有了显著提升，但是Buffer Pool毕竟还是存储在内存中的，而内存是非持久化的存储设备，一旦断电，那么还没写到磁盘的脏页的所有数据都会丢失。</p>
<p>那么如何保证事务的持久性呢？我们可以先思考为什么不能直接把Buffer Pool的脏数据在提交后就立马写回去[理由同上]，并且基于此可以如何优化呢</p>
<ol>
<li>既然整个数据页写回太浪费，那么就少写一点内容嘛，比如就写某某表空间某某数据页多少偏移量的字节发生了变化</li>
<li>既然数据页非连续存储，需要随机I/O，那就改为顺序I/O来写</li>
</ol>
<p>由此，就引入了redo log</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>redo log是物理日志，比如某表空间中某数据页多少偏移量的地方做了什么更新，逻辑上就体现为记录的新值，并且redo log是追加写的模式，对应磁盘的顺序I/O，写入速度较快。</p>
<p>有了redo log，事务提交时，只要先把redo log进行持久化，事务就算已经提交了，不需要等到对应脏数据也写到磁盘中，这就是WAL（Write Ahead Logging）技术，如果系统崩溃，那么MySQL也可以通过redo log的内容进行恢复。</p>
<h4 id="更新操作流程"><a href="#更新操作流程" class="headerlink" title="更新操作流程"></a>更新操作流程</h4><p><img src="/posts/64597/image-20230830133835288.png" alt="image-20230830133835288"></p>
<h4 id="事务执行流程"><a href="#事务执行流程" class="headerlink" title="事务执行流程"></a>事务执行流程</h4><p>结合redo log和undo log，数据库的更新事务执行流程如下</p>
<p><img src="/posts/64597/image-20230830134314807.png" alt="image-20230830134314807"></p>
<h4 id="额外拓展"><a href="#额外拓展" class="headerlink" title="额外拓展"></a>额外拓展</h4><ul>
<li><p>redo log都记录些啥</p>
<p>数据页新值、索引页新值、undo log的新值</p>
<p>数据页、索引页需要持久化[redo log或者原始文件]，undo log实际上也需要持久化</p>
<p>比如更新操作，那么需要记录旧值的undo log存储在Buffer Pool中的undo页面[后台线程选择合适时机写盘]，对这个undo页面的修改也需要用redo log进行记录</p>
</li>
<li><p>redo log什么时候写回磁盘</p>
<p>redo log不是直接写回磁盘的，而是先写到redo log buffer，然后后续在合适时机刷新到磁盘</p>
<ol>
<li><p>MySQL正常关闭</p>
</li>
<li><p>redo log buffer空间使用率超过50%</p>
</li>
<li><p><strong>后台线程每隔1s进行刷盘</strong></p>
</li>
<li><p>每次事务提交时根据策略决定是否要持久化</p>
<ol>
<li>参数为0：提交不会触发刷盘行为</li>
<li>参数为1：提交时直接刷盘</li>
<li>参数为2：提交时，写到内核缓冲区[Page Cache]，但是没有写入磁盘</li>
</ol>
<p>参数为0时，需要等待1、2、3触发才能刷盘，一般是后台线程每隔1s，调用write写到内核缓冲区，再调用fsync()写到磁盘，MySQL进程崩溃会导致1s内的事务数据丢失</p>
<p>参数为2时，也需要等待1、2、3触发才能刷盘，一般也是后台线程每隔1s，调用fsync()写到磁盘，MySQL进程崩溃不会丢失数据，但是操作系统崩溃会导致1s内的事务数据丢失</p>
<p>应用场景</p>
<p>安全性：1&gt;2&gt;0</p>
<p>性能：0&gt;2&gt;1</p>
</li>
</ol>
</li>
<li><p>redo log文件写满了怎么办</p>
<p>默认情况下，redo log的文件是由两个redo日志文件构成的，采用循环写的策略，一个写满了，切换到另外一个继续写，并且redo log对应的脏数据如果已经持久化了，就可以把redo log对应的记录删掉了[补图]</p>
<p>如果写的速度超过了脏数据持久化的速度，导致两个文件都没有空闲位置写，整个MySQL系统就会阻塞，不能指向新的更新操作，而是停下来把脏页刷新到磁盘上，再把redo log进行擦除，擦除完了再恢复</p>
</li>
</ul>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog比较特殊，前面的undo log和redo log都是存储引擎的日志，而binlog则是server层的log</p>
<p>binlog也是为更新操作服务的，但是binlog不仅仅记录数据更新，还会记录表结构的变化</p>
<h4 id="binlog-vs-redo-log"><a href="#binlog-vs-redo-log" class="headerlink" title="binlog vs redo log"></a>binlog vs redo log</h4><ol>
<li><p>适用对象不同</p>
<p>binlog是server层实现的，所有存储引擎都能用</p>
<p>redo log只能Innodb存储引擎</p>
</li>
<li><p>记录内容不同</p>
<p>binlog记录的是逻辑操作，默认格式记录的就是SQL语句</p>
<p>redo log则记录的是物理日志，某个数据页的变动</p>
</li>
<li><p>写入方式不同</p>
<p>bin log写满一个文件就创建新文件继续写，不会覆盖之前的文件</p>
<p>redo log是循环写，两个日志文件循环写，并且无效的redo log会被覆盖掉</p>
</li>
<li><p>用途不同</p>
<p>正是因为bin log不会覆盖，所以一般用于备份恢复和主从复制</p>
<p>redo log则用于故障恢复</p>
</li>
</ol>
<h4 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h4><p>如果整个数据库的磁盘文件丢失了，用redo log是恢复不了的，因为redo log会把已经持久化的对应记录给擦除，而数据库磁盘被删除需要的就是这些数据，用bin log就可以恢复，因为bin log不会覆盖，记录了数据库所有数据变更的情况。</p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>复制的过程就是把binlog从主库移动到从库中，从库依据binlog的内容进行回放</p>
<p>这样，更新时只需要更新主数据库了</p>
<h4 id="何时刷盘"><a href="#何时刷盘" class="headerlink" title="何时刷盘"></a>何时刷盘</h4><p>事务执行过程中，binlog也是先写到bin cache中，事务提交的时候，再把binlog cache写到binlog文件中，并且一个事务的binlog，为了保证事务原子性，是不能分开的，否则回放时就可能导致一个事务被拆分成多个</p>
<p>binlog是存放在内核缓冲区的，类似redo log，所以也是依据参数决定什么时候真正刷盘</p>
<ul>
<li>参数为0，提交时只写到内核缓冲区，由操作系统决定何时写到磁盘</li>
<li>参数为1，提交时马上写到内核缓冲区，然后写到磁盘</li>
<li>参数为N，提交时写到内核缓冲区，积累到N个事务的binlog后再写到磁盘</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>事务提交后，redo log和binlog都需要持久化到磁盘[undo log、数据页和索引页后台线程自己决定什么时候刷盘]，但是redo log和binlog又是两条独立的执行流程，就有可能导致不一致的情况</p>
<p>比如，修改某条记录的name从x变为y，持久化redo log和binlog时MySQL宕机，出现了不一致的情况</p>
<ol>
<li><p>redo log持久化了，MySQL宕机，binlog没来得及</p>
<p>重启后，根据redo log，主库的name是y，但是从库根据binlog，发现name应该是x</p>
</li>
<li><p>bin log持久化了，MySQL宕机，redo log没来得及</p>
<p>主库是x，从库是y</p>
</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>因此，就引入了两阶段提交协议，本身是分布式事务一致性的一个协议，能够保证多个逻辑操作要么都成功，要么都不成功，不会出现中间状态</p>
<p>单事务提交通过内部事务保证原子性，分为Prepare和Commit两阶段，其实就是把事务提交时的redo log写回和binlog写回视作一个事务来处理，并且以binlog的写回成功标识事务的成功，这样就能保证两个操作的原子性，具体来讲</p>
<ol>
<li>Prepare阶段，将内部事务ID写入redo log，并标记为prepare，然后把redo log进行持久化</li>
<li>Commit阶段，将内部事务ID写入binlog，然后把binlog进行持久化，接着把redo log的状态置为commit</li>
</ol>
<p>MySQL重启后，会扫描redo log，碰到处于prepare状态的redo log，就拿着内部事务ID去查binlog</p>
<ol>
<li>binlog里面没有这个事务id，说明是Commit阶段前数据库崩了，回滚即可</li>
<li>binlog里面有这个事务id，说明binlog也完成写回了，只是没来得及修改状态，提交事务就行了</li>
</ol>
]]></content>
      <categories>
        <category>扩展学习</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>学科扩展知识</tag>
        <tag>待补充图片</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层</title>
    <url>/posts/37553.html</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/posts/37553/9fe85e137e7f4f03a580512200a59609tplv-k3u1fbpfcp-zoom-1.png" alt="传输层"></p>
<p>为运行在不同主机上的应用程序（进程）提供逻辑通信，屏蔽下层网络核心的细节，例如网络拓扑、所采用的路由选择协议等，在这一层的数据单元叫报文段（segment），包括TCP报文段和UDP用户数据报</p>
<p><strong>进程（process）</strong>：指计算机中正在运行的程序实体。</p>
<p><strong>发送方</strong>：将应用层的报文分成报文段，然后传递给网络层</p>
<p><strong>接收方</strong>：将报文段进行重组，然后传递给应用层</p>
<p><strong>进程间通信</strong>：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</p>
<h3 id="传输层-VS-网络层"><a href="#传输层-VS-网络层" class="headerlink" title="传输层  VS 网络层"></a>传输层  VS 网络层</h3><p>网络层：主机之间的逻辑通信</p>
<p>传输层：主机上进程之间的逻辑通信</p>
<ul>
<li>依赖于网络层提供的服务（延时、带宽）</li>
<li>对网络层的服务进行增强（不可靠变成可靠，不安全变成安全，但是带宽、延时这种物理特征不好优化）</li>
</ul>
<blockquote>
<p>两个家庭的小孩子互相写信：网络层相当于两个家庭之间的通信，传输层则相当于家庭内部成员的通信，传输层的作用是为两个小孩之间的写信提供复用解复用服务，网络层则相当于是家庭之间的邮政服务</p>
</blockquote>
<p>传输层提供应用进程之间的逻辑通信，也就是说，传输层之间的通信并不是真正在两个传输层之间直接传输数据。传输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<h3 id="传输层的协议"><a href="#传输层的协议" class="headerlink" title="传输层的协议"></a>传输层的协议</h3><ol>
<li>可靠的、保序的传输服务：<strong>传输控制协议（Transmission Control Protocol，TCP</strong>）<ul>
<li>面向连接</li>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>不提供广播、多播服务</li>
<li>面向字节流</li>
<li>提供全双工通信</li>
</ul>
</li>
<li>不可靠、不保序的传输服务：<strong>用户数据报协议（User Datagram Protocol，UDP）</strong><ol>
<li>多路复用、解复用</li>
<li>无连接</li>
<li>尽力而为</li>
<li>首部开销小</li>
<li>支持一对一、一对多、多对多通信</li>
<li>没有为尽力而为的IP服务添加更多的额外增强</li>
<li><strong>相当于只是将服务粒度细化为进程到进程</strong></li>
</ol>
</li>
</ol>
<p>二者都无法提供 **延时保证和带宽保证</p>
<p>TCP将应用进程下达的字节流进行编号存储在发送缓冲区，然后取出一部分字节添加TCP首部进行发送，接收方将TCP首部去掉，取出数据载荷部分存储在接收缓冲区中，并且将缓冲区中的字节交付给应用进程</p>
<p>TCP发送和接收的数据块的大小不一定相等，比如发送方需要10个数据块才能发送，但是接收方可能只需要4个数据块就能存储所有数据，但是字节流需要保持一致</p>
<h3 id="端口和套接字"><a href="#端口和套接字" class="headerlink" title="端口和套接字"></a>端口和套接字</h3><p>仅仅用IP地址不能唯一标识一个应用进程，如何进行应用进程之间的通信呢？</p>
<ol>
<li>如何让发送方的下层实体知道这一段数据应该发给哪个主机的哪个进程？</li>
<li>如何让接收方的下层实体知道这一段数据应该发给主机里的哪个进程？</li>
</ol>
<p>IP地址能够区分主机，还需要用端口号来区分不同进程</p>
<p><strong>端口（port）</strong>：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与传输实体进行层间交互的一种地址。</p>
<p><strong>层间接口必须要携带的信息（应用层给传输层的数据）</strong></p>
<ul>
<li>要传输的报文（对于本层来说：SDU），就是货物</li>
<li>谁传的：发送方的应用进程的标示：IP+TCP(UDP)端口</li>
<li>传给谁：接收方的应用进程的标示：对方的IP+TCP(UDP)端口号</li>
</ul>
<p>传输层实体（tcp 或者 udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装</p>
<ul>
<li>源端口号，目标端口号，数据等</li>
<li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li>
</ul>
<p>如果Socket API每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理=&gt;用一个代号标示通信的双方或者单方：socket（就像OS打开文件返回的句柄一样，对句柄的操作，就是对文件的操作）</p>
<ul>
<li><p>TCP服务，两个进程之间的通信需要之前要建立连接</p>
<p>两个进程通信会持续一段时间，通信关系稳定  </p>
</li>
<li><p>可以用一个整数表示两个应用实体之间的通信关系，本地标识</p>
</li>
<li><p>穿过层间接口的信息量变小</p>
</li>
</ul>
<p>标识具有本地标识意义的元组（源IP 源端口 目标IP 目标端口）的一个整数，唯一指定了一个会话，不需要每次都要用这个元组，直接用套接字进行查表就知道给谁了</p>
<p>有点像操作系统的句柄，有了句柄就不需要每次都查文件的目录、文件名称、怎么打开了</p>
<h3 id="多路复用解复用"><a href="#多路复用解复用" class="headerlink" title="多路复用解复用"></a>多路复用解复用</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>传输层的复用与解复用</strong>：复用指发送方不同的进程都可以通过同一个传输层协议传送数据。解复用指接收方的传输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</p>
<p><strong>多路复用</strong>：<strong>发送方</strong>的多路复用，从多个套接字（应用进程）接收来自多个本地进程的报文，根据套接字对应的IP地址和端口号等信息对报文段用头部加以封装 (该头部信息用于以后的解复用)，决定发往哪里</p>
<p><strong>解复用</strong>：<strong>接收方</strong>的解复用，根据报文段的头部信息中的IP地址和端口号将接收到的报文段发给<strong>正确的套接字和对应的应用进程</strong></p>
<h4 id="TCP多路复用-解复用"><a href="#TCP多路复用-解复用" class="headerlink" title="TCP多路复用/解复用"></a>TCP多路复用/解复用</h4><p>发送方根据socket，查表可以得到目标IP和目标端口，<strong>知道应该发给谁</strong></p>
<p>接收方收到了数据包</p>
<ol>
<li>每个数据报有源IP地址和目标IP地址（网络层的包）</li>
<li>每个数据报包含一个传输层的报文段</li>
<li>每个报文段里面又有源端口和目标端口</li>
</ol>
<p>主机联合使用<strong>源IP地址</strong>和<strong>源端口号和目标端口</strong>将报文段发送给正确的套接字，再递交给正确的应用进程</p>
<p><img src="/posts/37553/image-20230526144922523.png" alt="image-20230526144922523"></p>
<h4 id="UDP多路复用"><a href="#UDP多路复用" class="headerlink" title="UDP多路复用"></a>UDP多路复用</h4><p>客户端使用什么端口号不重要，客户端主动找服务器，所以在UDP中，socket只需要目标IP和目标端口</p>
<p>客户端的下层实体（网络层）根据socket，查表可以得到目标IP和目标端口，<strong>知道应该发给谁</strong></p>
<p>主机收到了数据包</p>
<ol>
<li>检查报文段的目标端口号（IP不重要，都发到这个主机了，IP肯定已经确定了）</li>
</ol>
<p>用该端口号将报文段定位给套接字，进而交给正确的应用进程，<strong>知道应该递交给哪个应用进程</strong></p>
<p>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</p>
<p><img src="/posts/37553/image-20230526143452934.png" alt="image-20230526143452934"></p>
<h3 id="用户数据报协议"><a href="#用户数据报协议" class="headerlink" title="用户数据报协议"></a>用户数据报协议</h3><p>User Datagram Protocol，UDP</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>“尽力而为”的服务：</strong>报文可能丢失、乱序</p>
<p><strong>无连接服务：</strong>UDP发送端和接收端无需建立连接，每个UDP报文段独立处理</p>
<p><strong>适用于：</strong>流媒体、DNS、SNMP</p>
<p><strong>基于UDP实现可靠传输：</strong>在应用层增加可靠性，应用设置特定的差错恢复机制</p>
<p>UDP优势：</p>
<ol>
<li>无需建立连接，建立连接需要耗时</li>
<li>实现简单，资源消耗少，在发送端和接收端无需维护连接状态</li>
<li>报文段的头部小</li>
<li>无拥塞控制和流量控制：UDP能够以尽可能快的速率发送数据报，应用传输的速率就是主机发送数据报到网络的速率</li>
</ol>
<h4 id="检错和"><a href="#检错和" class="headerlink" title="检错和"></a>检错和</h4><p>检测在被传输报文段中的差错，比如比特反转</p>
<p>发送方：计算报文段的检验和，放在UDP的检验和字段</p>
<p>接收方：计算接收到的报文段的检验和，比较是否相等</p>
<ol>
<li><p>相等，只能说没有检测到差错，但是不保证没有差错</p>
<p>无法保证完整性和靠靠性</p>
<p>比如丢包，无从计算何谈检测？</p>
<p>比如虽然发生错误，但是检验和计算结果还是一致（恰好两个bit反转）</p>
</li>
<li><p>不相等，一定有差错</p>
</li>
</ol>
<h3 id="传输控制协议"><a href="#传输控制协议" class="headerlink" title="传输控制协议"></a>传输控制协议</h3><p>Transmission Control Protocol，TCP</p>
<p>最大传输单元（Maximum Transmission Unit，MTU）：网络上的某个链路允许的最大数据包大小，</p>
<p>最大报文段大小（Maximum Segment Size，MSS）：TCP报文段可以有的最大长度</p>
<h4 id="首部结构"><a href="#首部结构" class="headerlink" title="首部结构"></a>首部结构</h4><p><img src="/posts/37553/image-20230603133559608.png" alt="image-20230603133559608"></p>
<p><strong>数据偏移</strong></p>
<p>x字序号：当前段在整个字节流的偏移量</p>
<p>x，x+MSS，x+2MSS，…，x+n*MSS</p>
<p>x不从0、1开始，随机生成：因为老的连接的分组滞留在网络中，对新的连接造成影响</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>点对点，一对一，一个发送方和一个接收方</li>
<li>可靠的、保序的字节流服务，不提供报文边界服务</li>
<li>流水线：通过拥塞控制和流量控制来限制发送缓冲区的大小</li>
<li>发送和接收都有缓存</li>
<li>支持全双工通信（同一连接的数据是双向流动的）</li>
<li>面向连接的：数据交换前需要先建立连接，初始化发送方和接收方的状态变量，比如初始分组的序号</li>
<li>有流量控制</li>
</ol>
<h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><p>$SampleRTT$：测量从报文段发出到收到确认的时间（发生重传不算），需要对最近的几次测量做平均</p>
<p>EstimatedRTT=(1-α)EstimatedRTT+αSampleRTT</p>
<ol>
<li><p>用之前的预估值和当前的测量值进行加权求和</p>
</li>
<li><p>过去样本的影响呈指数衰减趋势$(1-α)^n$</p>
<script type="math/tex; mode=display">
EstimatedRTT_2=(1-α)EstimatedRTT_1+αSampleRTT_2\\
=(1-α)[(1-α)EstimatedRTT_0+αSampleRTT_1]+αSampleRTT_2</script></li>
</ol>
<p>安全边界时间：$SampleRTT$会偏离$EstimatedRTT$多远</p>
<script type="math/tex; mode=display">
DevRTT=(1-β)DevRTT+β|SampleRTT-EstimatedRTT|</script><p>超时：EstimatedRTT+4*DevRTT</p>
<p>超时设置简单来说，预估往返时间+安全区间</p>
<ol>
<li><strong>预估往返时间</strong>由<strong>之前预估的往返时间</strong>和<strong>当前测量往返时间</strong>加权而成</li>
<li><strong>当前测量往返时间</strong>需要对最近几次测量取平均</li>
<li><strong>安全区间</strong>反映了<strong>预估往返时间</strong>会与<strong>测量往返时间</strong>的<strong>偏差量</strong></li>
</ol>
<h4 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>特点</p>
<ol>
<li><p>管道化（流水线）的报文段（GBN or SR）</p>
</li>
<li><p>累积确认（GBN）</p>
</li>
<li><p>最老发送未确认的分组的计时器（GBN）</p>
</li>
<li><p>重传</p>
<ol>
<li>超时重传 只重发最老的未确认的分组（SR）同时重启定时器</li>
<li>重复确认</li>
</ol>
</li>
<li><p>收到确认</p>
<p>如果是对尚未确认的报文段确认</p>
<ol>
<li>更新已被确认的报文段</li>
<li>如果当前还有已发送未确认的报文段，重启计时器</li>
</ol>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>接收方事件</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认</td>
<td>不马上返回ack 而是等待一段时间然后返回最新的ack，但是最多等待500ms，超时赶紧发，防止发送方超时重发</td>
</tr>
<tr>
<td>有期望序号的报文段到达。另一个按序报文段等待发送ACK</td>
<td>攒了两个ACK 直接发送最新的ACK</td>
</tr>
<tr>
<td>比期望序号大的报文段乱序到达。检测出数据流中的间隔</td>
<td>立即发送重复的ACK，指明下一个期待字节的序号</td>
</tr>
<tr>
<td>能部分或完全填充接收数据间隔的报文段到达</td>
<td>间隔全补齐了 发送最新AC 部分补齐 发送部分补齐后的期待序号</td>
</tr>
</tbody>
</table>
</div>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>超时周期可能设置太长了，报文早就丢失了，但是很久才超时，利用快速重传在定时器超时前重传</p>
<p>通过重复ACK来实现快速重传，如果连续收到3个重复序号的ACK，直接重传</p>
<p><img src="/posts/37553/image-20230526165356198.png" alt="image-20230526165356198"></p>
<p>40-49正常接收，正常回复</p>
<p>接着接收方收到了60-69 70-79 80-89的确认 只能返回50，多个重复50ACK，大概率50-59丢失，重传50-59</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p><strong>目的：</strong>接收方控制发送方，不让发送方发得太多、太快，导致接收方来不及接受（缓冲区溢出），需要反复重传，反而降低了效率</p>
<p><strong>实现：</strong>接收方向发送方通告自己的空闲缓冲区大小，发送方就能限制自己发送未接收的字节的个数&lt;=空闲缓冲区的大小，这里可以利用捎带技术避免多次交互，就是A和B都有信息要互相发送，那么可以在发送data时捎带ack和buffer数据，告知对方上一条信息的接收结果以及当前空闲缓冲区大小</p>
<p><strong>传统模式</strong>：A→(data)→B，B→(ack)→A，B→(data)→A，A→(ack)→B</p>
<p><strong>捎带技术</strong>：A→(data)→B，B→(data+ack+buffer)→A，A→(data+ack+buffer)→B</p>
<p>问题：接收方发送一个接收缓冲区为0的控制信号，发送方将发送缓冲区设置为0之后，接收方想要调整发送缓冲区为300，但是这个信号丢失了，发送方不发送，接收方收不到，死锁</p>
<p>解决：发送方只要接收到缓冲区置为0的信息，就启动持续计时器，这个计时器超时都没有收到增加缓冲区的信息，就发送一个零窗口的探测报文（本身自带重传计时器，丢失也没事），接收方收到这个探测报文后，就会返回自己的缓冲区大小（如果还是0，就重新计时，否则，也打破了死锁；需要注意即使接收缓冲区是0，也得接收推测报文、确认报文段及带有紧急信息的报文段）</p>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><h5 id="粗略版"><a href="#粗略版" class="headerlink" title="粗略版"></a>粗略版</h5><h6 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h6><p><img src="/posts/37553/image-20230603131643631.png" alt="image-20230603131643631"></p>
<p>两次握手的问题</p>
<p><img src="/posts/37553/image-20230603131833848.png" alt="image-20230603131833848"></p>
<h6 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h6><p><img src="/posts/37553/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<p>MSL：最长报文段寿命</p>
<p>2*MSL：确保TCP服务进程可以收到最后一个TCP确认报文段而进入关闭状态，TCP客户进程在发送最后一个确认报文后，2*MSL也能确保本次连接持续时间内所产生的所有报文段从网络中消失，不会对后续新的连接产生影响</p>
<p>TCP客户端出问题：保活计时器，超时就发送探测报文，一连发送10个都得不到响应就关闭该连接</p>
<h5 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h5><p><strong>连接管理：发送方和接收方握手建立通信关系</strong></p>
<p>两次握手的缺陷</p>
<ol>
<li>客户端，建立连接吧？</li>
<li>服务端，ok</li>
</ol>
<p>半连接，只在服务端维护了一个连接：客户端发送建立连接后，迟迟没有收到服务端的反馈，超时了，又重传连接请求，然后客户端前一个连接请求建立了，后一个也建立了连接（在服务端建立连接），前一个可以通过客户端正常终止，但是后一个连接会在服务端造成资源浪费</p>
<p><strong>连接建立-&gt;变化的初始序号+双方确认对方的序号（三次握手）</strong></p>
<p><img src="/posts/37553/image-20230523191006681.png" alt="image-20230523191006681"></p>
<ol>
<li>客户端发送给服务器，告知对方，我要建立连接，同时发送随机生成的初始序列号（x）</li>
<li>服务端返回给客户端，说我收到你的连接请求了，也随机生成一个初始序列号（y），返回对发送方序列号的确认（x+1），询问是否真的要建立连接</li>
<li>客户端得到服务端的确认，知道服务端是响应的，返回ACK（y+1，可能包含第一条数据，捎带机制），服务端接收到ACK（y+1），连接才真正建立</li>
</ol>
<p><strong>连接释放：四次挥手</strong></p>
<ol>
<li><p>客户端发送一个FIN=0，表明自己没有数据要发了，用来关闭和服务端的连接，自身进入FIN_WAIT_1状态，只能接收数据，不能发送数据了，控制信息还能发送</p>
</li>
<li><p>服务端接收到FIN，发送一个ACK，确认序号为收到的序号+1，告知客户端，我知道你要关闭连接，但是我可能还有数据没发完，因此服务端进入CLOSE_WAIT状态，</p>
<p>这里可以将服务端没有发送完的数据发完</p>
</li>
<li><p>发送完之后，服务端发送一个FIN=0，表明我这边也没数据了，用来关闭和客户端的连接，自身进入LAST_ACK状态</p>
</li>
<li><p>客户端接收到FIN，进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到序号+1，服务端收到后进入CLOSED状态，客户端等待一段时间（最长报文段寿命的两倍）没有收到回复那么也关闭</p>
<p>如果最后客户端没有发送ACK，那么服务端连接没有关闭</p>
<p>如果客户端等待时间的定时器设置太短，客户端自顾自关闭连接，服务端如果没有收到ack，而客户端又关闭了，那么服务端即便重发断连请求，也无法终止连接了</p>
<p>因此，客户端的等待时间为两倍的往返传输延迟，为什么是这个时间？</p>
<ol>
<li><strong>确保ACK报文的传输</strong>：等待2MSL的时间确保了客户端发送的ACK报文能够正确被对端服务器接收。如果服务器没有收到ACK报文，它将重新发送FIN报文，客户端在等待2MSL的期间将有机会再次发送ACK报文。</li>
<li><strong>处理可能的延迟报文</strong>：在网络传输过程中，可能存在延迟的报文。等待2MSL的时间可以确保这些延迟报文在网络中消失。这样，当新的连接建立时，就不会出现错误地将这些延迟报文误认为是新连接的报文的情况。</li>
<li><strong>避免连接状态不一致</strong>：如果客户端在发送ACK报文后立即关闭连接，可能导致服务器端还处于等待ACK确认的状态。当服务器再次发送FIN报文时，客户端可能已经关闭了连接，这将导致服务器无法正确关闭连接，出现连接状态不一致的问题。等待2MSL的时间，可以确保双方都能正确收到关闭连接的报文，避免连接状态不一致。</li>
</ol>
</li>
</ol>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="粗略版-1"><a href="#粗略版-1" class="headerlink" title="粗略版"></a>粗略版</h5><ol>
<li><p>慢开始和拥塞避免</p>
<p><img src="/posts/37553/image-20230603123520531.png" alt="image-20230603123520531"></p>
</li>
<li><p>快重传</p>
<p>有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。这将导致发送方超时重传，并误认为网络发生了拥塞；</p>
<p>发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。</p>
<p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<p>所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。</p>
<ul>
<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</li>
<li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li>
<li>发送方一旦收到3个连续的重复确认（加上有效确认一共4个），就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li>
<li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞(进而降低拥塞窗口cwnd为1)。使用<br>快重传可以使整个网络的吞吐量提高约20%。</li>
</ul>
</li>
<li><p>快恢复</p>
<p>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法；</p>
<ul>
<li>发送方将慢开始阈值和拥塞窗口CongWin值调整为当前窗口的一半；开始执行拥塞避免算法（线性增）。</li>
<li>也有的快恢复实现是把快恢复开始时的拥塞窗口CongWin值再增大一些，即等于新的阈值+3（收到3个重复的确认，表明有3个后续的报文时收到了的，存储在缓冲区中）。</li>
</ul>
</li>
</ol>
<p><strong>超时重传时间</strong></p>
<p>加权平均往返时间+4×偏差值</p>
<p><strong>新问题</strong>：发送方接收到ACK，不知道是对原始报文的ACK还是对重传报文的ACK，RTT的测量不准确</p>
<h5 id="详细版-1"><a href="#详细版-1" class="headerlink" title="详细版"></a>详细版</h5><p><strong>与流量控制（点对点）不同，拥塞控制针对的是网络层面：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。前提是网络能够承受现有的网络负荷。</strong></p>
<p>拥塞表现：分组丢失，分组延迟剧增，当路由器的带宽利用率接近满载时，路由器转发延迟剧增</p>
<p>拥塞延长传输延迟，延迟导致超时重传，而这种重传有时候是没必要的，不断重传又加剧了拥塞</p>
<p>数据需要经过多个路由器的转发才能抵达终点，而在第i个路由器被抛弃，前面的路由的传输能力都被浪费了</p>
<p><strong>端到端的拥塞控制</strong></p>
<p>端系统通过延迟和丢失事件判断网络中是否发生了拥塞</p>
<p><strong>网络辅助的拥塞控制</strong></p>
<p>路由器给端系统提供反馈信息，表示网络中是否用拥塞，显式告知发送端能够发送的最大速率</p>
<p><strong>TCP拥塞控制：端到端的拥塞控制</strong></p>
<p>路由器不需要向端系统反馈信息，负担较轻，符合网络核心功能简单的TCP\IP架构原则</p>
<h6 id="拥塞检测"><a href="#拥塞检测" class="headerlink" title="拥塞检测"></a><strong>拥塞检测</strong></h6><p>端系统根据自身得到的信息判断是否发生拥塞，从而采取必要的行动</p>
<p><strong>超时：拥塞比较严重了</strong></p>
<p>某个段超时了，超时时间到了，关于这个段的ACK没有到来，两个原因</p>
<ol>
<li><strong>网络拥塞，丢弃了，发生的概率比较大</strong></li>
<li>出错而被中转节点丢弃了，发生概率比较小</li>
</ol>
<p><strong>重复ACK：轻微的拥塞</strong></p>
<p>发送方接收到了3次重复ACK，比如 0 1 2 3这四个段</p>
<ol>
<li><p>收到1 说明0到达了</p>
</li>
<li><p>又收到了1 说明2乱序到达了</p>
</li>
<li><p>又收到了1 说明3乱序到达了</p>
<p>1丢失的可能性很大，但是2 3却收到了，说明网络暂时还有传输能力</p>
<p>此时发送方可能还没出发超时重传，需要做快速重传（直接重传1），发送方知道网络可能即将拥塞</p>
</li>
</ol>
<h6 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a><strong>控制策略</strong></h6><p>维护一个拥塞窗口（Congestion Window，CongWin），限制已发送但是没有确认的字节数，用于控制发送方的发生速率，粗略地控制发送方往网络注入数据的速率，拥塞窗口的大小是动态的</p>
<ol>
<li><p>慢启动</p>
<p>连接刚建立时，CongWin置为1，然后倍增（SS阶段，每次收到一个ACK，就+1个MSS）</p>
<p><img src="/posts/37553/image-20230526185145951.png" alt="image-20230526185145951"></p>
</li>
<li><p>线性增，乘性减（Additive Increase Multiplicative Decrease，AIMD）</p>
<ol>
<li>乘性减：将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增直到CongWin/2）  </li>
<li>线性增：当Cong＞阈值时，一个RTT如没有发生丢失事件，将CongWin加1MSS:试探</li>
</ol>
</li>
<li><p>超时后的保守策略</p>
<ol>
<li><p>超时</p>
<p>将CongWin降为1MSS（MSS是最大报文段大小，即只允许发送一个分组），阈值之诶CongWin/2，进入慢启动（Slow-Start，SS）阶段，逐渐倍增至CongWin/2（每收到一个ACK增加一个MSS），然后进入拥塞避免阶段（Congestion Avoidance，CA）：线性增加</p>
</li>
<li><p>重复ACK</p>
<p>阈值置为CongWin/2，CongWin置为阈值+3（快速重传，收到3个重复ACK说明有三个序号大的已经收到，存在缓冲区内，线性增+3），然后进入拥塞避免阶段（Congestion Avoidance，CA）：线性增加</p>
</li>
</ol>
</li>
</ol>
<p><img src="/posts/37553/image-20230530134608112.png" alt="image-20230530134608112"></p>
<h6 id="联合控制"><a href="#联合控制" class="headerlink" title="联合控制"></a>联合控制</h6><p>SendWin={CongWin, RevcWin}，同时满足拥塞控制和流量控制两个要求</p>
<h6 id="TCP的公平性"><a href="#TCP的公平性" class="headerlink" title="TCP的公平性"></a>TCP的公平性</h6><p>两个竞争关系的TCP对话</p>
<p><img src="/posts/37553/image-20230526190508888.png" alt="image-20230526190508888"></p>
<ol>
<li>一开始比如是AA’占据优势，BB’劣势</li>
<li>增加直到发生超时，需要将窗口减半，AA’本来窗口大，减半就多，BB’窗口小，减半少</li>
<li>又开始线性增加，同样还是窗口大的减少多，逐渐会趋向于带宽平分</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-应用层</title>
    <url>/posts/63069.html</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>只关心应用层自身的功能和传输层提供的服务，屏蔽传输层以下层次的具体细节，在这一层的数据单元叫报文（message）</p>
<p>比如email，Web，网络游戏，流媒体，网络会议，社交网络等等</p>
<h3 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h3><p>网络应用程序的组织结构，描述应用程序在网络中的不同角色和交互方式</p>
<h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h4><ul>
<li><p>服务器</p>
<ul>
<li>一直运行</li>
<li>固定的IP地址和周知（约定）的端口</li>
<li>扩展性：部署多个服务器，扩展性比较差，达到性能瓶颈后断崖式下降</li>
<li>可靠性：所有资源均位于服务器，可靠性比较差</li>
</ul>
</li>
<li><p>客户端</p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网的连接是间歇性的</li>
<li>IP地址可能是动态的</li>
<li>不直接与其他客户端通信</li>
</ul>
</li>
</ul>
<h4 id="对等模式"><a href="#对等模式" class="headerlink" title="对等模式"></a>对等模式</h4><ul>
<li>可以认为没有需要一直运行的服务器</li>
<li>任意端系统之间可以直接进行通信</li>
<li>每个节点可以认为既是服务器也是客户端</li>
<li>自扩展性：新Peer节点带来新的服务能力和服务请求</li>
<li>参与的主机间歇性连接且可以改变IP地址，但是可能带来难以管理的问题</li>
<li>文件分发（bitTorrent）、流媒体、VoIP</li>
</ul>
<h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p><strong>Napster</strong></p>
<ul>
<li>文件搜索：C/S<ul>
<li>任意端系统向服务器注册自己拥有的资源</li>
<li>任意端系统在服务器检索所需资源的位置</li>
</ul>
</li>
<li>文件传输：P2P<ul>
<li>任意端系统之间都可以进行数据传输</li>
</ul>
</li>
</ul>
<p><strong>即时通讯</strong></p>
<ul>
<li>在线检测：C/S<ul>
<li>用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，找到在线好友的位置</li>
</ul>
</li>
<li>聊天：P2P</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul>
<li>进程：在主机上运行的应用程序</li>
<li>同一个主机：使用进程间通信机制（操作系统）进行通信</li>
<li>不同主机：通过交换报文（Message）进行通信<ul>
<li>需要使用操作系统提供的进程间通信服务</li>
<li>借助传输层提供的服务，按照应用协议交换报文</li>
</ul>
</li>
</ul>
<h3 id="分布式进程通信"><a href="#分布式进程通信" class="headerlink" title="分布式进程通信"></a>分布式进程通信</h3><h4 id="进程标识和寻址问题"><a href="#进程标识和寻址问题" class="headerlink" title="进程标识和寻址问题"></a>进程标识和寻址问题</h4><p>进程为了接收正确的报文，需要有一个标识（IP + port），唯一代表主机上的这个进程</p>
<ol>
<li>主机：唯一的32位IP地址</li>
<li>端口号（Port Number）</li>
<li>需要使用到的传输层协议TCP UDP</li>
</ol>
<h4 id="应用层功能"><a href="#应用层功能" class="headerlink" title="应用层功能"></a>应用层功能</h4><p>应用层协议定义了应用程序与网络之间的通信规则和数据格式，使得不同设备和应用程序能够互相协作和交换数据。协议是应用层的一个组成部分，例如web应用由HTTP协议、web浏览器、web服务器和HTML协议等部分组成</p>
<p><strong>通信规则和数据格式</strong></p>
<ol>
<li>交换的报文类型：请求报文和应答报文</li>
<li>不同报文类型的语法规范：报文中的应该有哪些字段，分别有什么作用</li>
<li>字段的语义：字段取某个值有什么含义</li>
<li>进程什么时候，怎么样发送报文，以及对报文如何进行响应的规则</li>
</ol>
<p><strong>主要功能</strong></p>
<ol>
<li>提供应用程序接口（API）：应用层协议定义了应用程序与网络之间的接口，使得应用程序可以方便地访问网络资源和服务。常见的应用层协议包括HTTP、FTP、SMTP等，它们提供了不同的API，用于实现Web服务、文件传输、电子邮件等功能。</li>
<li>实现应用层协议：应用层协议定义了应用程序与网络之间的通信规则和数据格式，应用程序必须遵守这些规则才能与网络进行通信。例如，HTTP协议定义了Web浏览器和Web服务器之间的通信规则，包括请求和响应的格式、请求方法、状态码等，使得Web浏览器和Web服务器能够互相通信和交换数据。</li>
<li>支持数据编码和解码：在网络中传输的数据需要进行编码和解码，以确保数据的正确性和完整性。应用层协议可以支持不同的数据编码和解码方式，例如Base64编码、压缩编码等，以便于在网络中传输和处理数据。</li>
</ol>
<p>为了实现上述的应用层功能，需要借助传输层的服务，也就需要将数据进行层间垂直传输</p>
<p><strong>数据</strong>：</p>
<ul>
<li>要传输的报文（本层：服务数据单元SDU）</li>
<li>源：自身的IP和TCP（UDP）端口号</li>
<li>目的地：对方的IP和TCP（UDP）端口号</li>
</ul>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>每次层间数据传输，除了服务数据单元外，都要传这么多上述<strong>数据</strong>（源IP 目标IP等等），过于繁琐，容易出错，也难以管理，引入socket这一个唯一的整数用来在本地唯一标识通信的双方（TCP）或者单方（UDP），作用范围是<strong>本地</strong></p>
<blockquote>
<p>类比操作系统中的文件句柄，使用这个句柄，就可以操作文件，不需要每次都获取文件的目录、文件名及打开方式，或者C++中的指针</p>
</blockquote>
<h5 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h5><p>TCP服务：两个进程之间的通信需要预先建立连接，通信一般会持续一段时间，通信关系比较稳定，比如文件传输</p>
<p>socket：用一个唯一的整数标识具有本地意义的四元组&lt;源IP，源端口，目标IP，目标端口&gt;，唯一指定了一个对话（两个进程之间的对话）</p>
<p>特点：</p>
<ol>
<li>通信时，不需要发送每个报文都附带这个四元组，通过socket就可以标识</li>
<li>简单，易于管理</li>
</ol>
<h5 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h5><p>UDP服务：两个进程之间的通信无需建立连接，每个报文都是独立传输的，不关心是否发送/接收成功，本地进程发送的前后报文可能给不同的进程（目标IP和目标端口不一样）</p>
<p>socket：用一个唯一的整数标识具有本地意义的二元组（源IP，源端口），目标IP和目标端口需要提供，唯一指定了一个本地的应用进程</p>
<p>特点：</p>
<ol>
<li>在发送数据报时，采用创建好的本地套接字，就不必在发送每个报文中指明自己所采用的ip和port</li>
<li>发送报文时，还是要指定对方的ip和udp 端口号</li>
</ol>
<h4 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h4><p>传输层实体（tcp或者udp实体）根据上述数据进行TCP报文段或者UDP数据报的封装，进一步将IP地址往下送给网络层的IP实体，进行IP数据包的封装</p>
<h5 id="服务指标"><a href="#服务指标" class="headerlink" title="服务指标"></a>服务指标</h5><ul>
<li><p>数据丢失率</p>
<ul>
<li><p>有些应用则要求100%的可靠数据传输（如文件）</p>
</li>
<li><p>有些应用（如音频）能容忍一定比例以下的数据丢失</p>
</li>
</ul>
</li>
<li><p>延迟</p>
<ul>
<li><p>一些应用 出于有效性考虑，对数据传输有严格的时间限制</p>
</li>
<li><p>Internet电话、交互式游戏</p>
</li>
</ul>
</li>
<li><p>吞吐</p>
<ul>
<li>一些应用（如多媒体）必须需要最小限度的吞吐（要不然看视频一卡一卡的），从而使得应用能够有效运转</li>
<li>一些应用能充分利用可供使用的吞吐(弹性应用)</li>
</ul>
</li>
<li><p>安全性</p>
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性</li>
</ul>
</li>
</ul>
<p><img src="/posts/63069/image-20230524193027946.png" alt="image-20230524193027946"></p>
<h5 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h5><ol>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接收方</li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方的发送速率</li>
<li>面向连接：两个进程之间需要建立连接才能通信</li>
<li>无法保证延迟、吞吐量和安全性</li>
</ol>
<h5 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h5><ol>
<li>不可靠的传输服务</li>
<li>无需建立连接</li>
<li>无法提供流量控制、拥塞控制、延迟、带宽、安全性等</li>
</ol>
<p>必要性：</p>
<ol>
<li><p>网络层的IP不能区分进程，需要用到UDP 端口号区分进程</p>
</li>
<li><p>无需建立连接，节省时间</p>
<p>比较适合事务性的应用，比如</p>
<ol>
<li>域名系统（Domain Name System，DNS）：DNS是一种将域名映射到IP地址的分布式数据库系统，它使用UDP协议进行域名解析和查询，由于查询速度要求高、数据量小，因此使用UDP协议更加合适。</li>
<li>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）：用于自动分配IP地址、子网掩码、网关等网络参数，它使用UDP协议实现客户端与服务器之间的通信，由于数据量小、传输速度要求高，因此使用UDP协议更加合适。</li>
<li>基于IP的语音传输（Voice over Internet Protocol，VoIP）：VoIP是一种基于网络的语音通信技术，它使用UDP协议进行语音数据的传输，由于实时性要求高、数据量小、传输速度要求高，因此使用UDP协议更加合适。</li>
</ol>
</li>
<li><p>不用付出时间代价做可靠性的工作</p>
<p>比如检错重发、确保有序等，实现简单，比较适合对实时性要求较高的应用，比如流媒体</p>
</li>
<li><p>没有拥塞控制和流量控制，应用能够按照预设的速度发送数据</p>
<p>TCP上面的应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</p>
</li>
</ol>
<p><img src="/posts/63069/image-20230524193653667.png" alt="image-20230524193653667"></p>
<h3 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li>万维网（World Wide Web, WWW）:分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。<strong>万维网实际上是运行在互联网上的一种应用服务，提供了互联网上的信息内容</strong><ul>
<li>互联网定义了网络间通信的规则,而万维网定义了在互联网上传输内容的规则</li>
<li>互联网是网络的集合,让计算机能够相互通信;万维网是一个信息服务,提供互联网上的内容</li>
<li>互联网存在于物理层,万维网存在于应用层。</li>
<li>互联网把网络相连在一起,而万维网为这些网络中的计算机和设备提供信息服务。</li>
</ul>
</li>
<li><strong>超文本标记语言（Hypertext Markup Language，HTML）</strong>：一种基于文本的语言，用于描述网页的结构和内容，通过标签（tag）和属性（attribute）来定义网页的元素和样式</li>
<li><strong>统一资源定位符（URL）</strong>：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标识资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>
<li><strong>Web页</strong>：由一些对象构成<ul>
<li>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</li>
<li>Web页首先含有一个基本的HTML文件，这个文件又包含若干对象的引用（链接）</li>
<li>通过统一资源定位符（Uniform Resource Locator，URL）对每个对象进行引用<ul>
<li>访问协议，用户名，口令字，端口等</li>
<li><img src="/posts/63069/image-20230525133406144.png" alt="image-20230525133406144"></li>
</ul>
</li>
</ul>
</li>
<li>往返时间（Round Trip Time，RTT）：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）</li>
<li>响应时间：客户端发起请求后得到响应的时间</li>
</ul>
<h4 id="超文本传输协议"><a href="#超文本传输协议" class="headerlink" title="超文本传输协议"></a>超文本传输协议</h4><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）：一种用于在Web浏览器和Web服务器之间基于TCP协议交换数据的应用层协议</p>
<p>属于客户/服务器模式，客户是请求、接收和显示Web对象的浏览器，服务器是对请求进行响应，返回对象的服务器</p>
<p><img src="/posts/63069/8e3efca026654874bde8be88c96e1783tplv-k3u1fbpfcp-zoom-1.jpeg" alt="img"></p>
<h5 id="基于TCP协议实现HTTP协议"><a href="#基于TCP协议实现HTTP协议" class="headerlink" title="基于TCP协议实现HTTP协议"></a>基于TCP协议实现HTTP协议</h5><ol>
<li><p>服务器启动，初始化一个守护socket，在某个固定IP的80号端口上保持监听状态</p>
<p>守护socket，不代表任何会话关系，在服务器端保存持久连接，起到监听的作用</p>
</li>
<li><p>客户发起一个与服务器的TCP连接（80号端口）</p>
</li>
<li><p>服务器接受客户的TCP连接，生成一个新的socket，代表服务器与这个客户端的会话关系</p>
</li>
<li><p>在浏览器(HTTP客户端)与 Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文)</p>
<p>浏览器收到返回的HTTP报文后，需要绘制出来，通过URL进行对象解析，对链接、图片都要这样操作，获取资源进行绘制</p>
</li>
<li><p>TCP连接关闭</p>
</li>
</ol>
<h5 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h5><p><strong>无状态的连接：</strong>服务器并不维护任何关于客户的信息</p>
<p>因为维护状态的协议很复杂：</p>
<ol>
<li>必须维护历史信息</li>
<li>如果服务器/客户机死机，可能导致双方的状态信息不一致，实现同步很困难</li>
<li>无状态的服务器可扩展性更好，能够支持更多客户端的连接</li>
</ol>
<p><strong>非持久HTTP（HTTP/1.0时代）</strong></p>
<ul>
<li><p>最多只有一个对象在TCP连接上发送， 下载多个对象需要建立多个TCP连接</p>
<p>假设用户输入URL：<a href="http://www.someschool.edu/someDept/home.index">http://www.someschool.edu/someDept/home.index</a></p>
<ol>
<li>HTTP客户端在端口号80发起一个到服务器www.someSchool.edu的连接</li>
<li>位于主机www.someSchool.edu的HTTP服务器在80号端口等待连接，接受连接并通知客户端</li>
<li>HTTP客户端向TCP连接的套接字发送HTTP请求报文，报文表示客户端需要对象someDepartment/home.index</li>
<li>HTTP服务器接收到请求报文，检索出被请求的对象，将对象封装在一个响应报文，并通过其套接字向客户端发送</li>
<li>HTTP关闭TCP连接</li>
<li>HTTP客户端收到包含html文件的响应报文，并显示html。然后对html文件进行检查，找到10个引用对象</li>
<li>对10个引用对象，重复上述1-7的操作，直到所有引用对象都绘制出来</li>
</ol>
<p><strong>响应时间=2RTT+文件传输时间</strong>：一个RTT用来发起和建立TCP连接（这里传输的数据很少，传输时间忽略不计），一个RTT用来发送HTTP请求并等待HTTP响应，最后还有文件传输时间</p>
<p><strong>缺陷</strong></p>
<ul>
<li>每个对象传输都要2个RTT用来建立连接和回应请求</li>
<li>操作系统需要为每个对象的每个TCP连接分配资源，而浏览器通常都会打开并行TCP连接获取引用的资源</li>
</ul>
<p><strong>请求方法类型</strong></p>
<ul>
<li>GET：请求资源</li>
<li>POST：提交表单</li>
<li>HEAD：要求服务器在响应报文中不包含请求对象 故障跟踪</li>
</ul>
</li>
</ul>
<p><strong>持久HTTP（HTTP/1.1时代）</strong></p>
<ul>
<li><p>多个对象可以在一个TCP连接（客户端-服务器）上进行传输，其实就是连接不关闭，后续有数据要传输，直接传输</p>
</li>
<li><p>服务器发送HTTP报文后不关闭连接，保持响应</p>
</li>
<li><p>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</p>
</li>
<li><p>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</p>
<p><strong>非流水线的持久HTTP</strong>：</p>
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
<p><strong>流水线的持久HTTP</strong>：</p>
<ul>
<li>客户端遇到一个引用对象就立即产生一个请求，不需要等待前一个请求的回应</li>
<li>所有引用对象在最理想的情况下可能只需要一个RTT</li>
</ul>
<p><strong>请求方法类型</strong></p>
<ol>
<li><p>GET,POST,HEAD</p>
</li>
<li><p>PUT：将实体主体中的文件上载到URL字段规定的路径</p>
</li>
<li><p>DELETE：删除URL字段规定的文件 </p>
<p>后两个一般是网络管理员用于维护网页</p>
</li>
</ol>
</li>
</ul>
<h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p><strong>请求报文</strong></p>
<p><img src="/posts/63069/image-20230525141040080.png" alt="image-20230525141040080"></p>
<p><strong>提交表单输入</strong></p>
<p>网页通常包含表单的输入</p>
<ol>
<li><p>Post方式</p>
<p>包含在实体主体（entity body）中的输入被提交到服务器</p>
<p><img src="/posts/63069/image-20230525141300359.png" alt="image-20230525141300359"></p>
</li>
<li><p>Get方式（URL的方式）</p>
<p>输入通过请求的URL字段上载</p>
<p><img src="/posts/63069/image-20230525141319186.png" alt="image-20230525141319186"></p>
</li>
</ol>
<h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p><strong>格式</strong></p>
<p><img src="/posts/63069/image-20230525141655102.png" alt="image-20230525141655102"></p>
<p><strong>状态码</strong></p>
<p>200 OK：请求成功，请求对象包含在响应报文的后续部分  </p>
<p>301 Moved Permanently：请求的对象已经被永久转移了；新的URL在响应报文的Location:首部行中指定，客户端软件自动用新的URL去获取对象  </p>
<p>400 Bad Request：一个通用的差错代码，表示该请求不能被服务器解读</p>
<p>404 Not Found：请求的文档在该服务上没有找到</p>
<h5 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h5><p>用于维护用户-服务器的连接状态， 在四个地方记录或者使用</p>
<ol>
<li>在HTTP响应报文中有一个cookie的首部行，使用</li>
<li>在HTTP请求报文含有一个cookie的首部行，使用</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器管理，记录</li>
<li>在Web站点有一个后端数据库，记录</li>
</ol>
<blockquote>
<p>Susan总是用同一个PC使用Internet Explore上网</p>
<p>她第一次访问了一个使用了Cookie的电子商务网站</p>
<p>当最初的HTTP请求到达服务器时，该Web站点产生一个唯一的ID，并以此作为索引在它的后端数据库中产生一个项</p>
<p>后续访问，客户端带上这个cookie，服务器识别这个cookie就知道怎么回应了（购物车信息，产品推荐…）</p>
<p><img src="/posts/63069/image-20230525142057370.png" alt="image-20230525142057370"></p>
</blockquote>
<p><strong>便利性</strong>：</p>
<ol>
<li>用户验证</li>
<li>购物车记录</li>
<li>推荐</li>
<li>用户状态</li>
</ol>
<h5 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h5><p><strong>代理服务器（Proxy Server）</strong>：代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</p>
<p>代理服务器（大学、公司、居民区的ISP）设置缓存，其实就是客户不需要访问原始服务器，由代理服务器满足客户的需求</p>
<p>实际上，客户端自身也能进行缓存</p>
<p>用户设置浏览器：运行通过代理服务器的缓存访问网页</p>
<p>浏览器将所有的HTTP请求发给代理服务器</p>
<ol>
<li>缓存中的对象直接返回</li>
<li>不在缓存中的对象，代理服务器去向原始服务器要，存储到缓存中，再返回给客户端</li>
</ol>
<p>优势</p>
<ol>
<li>降低客户端响应时间</li>
<li>大大减少一个区域内部和互联网这个外部的交互流量</li>
<li>降低原始服务器的负担</li>
</ol>
<p><strong>条件式获取（Conditional GET）：访问的对象实际上在服务器端已经更新了</strong></p>
<ol>
<li>用户向代理服务器请求某个对象，这个对象在代理中有，但是不确定是不是最新的</li>
<li>在代理向服务器的请求报文中添加头部 If-modified-since: <date>，实际上这个日期应该是最近的一次缓存该对象的日期  ，询问这个对象自从这个日期后有没有进行修改</date></li>
<li>如果没有修改，那么返回304 Not Modified</li>
<li>如果有修改，那就需要服务器重传一份给代理</li>
</ol>
<h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h3><p>文件传输协议（File Transfer Protocol，FTP）用于在本地文件系统和远程文件系统之间传输文件，基于TCP实现，同时FTP也是一个应用程序</p>
<p><img src="/posts/63069/image-20230525144700990.png" alt="image-20230525144700990"></p>
<p><strong>客户/服务器模式</strong></p>
<ul>
<li>客户：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
<p>客户端和服务器通过端口21进行连接，并使用TCP作为传输协议</p>
<p><strong>控制连接（control connection）</strong>：用于传输FTP命令（登录、列出目录、上传文件等）和响应信息（成功、失败、文件已存在），以便客户端和服务器进行通信，控制连接始终由客户端发起，始终保持连接状态直到客户端关闭连接或者服务器超时而关闭</p>
<p><strong>数据连接（data connection）</strong>：用于传输文件内容的连接</p>
<p>控制连接其实是<strong>带外（out of band）传输</strong>的体现，带外传输指:使用与主要数据流（in-band，带内）不同的通信通道传输控制信息或数据的过程</p>
<p><strong>执行流程</strong></p>
<ol>
<li>客户端通过控制连接获得身份确认（身份认证，明文传输）</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
<li>服务器收到一个文件传输命令时，打开一个与客户端的数据连接</li>
<li>文件传输完成后，数据连接关闭，但是控制连接依然保持 </li>
<li>如果有新的文件需要传输，服务器会打开新的数据连接进行传输</li>
</ol>
<p><strong>FTP服务器维护用户的状态信息</strong>：当前访问了哪个目录，用户账户与控制连接进行对应</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><strong>主要组成部分</strong></p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议：SMTP</li>
</ul>
<h4 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h4><p><strong>邮件阅读器：Outlook、Foxmail</strong></p>
<ul>
<li>负责撰写、编辑和阅读邮件</li>
<li>输出和输入邮件保存在服务器上</li>
</ul>
<p><img src="/posts/63069/image-20230525150001750.png" alt="image-20230525150001750"></p>
<h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><ul>
<li>邮箱：管理和维护发送给用户的邮件</li>
<li>待发送：以报文队列保存待发送的邮件报文</li>
<li>邮件服务器之间利用SMTP协议互发email报文</li>
<li>用户发邮件：使用<strong>TCP协议</strong>基于25号端口将邮件发给服务器，服务器基于<strong>TCP协议</strong>投递到对方在服务器中的邮箱</li>
<li>用户收邮件：从服务器中自己的邮箱中拉取邮件，需要使用POP3 IMAP和HTTP协议<ul>
<li>邮局访问协议 第三版（Post Office Protocol version 3，POP3）  <ol>
<li>只能区分 收件箱和发件箱</li>
<li>想要阅读邮件只能下载下来，无法在服务器上整理邮件</li>
<li>一次只能从一个设备访问邮件</li>
<li>不支持在线搜索邮件内容</li>
</ol>
</li>
<li>Internet 邮件访问协议（Internet Mail Access Protocol，IMAP）<ol>
<li>允许在远程的服务器上创建目录，移动文件</li>
<li>允许多个设备同时访问邮件</li>
<li>下载前可以阅读部分邮件内容</li>
<li>支持在线搜索邮件内容</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<ol>
<li>Alice使用用户代理撰写邮件并发送给bob@someschool.edu</li>
<li>Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中</li>
<li>SMTP的客户端打开到Bob邮件服务器的TCP连接</li>
<li>SMTP客户端通过TCP连接发送Alice的邮件</li>
<li>Bob的邮件服务器将邮件放到Bob的邮箱</li>
<li>Bob调用他的用户代理阅读邮件</li>
</ol>
<h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>一种用于发送电子邮件的标准协议，它定义了如何将电子邮件从一个邮件客户端发送到一个或多个邮件服务器（下一跳是哪），并最终发送到目标邮件服务器上的收件人的电子邮件客户（只负责发送，不负责接收，接收由POP3 IMAP实现）</p>
<p><strong>作用范围</strong></p>
<ol>
<li>客户端通过SMTP服务发送给邮箱服务器</li>
<li>邮箱服务器之间通过SMTP服务互相传输邮件</li>
</ol>
<p><strong>工作流程</strong></p>
<ol>
<li>邮件客户端向邮件服务器发送连接请求。</li>
<li>邮件服务器响应连接请求，并等待邮件客户端发送邮件。</li>
<li>邮件客户端发送邮件到邮件服务器，包括邮件的主题、正文和附件等信息。</li>
<li>邮件服务器接收邮件，并将其存储在邮件队列中，等待发送到目标邮件服务器。</li>
<li>邮件服务器使用DNS来查找目标邮件服务器的地址。</li>
<li>邮件服务器向目标邮件服务器发送邮件。</li>
<li>目标邮件服务器接收邮件，并将其存储在邮件队列中，等待目标邮件客户端检索。</li>
<li>目标邮件客户端从邮件服务器中检索邮件，并将其显示在邮件客户端中。</li>
</ol>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p><strong>必要性</strong></p>
<p>IP地址虽然能够标识主机、路由器，但是不好记忆，需要用字符串的名称来标识IP地址，进一步就需要一个服务能够负责将名称转换为IP地址</p>
<p><strong>Domain Name System，DNS</strong>：一个由分层的DNS服务器实现的分布式数据库系统，同时也是一个帮助主机查询这个分布式系统的基于UDP（53）实现传输的协议，实际上就是<strong>为互联网设计的电话簿</strong></p>
<ol>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址的转换</li>
</ol>
<h4 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h4><ol>
<li>顶级域（Top Level Domain，TLD）DNS服务器：负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp）  </li>
<li>权威DNS服务器：组织机构的DNS服务器， 提供组织机构服务器（如Web和mail）可访问的主机和IP之间的映射</li>
<li>根DNS服务器：最顶层的DNS服务器，知道所有顶级域服务器的域名</li>
<li>本地DNS服务器：不严格属于层次结构，默认名字服务器，代理作用，比较近</li>
</ol>
<p><strong>主要目的</strong></p>
<ol>
<li>主机名和IP地址的转换</li>
<li>邮件服务器别名到邮件服务器正规名字的转换</li>
</ol>
<h4 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h4><ul>
<li>层次树状结构的命名方法</li>
<li>Internet根被划分为几百个顶级域（Top Level Domain，TLD）<ul>
<li>通用的域：.com .edu .gov .net</li>
<li>国家的域：.cn .us </li>
</ul>
</li>
<li>每个域下面都可划分为若干子域（subdomains）</li>
<li>叶子节点是主机</li>
</ul>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><ul>
<li><p>域名结构</p>
<ul>
<li><p>从本域相似，直到树根，中间用.间隔不同的级别</p>
<p>ustc.edu.cn</p>
</li>
<li><p>域的域名：用来表示一个域</p>
</li>
<li><p>主机的域名：表示域内的一个主机</p>
</li>
</ul>
</li>
<li><p>域名管理</p>
<ul>
<li><p>一个域管理其下所有域</p>
<p>.cn 被划分为 edu.cn gov.cn</p>
</li>
<li><p>创建域需要征得父域的同意</p>
</li>
<li><p>域与物理网络无关，逻辑划分</p>
<p>域内主机可以不在一个网络，一个网络内的主机可以不在一个域</p>
</li>
</ul>
</li>
</ul>
<h4 id="解析服务"><a href="#解析服务" class="headerlink" title="解析服务"></a>解析服务</h4><p>将命名空间划分为互不相交的区域，每个区域都是树的一部分，每个区域都有自己的名字服务器，维护辖区内的权威信息（authoritative record），名字服务器允许放置于区域外，以保障可靠性</p>
<p><img src="/posts/63069/image-20230525153041281.png" alt="image-20230525153041281"></p>
<p><strong>资源记录</strong></p>
<p>Resource Records</p>
<ul>
<li><p>维护 域名-IP地址的映射关系，位于名字服务器的分布式数据库中</p>
<p><strong>格式</strong>：（domain_name，ttl，type，class，value）</p>
<ol>
<li><p>domain_name：域名</p>
</li>
<li><p>ttl：time to live生存时间，决定资源记录从缓存中删除的时间，权威的生存时间无限长，缓冲记录则存在有效期</p>
</li>
<li><p>class：类</p>
</li>
<li><p>type：类型，资源记录是什么类型，区分这个映射关系的作用</p>
<ol>
<li><p>A：主机-&gt;IP地址</p>
</li>
<li><p>CNAME：别名-&gt;正规名称</p>
<p>www.ibm.com的规范名称为servereast.backup2.ibm.com</p>
</li>
<li><p>NS：域名-&gt;这个域的权威服务器的域名</p>
</li>
<li><p>MX：名称-&gt;邮件服务器的名字</p>
</li>
</ol>
</li>
<li><p>value：值，IP地址、域名、等等</p>
</li>
</ol>
</li>
</ul>
<p><strong>工作过程</strong></p>
<ol>
<li><p>应用调用解析器（resolver）</p>
</li>
<li><p>解析器作为客户 向Name Server发出查询报文，封装到UDP数据报中</p>
</li>
<li><p>Name Server进行<strong>名字解析</strong>，然后返回响应报文</p>
<ol>
<li><p>目标名字在本地名字服务器中，直接返回</p>
<ol>
<li><p>查询的名字就在区域内部</p>
</li>
<li><p>有缓存</p>
<p>提高性能，根服务器通常都在本地服务器有缓存，使根服务器不需要经常被访问，不一致问题通过TTL来解决</p>
</li>
</ol>
</li>
<li><p>不在本地名字服务器中，联系根名字服务器，要找到权威名字服务器</p>
<ol>
<li><p>递归查询</p>
<p><img src="/posts/63069/image-20230525154526854.png" alt="image-20230525154526854"></p>
<p>根服务器需要接收查询请求2，亲自去查3 6，后续还得把结果返回7</p>
</li>
<li><p>迭代查询</p>
<p><img src="/posts/63069/image-20230525154448235.png" alt="image-20230525154448235"></p>
<p>根服务器只需要告知，你去哪里可能可以查到这个域名，只需要2 3操作</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>本地名字服务器</strong></p>
<p>每个ISP都有一个本地DNS服务器，或者叫默认名字服务器，代理作用，距离比较近，查询比较方便</p>
<p><strong>域名维护</strong></p>
<p>如何新增一个域？</p>
<p>需要在上级域的名字服务器中新增两项内容</p>
<ol>
<li>新增的子域的域名=&gt;子域能在哪个名字服务器找到，名字服务器的名字</li>
<li>名字服务器=&gt;服务器IP地址</li>
</ol>
<blockquote>
<p>比如新增networkutopia.com，对应的权威DNS服务器是dns1.networkutopia.com，IP地址是212.212.212.1</p>
<ol>
<li>(networkutopia.com, dns1.networkutopia.com）</li>
<li>(dns1.networkutopia.com, 212.212.212.1)</li>
</ol>
<p>在dns1.networkutopia.com必须保存有一个类型A和MX的记录</p>
<ol>
<li>Web服务</li>
<li>邮件服务</li>
</ol>
</blockquote>
<h3 id="对等应用"><a href="#对等应用" class="headerlink" title="对等应用"></a>对等应用</h3><h4 id="纯P2P架构"><a href="#纯P2P架构" class="headerlink" title="纯P2P架构"></a><strong><a href="# 对等模式">纯P2P架构</a></strong></h4><p>相较于C/S架构，P2P在文件传输上存在天然优势</p>
<p>C/S架构的传输耗时随着客户端增加而线性增加，P2P随着客户端增加缓慢增加（客户端在带来下载需求时，也提供了服务能力）</p>
<p>tracker：跟踪torrent中的参与节点，某个文件有哪些客户在上传和下载，peer可以同时向拥有该文件的peer进行下载（文件被划分为多个块，向不同的peer申请不同的块，并发下载）</p>
<p>torrent：节点的组，组内节点间互相交换文件块</p>
<p>churn：扰动，peer节点可能会上线、下线</p>
<h4 id="传输原则"><a href="#传输原则" class="headerlink" title="传输原则"></a>传输原则</h4><p>并非先来先到，而是tit-for-tat，一报还一报，谁对我好，我就对谁好，自己提供的带宽越大，别人也愿意提供服务</p>
<h3 id="多媒体服务"><a href="#多媒体服务" class="headerlink" title="多媒体服务"></a>多媒体服务</h3><h4 id="多媒体流化技术"><a href="#多媒体流化技术" class="headerlink" title="多媒体流化技术"></a>多媒体流化技术</h4><p>Dynamic, Adaptive Streaming over HTTP  </p>
<p>服务器：</p>
<ul>
<li>将视频文件分割成多个块，比如8-10s一块</li>
<li>每个块独立存储，编码于不同码率，解析度，或者说清晰度</li>
<li>告示文件（manifest file）：提供不同块的URL，存储在哪里，从哪里可以获取这个视频</li>
</ul>
<p>客户端：</p>
<ul>
<li>先获取告示文件</li>
<li>周期性测量服务器到客户端的带宽</li>
<li>查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围<ul>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽)</li>
</ul>
</li>
<li>动态自适应客户端<ul>
<li><strong>什么时候</strong>去请求块 (不至于缓存挨饿，或者溢出)  </li>
<li>请求<strong>什么编码速率</strong>的视频块 (当带宽够用时，请求高质量的视频块)</li>
<li><strong>去哪里</strong>请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求)</li>
</ul>
</li>
</ul>
<h4 id="内容分布式网络"><a href="#内容分布式网络" class="headerlink" title="内容分布式网络"></a>内容分布式网络</h4><p>Content Distribution Network，CDN</p>
<p>面临规模性（数以亿计的用户）、异构性（不同用户的带宽、延迟不同）的挑战，集中式不可取</p>
<p>通过CDN，全网部署缓存节点，存储服务内容，就近（网络路径拥塞，换一条路）为用户提供服务</p>
<h3 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h3><p>除了系统管理员静态配置IP地址，还有动态配置</p>
<p><strong>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）</strong>：基于UDP的一个服务协议，允许主机从服务器动态获取一个IP地址，并包括子网掩码、本地域名服务器（域名和IP地址）、默认网关（第一跳路由器的IP地址）等。该协议允许主机在加入网络时，动态地从服务器获取IP地址，简化网络管理，提高网络配置的灵活性和可扩展性</p>
<p><strong>互联网名字与编号分配机构（ Internet Corporation for Assigned Names and Numbers，ICANN）</strong>:负责管理Internet的全球域名系统（DNS）和IP地址分配</p>
<blockquote>
<p>假设现在总共有400台主机，IP地址只能支持256个，是否可以不增加IP地址支持400个主机呢？</p>
<p>400个最多的时候也不会有256个同时上网，所以可以动态分配，这台主机不上网了，IP地址就空出来了</p>
</blockquote>
<ol>
<li>更新主机的IP地址，IP地址是有租期的，到期了需要进行更新</li>
<li>主机重启时，允许主机使用以前用过的IP地址</li>
<li>支持移动用户入网（短期在网）</li>
</ol>
<h3 id="其他应用或者协议"><a href="#其他应用或者协议" class="headerlink" title="其他应用或者协议"></a>其他应用或者协议</h3><p><strong>简单文件传输协议（TFTP）</strong>：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</p>
<p><strong>远程终端协议（TELNET）</strong>：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-数据链路层</title>
    <url>/posts/61619.html</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>网络层解决了一个网络到另一个网络的路由问题，那么网络内部如何实现节点（路由器、主机）间的数据传输呢？需要链路层提供点到点传输功能。</p>
<p><strong>链路</strong>：从一个节点到相邻节点的物理线路，中间没有任何其他交换节点</p>
<p><strong>数据链路</strong>：在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现），以帧为单位传输和处理数据</p>
<blockquote>
<p>主机和路由器（包括网桥和交换机）都是节点（nodes），连接相邻节点的通信信道是链路（links），链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
</blockquote>
<p>网络节点的连接方式包括：</p>
<ol>
<li><p>点到点连接：计算机的广域网，距离比较远，寻址不重要，已经是点对点了，传输介质的使用也不会冲突</p>
<p>海底电缆直连</p>
</li>
<li><p>多点连接（共享型介质、通过网络交换机）：局域网内部，存在多点冲突问题（两个节点同时发，大家都要收，怎么收），需要实现多点接入协议（协调各节点对共享性介质的访问和使用），此外如何为硬件节点进行编址，如何寻址也需要解决</p>
<p>通过同轴电缆、网络交换机连接多个节点</p>
</li>
</ol>
<p><strong>广域网如果采用多点连接方式</strong></p>
<ol>
<li><p>物理布局很麻烦</p>
</li>
<li><p>带宽需求大、延迟大→链路容量大，冲突发生时很难处理</p>
<blockquote>
<p>比如A B C D这四个节点依次连接到同轴电缆</p>
<p>A发送数据 花了很长时间</p>
<p>B侦听 A的数据没到达 以为没人发数据 自己也发了 </p>
<p>就造成了冲突 A发的数据都无效了</p>
</blockquote>
</li>
<li><p>用令牌的形式协调冲突，通信代价大</p>
</li>
</ol>
<p><strong>局域网如果用点对点连接方式</strong></p>
<p>局域网内任意节点之间都要连接，开销太大</p>
<p>数据链路层的数据单元叫做帧，将网络层获取的数据包封装成帧（frame）</p>
<p>数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点（一个子网内部的2节点），一跳</p>
<p>数据报（分组）在不同链路上以不同的链路协议进行传送，不同的链路协议提供不同的服务</p>
<ol>
<li>第一跳链路：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳：802.11</li>
</ol>
<p>网卡（适配器）实现链路层功能：</p>
<ol>
<li>发送方：<ol>
<li>在帧中封装数据报：帧头、帧尾</li>
<li>加上差错控制编码，实现可靠数据传输和流量控制功能等</li>
</ol>
</li>
<li>接收方：<ol>
<li>检查有无出错，执行可靠数据传输和流量控制功能等</li>
<li>解封装数据报，将至交给上层</li>
</ol>
</li>
</ol>
<h3 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h3><p>封装成帧、差错检测和可靠传输</p>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>将数据报封装在帧中，加上帧头、帧尾部，作用之一就是帧定界（不是所有数据链路层的协议都有帧定界标</p>
<blockquote>
<p>物理层添加8字节的前导码（帧头前面），其中前7个字节为同步码，用于接收双方的时钟同步，剩余一个字节表示帧开始的位置，其后紧跟MAC地址，此外，以太网帧还规定了96比特的帧间间隔，因此也不需要帧结束标志</p>
</blockquote>
<p>帧头包含了定位所需的物理地址信息（Media Access Control Address, MAC)，帧尾包含数据的校验和</p>
<p><strong>透明传输</strong>：指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样，数据链路层需要实现的功能</p>
<ul>
<li><p>面向字节的物理链路使用字节填充（或称字符填充，填充转义字符ESC 1个字节）的方法实现透明传输。</p>
</li>
<li><p>面向比特的物理链路使用比特填充的方法实现透明传输。</p>
</li>
</ul>
<blockquote>
<p>帧的数据部分，发送方碰到连续5个1补充1个0，接收方碰到连续5个1删除那个0</p>
</blockquote>
<p><strong>最大传输单元（Maximum Transmission Unit，MTU）</strong>:表示数据链路层的一个帧所能携带的最大数据长度，因此对于大的数据报，一个MTU存不下，就需要分片</p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p><strong>比特差错</strong>：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。这称为。<br><strong>误码率（Bit Error Rate，BER）</strong>：在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率。</p>
<p><strong>差错检验码</strong>；帧尾包含数据的校验和，差错校验码，用于差错检验</p>
<p><strong>错误检测</strong>：接收方检测出的错误，通知发送端进行重传或丢弃帧  </p>
<p><strong>差错纠正</strong>：接收端检查和纠正bit错误，不通过重传来纠正错误</p>
<p><strong>帧校验序列（Frame Check Sequence, FCS）字段</strong>：数据帧（Data Frame）中用来验证数据完整性和正确性的字段。FCS Field通常采用CRC计算出的校验和作为值，将该值附加到数据帧的末尾。</p>
<p>没有通过校验：肯定出错</p>
<p>通过检验：不一定没有出错，这种没有检测出来的错误叫做残存错误</p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。</p>
<p>单bit奇偶检验：检测单个bit级别错误，无法纠正偶数项错误</p>
<p><img src="/posts/61619/image-20230531154806604.png" alt="image-20230531154806604"></p>
<p>二维奇偶校验：检测和纠正单个bit错误</p>
<p><img src="/posts/61619/image-20230531154857997.png" alt="image-20230531154857997"></p>
<p>但是比如</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1</th>
<th>0</th>
<th>变为</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody>
</table>
</div>
<p>无法检验错误</p>
<h4 id="Internet校验和"><a href="#Internet校验和" class="headerlink" title="Internet校验和"></a>Internet校验和</h4><p>检测在传输报文段时的错误（如位翻转），（注：仅仅用在传输层）</p>
<p><img src="/posts/61619/image-20230531155442327.png" alt="image-20230531155442327"></p>
<h4 id="CRC循环冗余检验码"><a href="#CRC循环冗余检验码" class="headerlink" title="CRC循环冗余检验码"></a>CRC循环冗余检验码</h4><p>Cyclic Redundancy Check</p>
<ol>
<li><p>模2运算⊕</p>
<p>位与位之间独立，加法不进位，减法不借位，就是异或运算，相同为0，不同为1</p>
<p>1 0 1 1 0</p>
<p>0 1 0 1 0</p>
<hr>
<p>1 1 1 0 0</p>
</li>
<li><p>比特序列的两种表示</p>
<ol>
<li>1 0 1 1</li>
<li>$x^3+0·x^2+x^1+x^0=x^3+x^2+1$</li>
</ol>
</li>
<li><p>生成多项式G：r次方的一个多项式，总共r+1位</p>
<p>发送、接收双方<strong>约定</strong>的一个序列</p>
<p>例如，1001，$x^3+1$，4位，3次方的多项式</p>
</li>
<li><p>性能分析</p>
<ol>
<li>1bit的错误都能检测</li>
<li>双bit错误都能检测</li>
<li>长度&lt;=r的错误都能检测</li>
<li>长度=r+1的突发错误，检测不出的概率为$\frac{1}{2^{r-1}}$</li>
<li>长度&gt;r+1的突发错误，检测不出的概率为$\frac{1}{2^r}$</li>
</ol>
</li>
<li><p>广泛应用于以太网、802.11WiFi、ATM</p>
</li>
</ol>
<p>生成多项式：$x^4+x^2+x+1&lt;=&gt;10111$，就是除法用到的除数</p>
<p>如下是常用的生成多项式：必须包含最低次项</p>
<p><img src="/posts/61619/image-20230531162619239.png" alt="image-20230531162619239"></p>
<p><strong>数据为101001，生成多项式是x\^3+x^2+1&lt;=&gt;1101，计算余数</strong></p>
<p>101001|000=&gt;101001 000</p>
<p>101001 000/1101</p>
<p><img src="/posts/61619/image-20230531163021643.png" alt="image-20230531163021643"></p>
<p><strong>接收到信息为101101001，多项式为x\^3+x^2+1，是否出现错误?</strong></p>
<p><img src="/posts/61619/image-20230531163740992.png" alt="image-20230531163740992"></p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>Reliable Data Transfer，RDT</p>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务一个特定的链路层只是提供其中一部分的服务，取决于为上层提供什么样的服务</p>
<ul>
<li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做</li>
<li>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。</li>
</ul>
<blockquote>
<p>以太网的链路层不提供可靠数据传输</p>
<p>WLAN这种无线局域网提供可靠数据传输</p>
</blockquote>
<ol>
<li><p>本身比较可靠的链路，不需要实现可靠传输</p>
<p>出错率低，没有必要在每一个帧中做差错控制的工作，协议复杂  </p>
<ul>
<li>发送端对每一帧进行差错控制编码，根据反馈做相应的动作</li>
<li>接收端进行差错控制解码，反馈给发送端（ACK，NAK）  </li>
</ul>
</li>
<li><p>数据链路层放弃可靠传输，在网络层和传输层实现可靠控制，或者完全不做可靠控制</p>
</li>
<li><p>在高差错链路上需要进行可靠的数据传输，但是为什么还要在传输层做端到端的可靠性控制</p>
<p>出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</p>
</li>
</ol>
<blockquote>
<p>如果链路层不做差错控制，分组的帧可能被丢弃，目标主机没收到，只能源主机重传，代价太大</p>
</blockquote>
<p>一般情况下，<strong>有线链路</strong>的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。<br><strong>无线链路</strong>易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</p>
<p>实际上传输出错，还要考虑分组丢失、分组失序、分组重复等问题，这些问题通常不在数据链路层出现，因此也会把可靠数据传输弄到上层去</p>
<p>实现可靠数据传输的三种协议包括停止等待、回退N步以及选择重传，这几种协议的基本原理在整个计算机网络体系结构是通用的</p>
<h4 id="粗粒度"><a href="#粗粒度" class="headerlink" title="粗粒度"></a>粗粒度</h4><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><p>Stop-and-Wait</p>
<h6 id="确认与否认"><a href="#确认与否认" class="headerlink" title="确认与否认"></a>确认与否认</h6><p>接收到返回确认，数据包发生错误或者乱序接收，返回否认</p>
<p><strong>新的问题：如果DATA丢失了，接收方没收到不会返回任何信息，发送方没有收到ACK不会发送下一条数据，死锁</strong></p>
<h6 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h6><p>为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间<br>而发送方仍收不到接收方的任何ACK或NAK,则重传原来的数据分组，这就叫做超时重传。</p>
<p>一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”（数据链路层，相邻节点之间的往返时间比较好确定，但是传输层的往返时间不固定，比较难以确定）</p>
<p><strong>新的问题：接收方实际上收到了数据，返回ACK，但是ACK丢失了，发送方没有收到，出发超时重传，就会出现重复分组</strong></p>
<h6 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h6><p>为解决该问题，为每个分组引入序号，碰到相同序号的分组，就丢弃，由于停止等待协议是发一个收一个再发，因此只需要0 1即可表示序号，1个比特位足以，接收方用一个比特位表示期待收到的序号，如果不匹配就丢弃</p>
<p><strong>新的问题：发送方接收到ACK到底是哪个分组的ACK</strong></p>
<p>DATA0延误了，再次发送DATA0，接收方收到第一个DATA0，返回ACK，又收到第二个DATA0，丢弃，为了防止再次重传，需要再次返回ACK，发送方在超时重传之后，接收到第一个ACK，发送DATA1，这个时候又收到了ACK，无法区分这个ACK是DATA0还是DATA1的</p>
<p>返回的ACK信号也需要序号</p>
<p>实际上，数据链路层其实不会出现分组迟到的情况（链路点对点，往返时间相对固定），因此不需要对ACK编号，传输层不行</p>
<h5 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a><a href="# 流水线">GBN</a></h5><p>发送窗口的大小不是随意设置的，构成序号的比特数量为n，则$1&lt;W_T&lt;=2^n-1$</p>
<p>比如分组序号是0-7(3个比特位)，那么窗口大小应该1&lt;W&lt;=2^3-1，否则会出现分组重复问题</p>
<blockquote>
<p>窗口设为8</p>
<p>发送方发送0 1 2 3 4 5 6 7（old） 接收方接收后返回ACK（丢失了或者延误），触发超时重传</p>
<p>此时，接收方期待0 1 2 3 4 5 6 7（new）</p>
<p>发送方重传0 1 2 3 4 5 6 7（new），0与0匹配，发生了重复</p>
<p>窗口设为7</p>
<p>0 1 2 3 4 5 6 接收方接收后返回ACK（丢失了或者延误）触发超时重传</p>
<p>此时，接收方期待7 0 1 2 3 4 5 6</p>
<p>发送方重传 0 1 2 3 4 5 6，0和7不匹配，不会出现分组重复问题</p>
</blockquote>
<p>通信线路质量不好时，分组出错重传代价太大，信道利用率不一定优于停止等待协议</p>
<h5 id="SR"><a href="#SR" class="headerlink" title="SR"></a><a href="# 流水线">SR</a></h5><p>发送、接收窗口的大小不是随意设置的，构成序号的比特数量为n，则$1&lt;W_T=W_R&lt;=2^{n-1}$</p>
<p>比如分组序号是0-7(3个比特位)，那么窗口大小应该1&lt;W&lt;=2^2=4，否则会出现分组重复问题</p>
<p>其实就是窗口分成两段，前后不能交集</p>
<blockquote>
<p>窗口设为5</p>
<p>发送方发送0 1 2 3 4（old） 接收方接收后返回ACK（0的丢失了或者延误），触发超时重传</p>
<p>此时，接收方期待5 6 7 0 1（new）</p>
<p>发送方重传0，0与0匹配，发生了重复</p>
<p>窗口设为4</p>
<p>0 1 2 3接收方接收后返回ACK（0的丢失了或者延误）触发超时重传</p>
<p>此时，接收方期待4 5 6 7</p>
<p>发送方重传0，均不匹配，不会出现分组重复问题</p>
</blockquote>
<p><img src="/posts/61619/image-20221214183009928.png" alt="image-20221214183009928"></p>
<h4 id="细粒度"><a href="#细粒度" class="headerlink" title="细粒度"></a>细粒度</h4><h5 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h5><p>可靠信道，没有比特错误，没有分组丢失，不需要额外机制实现可靠数据传输</p>
<p><strong>问题</strong>：过于理想</p>
<h5 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h5><p>信道是不可靠的</p>
<p><strong>问题</strong>：会发生bit错误</p>
<p><strong>解决思路</strong>：如何发现错误？如何修正错误？</p>
<ol>
<li><p>发现错误</p>
<p><strong>校验和</strong>来检测bit级的错误</p>
</li>
<li><p>告知错误</p>
<p>接收方用<strong>ACK 和NAK</strong>信号显式告知发送方，数据的发生状况，成功或者失败</p>
</li>
<li><p>修正错误</p>
<p>发送方缓存已发送的数据，当接收到NAK后，<strong>重发</strong>数据</p>
</li>
</ol>
<h5 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h5><p>解决rdt2.0的致命缺陷</p>
<p><strong>问题</strong>：如果ACK和NAK出错怎么办？发送方完全不知道接收方发生了啥</p>
<p><strong>解决思路</strong>：首先需要能够检测出ACK和NAK的错误，其次检测到错误了，不重发导致死锁，重发可能内容重复</p>
<ol>
<li><p>重发是肯定要重发的，需要引入序号来避免重复，相同序号的内容抛弃掉</p>
<blockquote>
<p>停止等待协议中，因为是发一个接收一个，所以只需要0和1，发送端给数据编号，接收端比较接收到的数据是不是想要的数据来判断是否要抛弃掉</p>
</blockquote>
</li>
</ol>
<p>此外，接收方实际上是不知道自己的ACK和NAK有没有被正确返回给发送方的，但是可以通过发送方的下一步动作来判断</p>
<ol>
<li>接收方返回ACK<ol>
<li>发送方重发，ACK出错</li>
<li>发送方发送下一个分组，ACK无误</li>
</ol>
</li>
<li>接收方返回NAK<ol>
<li>发送方重发，NAK出错、无误</li>
</ol>
</li>
</ol>
<h5 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h5><p>简化控制信息</p>
<p><strong>问题</strong>：ACK和NAK作为控制信息，在逻辑上需要两个，true or false，但是在实现上，是否可以简化</p>
<p><strong>解决思路</strong>：接收方既然可以通过发送方的下一步动作隐式判断发送方接收控制信息成功与否，那么接收方其实也可以通过带序号的ACK信息来表达自己接收分组成功与否。实际上，发送方只有明确知道接收方接收到上一个数据，才会发下一个数据</p>
<blockquote>
<p>比如发送方发了0的分组</p>
<ol>
<li>接收方接收到了，返回0的确认，告诉发送方，我收到0的数据了，发送方就能发送1了</li>
</ol>
<p>继续发1的分组</p>
<ol>
<li>接收方没接到或者出错，再次返回0的确认，告诉发送方，我收到0的数据了，但是需要1的数据，发送方需要重发1</li>
</ol>
<p>重发1的分组</p>
<ol>
<li>接收方接收到了，返回1的确认，告诉发送方，我收到1的数据了，发送方就能发送2了</li>
</ol>
<p><img src="/posts/61619/image-20230526152410596.png" alt="image-20230526152410596"></p>
</blockquote>
<h5 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h5><p><strong>分组丢失的新危机</strong></p>
<p><strong>问题</strong>：如果分组丢失了，怎么办？比如数据丢失了，接收方没收到，也不会返回确认信息，发送方也不会发送下一个数据，死锁；或者数据收到了，但是确认信息丢了，还是死锁</p>
<p><strong>解决思路</strong>：超时重传或者叫自动重传请求（Automatic Repeat Request，ARQ），在发送方设置一个时钟，超时都没有收到确认信息就重传最后一次发送的分组；</p>
<blockquote>
<p><strong>超时的时间</strong></p>
<ul>
<li>在传输层是动态变化的，因为在传输层，有很多中转节点，往返延迟检测改变</li>
<li>在数据链路层，一般是固定的，因为数据链路层就是转发给相邻的节点，往返延迟变化不大</li>
</ul>
<p><strong>过早超时</strong></p>
<ul>
<li>能工作，但是经常出发重传，信道中存在很多无效数据，接收方也需要进行去重</li>
</ul>
</blockquote>
<p><strong>停止等待协议</strong>：发一个，收一个，返回一个，确认一个，再发一个</p>
<h5 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h5><p>优化效率，信道利用率</p>
<p><strong>问题</strong>：停止等待太慢了，每次发一个都要等待正确接收才能发下一个，每一个分组的发送都得要一次往返时间RTT</p>
<p><strong>解决思路</strong>：流水线，发送方设置发送缓冲区，缓冲区内的未发送的分组可以依次打出去，打出去而没有接收到确认的分组放置在滑动窗口（发送窗口）内，便于重传</p>
<ol>
<li>需要增加序号的范围，0  1肯定是不够的</li>
<li>发送方设置缓冲区，便于重传</li>
<li>接收方也得设置缓冲区，上层取数据的速率和接收速率不匹配，并且还需要保存有序性，也就是收到乱序的不能直接交付，需要放到缓冲区内，进行重排，将完整的数据递交给上层</li>
</ol>
<p><strong>通用流水线协议</strong></p>
<p><strong>发送端：滑动窗口协议实现依次发送多个分组</strong></p>
<ul>
<li><p><strong>发送缓冲区</strong></p>
<p>内存中的一块区域，在缓冲区内的分组可以发送，便于重传</p>
<p>缓冲区的大小决定了在没有得到确认信息前一次性最多可以发送多少个分组</p>
<p>在停止等待协议中缓冲区大小为1，而在流水线协议中缓冲区大小&gt;1</p>
<p>缓冲区内有两种分组，未发送的、已发送未确认的，未发送的直接发送，因此可以认为<strong>缓冲区就是用来存放已经发送但是没有得到确认的分组</strong>，一旦确认就可以删除了，<strong>缓冲区也就可以前移（右移）了</strong></p>
</li>
<li><p><strong>发送窗口</strong></p>
<p>缓冲区内部的一个区域，实际上是用后沿和前沿标识已发送但是未确认的分组的边界</p>
<p>发送窗口的大小$\le$发送缓冲区的大小</p>
<p>初始化，后沿=前沿，发送窗口的大小为0，发送缓冲区的大小为5</p>
<p>不断发送，前沿前移，直到达到缓冲区边界</p>
<p>某个分组确认了，后沿前移，直到抵达前沿</p>
<p>实际上发送缓冲区也会前移（右移），然后新的分组落入发送缓冲区，可以发送了，前沿前移</p>
<blockquote>
<p>发送缓冲区大小为5</p>
<p>依次发送 0 1 2 3 4，前沿到了4，后沿还是0</p>
<p>接到0 1的确认，后沿前移到2，发送缓冲区前移到6，新的分组5 6可以发送</p>
<p>发送之后前沿到了6</p>
<p><img src="/posts/61619/image-20230526155129089.png" alt="image-20230526155129089"></p>
</blockquote>
</li>
<li><p><strong>接收窗口=接收缓冲区</strong></p>
<p>用于控制哪些分组可以接收，只有序号在接收窗口范围内的分组可以接收，其余分组丢弃</p>
<p>接收窗口大小</p>
<ul>
<li>GBN=1，只允许顺序接收，累积确认（cumulative ack，当前分组和之前分组都收到，因此返回ACK1 2 3 4即便1 2 3丢失，4到达也是OK的）</li>
<li>SR>1，允许乱序接收（缓存而不交付），非累积确认（individual ack，只能表示当前分组收到），但是需要进行重排，保证有序后才能递交给上层</li>
</ul>
<p>接收动作</p>
<ul>
<li>最低序号的分组到来，接收，右移</li>
<li>非最低序号的分组到来，接收、缓存、不交付，无法右移</li>
</ul>
</li>
<li><p><strong>异常处理</strong></p>
<ul>
<li><p>回退N步（Go Back N，GBN）</p>
<p>接收方接到非最低序号的分组，丢弃，导致出错时重传代价大</p>
<p>发送方接收到错误的ACK，或者触发超时重传机制，需要将发送窗口内的所有分组都发送出去（因为发送方收到了老分组x的确认，接收方的窗口大小只有1，说明x+1都没收到，即便x+2收到也会被丢弃，因此需要全部重发）</p>
<p>只需为最老未确认的分组设置定时器，超时全部重发</p>
</li>
<li><p>选择重传（Selective Repeat，SR）</p>
<p>接收方接到较高序号的分组，缓存，接收窗口不右移</p>
<p>发送方接收到错误的ACK，或者触发超时重传机制，只需要将出错的分组重传即可</p>
<p>为每一个已发送未确认的分组设置定时器，超时对应重发</p>
</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>回退N步</th>
<th>选择重传</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送窗口大小</td>
<td>&gt;1</td>
<td>&gt;1</td>
</tr>
<tr>
<td>接收窗口大小</td>
<td>=1</td>
<td>&gt;1</td>
</tr>
<tr>
<td>重传机制</td>
<td>窗口内全部重传，比如已经发送0 1 2 3 4，0成功，1没有成功，需要重发1 2 3 4</td>
<td>只需重传失败分组，比如已经发送0 1 2 3 4，发现3失败了，只需重发3</td>
</tr>
<tr>
<td>接收机制</td>
<td>必须顺序接收，高序号的丢弃</td>
<td>允许乱序接收</td>
</tr>
<tr>
<td>定时器</td>
<td>最老未确认分组的定时器</td>
<td>每一个已发送未确认分组的定时器</td>
</tr>
<tr>
<td>优势</td>
<td>实现简单，所需资源比较少</td>
<td>出错的重传代价小</td>
</tr>
<tr>
<td>劣势</td>
<td>出错重传代价大</td>
<td>复杂，所需资源比较多</td>
</tr>
<tr>
<td>应用场景</td>
<td>出错率比较低的应用</td>
<td>链路容量大=&gt;发送缓冲区大，出错代价非常大，需要用SR</td>
</tr>
</tbody>
</table>
</div>
<h3 id="点对点协议"><a href="#点对点协议" class="headerlink" title="点对点协议"></a>点对点协议</h3><p><strong>Point to Point Protocol，PPP</strong>：目前使用最广泛的数据链路层协议，比如因特网</p>
<h4 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h4><ol>
<li>对各种协议数据报的封装方法（封装成帧）</li>
<li>链路控制协议LCP：用于建立、配置和测试数据链路的连接</li>
<li>一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议</li>
</ol>
<h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><p><img src="/posts/61619/image-20230602132437548.png" alt="image-20230602132437548"></p>
<blockquote>
<p>MAC是数据链路层广播信道特有的，而且一般使用总线网拓扑，简言之就相当于是一个局域网范围内的主机通信，需要共享各自的软硬件资源，所以需要mac地址。ppp协议是点对点信道，基本只有通讯功能，不需要获取MAC，点对点通信是基于IP而不是MAC通讯的 。</p>
</blockquote>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p><img src="/posts/61619/image-20230602132537204.png" alt="image-20230602132537204"></p>
<p>发送方：正变换</p>
<ol>
<li>将<strong>7D</strong>插入到定界符7E前面，（<strong>01111101</strong>,01111110）=&gt;<strong>01111101</strong>01011110</li>
<li>将<strong>7D</strong>插入到转义字符7D前面，（<strong>01111101</strong>,01111101）=&gt;<strong>01111101</strong> 01111101</li>
<li>ASCII控制字符，数值小于0x20的字符</li>
</ol>
<p>接收方：反变换</p>
<p>比如发送方发现5个连续的1，就填充一个0；接收方发现5个连续的1，就把后面紧跟着的0删掉</p>
<h4 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h4><p>FCS字段填充循环冗余校验码</p>
<h4 id="可靠数据传输-1"><a href="#可靠数据传输-1" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>没有</p>
<h3 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h3><p>单个共享的广播型链路</p>
<p>冲突（collision）：2个或者更多站点同时传送，多个信号叠加，不可取</p>
<p>Medium Access Control，MAC：分布式协调各个节点对共享介质的使用，决定节点什么时候可以发送，同时控制信息也需要利用这个共享信道进行传输（没有带外信道）</p>
<p>协议能够实现的理想情况：</p>
<ol>
<li>一个节点发送，以最高速率R发送</li>
<li>M个节点发送，每个节点能够以R/M的平均速率发送</li>
<li>完全分布的，没有特殊节点协调，没有时钟和时隙的同步</li>
<li>实现需要简单</li>
</ol>
<h4 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h4><p>预先固定分配好信道，不灵活，对于突发性数据传输，信道利用率比较低</p>
<p>通常在物理层中使用，而不是在数据链路层中使用</p>
<p>信道复用：通过一条物理线路同时传输多路用户的信号</p>
<h4 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h4><h5 id="受控接入"><a href="#受控接入" class="headerlink" title="受控接入"></a>受控接入</h5><p>已经退出历史舞台</p>
<h6 id="集中控制"><a href="#集中控制" class="headerlink" title="集中控制"></a>集中控制</h6><p>有一个主站以循环方式轮询每个站点有无数据要发送，只有被轮询到的站点才能发送数据，存在单点故障问题</p>
<h6 id="分散控制"><a href="#分散控制" class="headerlink" title="分散控制"></a>分散控制</h6><p>各站点是平等的，并连接成一个环形网络。令牌（一个特殊的控制帧）沿环逐站传递，接收到令牌的站点才有权发送数据，并在发送完数据后将令牌传递给下一个站点</p>
<h5 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h5><p>所有站点通过竞争，随机地在信道上发送数据。如果恰巧有两个或更多的站点在同一时刻发送数据，则信号在共享媒体上就要产生碰撞（即发生了冲突）。使得这些站点的发送都失败。因此，这类协议要解决的关键问题是如何尽量避免冲突及在发生冲突后如何尽使恢复通信。著名的共享式以太网采用的就是随机接入。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-物理层</title>
    <url>/posts/48147.html</url>
    <content><![CDATA[<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>物理层：实现在连接各种计算机的传输媒体上传输比特流，为数据链路层屏蔽各自传输媒体的差异，使数据链路层只需要考虑如何在物理层服务的基础上实现本层的功能，需要考虑的是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</p>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><ol>
<li>串行传输：数据一个比特一个比特依次发送（只需要一条线路，计算机网络中普遍使用）</li>
<li>并行传输：一次发送n个比特（n条线路，计算机内部CPU和内存通过总线，总线就是并行传输的）</li>
</ol>
<hr>
<ol>
<li>同步传输：数据块以稳定比特流的形式传输，字节之间没有间隔</li>
<li>异步传输：以字节为独立传输单位，字节之间的时间间隔非固定，通常需要添加起始位和结束位</li>
</ol>
<hr>
<ol>
<li>单工通信：只允许单向的传输</li>
<li>半双工通信：虽然允许双向传输，但是无法同时进行</li>
<li>全双工通信：任意时刻都允许双向传输</li>
</ol>
<h3 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h3><p><strong>码元（ code）</strong>：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</p>
<p><strong>数字信道</strong>：能传输数字信号的信道。数字信号传输的是不连续的、离散的二进制脉冲信号（对称的方波波形）。在它的整个信号中只有两种状态，高电平与低电平，高电平用逻辑1表示低电平用逻辑0表示。</p>
<p><strong>模拟信道</strong>：能传输模拟信号的信道。模拟信号的电平随时间连续变化，具有周期性的正弦波信。语音信号是典型的模拟信号。模拟信号一般通过PCM脉码调制方法量化为数字信号，即让模拟信号的不同幅度分别对应不同的二进制值。</p>
<p><strong>编码</strong>：在不改变信号性质的前提下，对数字基带信号的波形进行变换（数字信号→数字信号，可以在数字信道中传输）</p>
<p><strong>调制</strong>：数字基带信号的频率范围搬移到较高频段，并转换为模拟信号（数字信号→模拟信号，可以在模拟信道中传输）</p>
<p><strong>消息（message）</strong>：包括文字、图片、音频、视频等信息</p>
<p><strong>数据（data）</strong> :运送消息的实体，一般是二进制。</p>
<p><strong>信号（signal）</strong>：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</p>
<h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</p>
<p><img src="/posts/48147/f939342f543046459ffabdc476f7bca4tplv-k3u1fbpfcp-zoom-1.png" alt="img"></p>
<p>奈氏准则：在假定的理想情况下，为了避免码间串扰，码元传输速率有上限</p>
<blockquote>
<p>只要采用更好的调制方法，让码元可以携带更多的比特，岂不是可以无限制地提高信息的传输速率？</p>
<p>答案是否定的。因为信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。</p>
</blockquote>
<p>香农公式：带宽受限且有高斯白噪音干扰的信道的极限信息传输速率</p>
<ol>
<li>信道带宽或信道中信噪比越大，信息的极限传输速率越高。</li>
<li>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少。这是因为在实际信道中，信号还要受到其他<br>一些损伤，如各种脉冲干扰、信号在传输中的衰减和失真等，这些因素在香农公式中并未考虑。</li>
</ol>
<p>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制（更好的调制方法）和努力提高信道中的信噪比。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-概述</title>
    <url>/posts/57351.html</url>
    <content><![CDATA[<h3 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h3><p><strong>网络</strong>：若干节点（node）和连接这些节点的边（链路，link）构成</p>
<p><strong>互联网</strong>：多个网络通过路由器连接起来，构成一个覆盖范围更大的网络，即互联网，是“网络的网络（Network of Networks）”</p>
<p><strong>因特网</strong>：世界上最大的互联网</p>
<p><strong>internet</strong>：小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</p>
<p><strong>Internet</strong>：大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则。</p>
<p><strong>计算机网络</strong>：一些互连（通过有线或者无线的方式进行数据通信）、自治（计算机拥有自己的硬件和软件，能够独立运行）的计算机的集合（≥2）；计算机网络主要是由一些通用的、可编程的硬件（包括计算机和智能手机）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p>
<p><strong>交换技术分类</strong>：电路交换网络、报文交换网络、分组交换网络</p>
<p><strong>使用者分类</strong>：专用网、公用网</p>
<p><strong>传输介质</strong>：有线网络、无线网络</p>
<p><strong>覆盖范围分类</strong>：广域网、城域网、局域网、个人区域网</p>
<ul>
<li><p><strong>广域网 WAN（Wide Area Network）</strong>：覆盖范围较广的网络，通常跨越城市、省份、甚至国家和地区。在WAN中，多个局域网通过路由器、交换机、调制解调器等设备相互连接，形成一个覆盖范围更广的网络。</p>
</li>
<li><p><strong>城域网 MAN（Metropolitan Area Network）</strong>：覆盖范围介于LAN和WAN之间的网络，通常跨越一个城市或一个城市的一部分。在MAN中，多个LAN通过路由器、交换机等设备相互连接，形成一个覆盖范围较大的网络。</p>
</li>
<li><p><strong>局域网 LAN（Local Area Network）</strong>：在一个相对较小的地理范围内，例如在一个建筑、校园、公司或家庭中建立的网络。</p>
</li>
<li><p><strong>个人区域网 PAN（Personal Area Network)</strong>：覆盖范围最小的网络，通常只包括一个人的设备，例如手机、电脑、平板电脑、蓝牙耳机等设备。</p>
<blockquote>
<p>一个大型跨国公司的网络可以被划分为多个LAN，每个LAN覆盖不同的办公室或部门，这些LAN之间通过WAN连接起来，形成一个覆盖全球的网络。而一个家庭中的网络可以是一个LAN，包括多台电脑、手机、智能电视等设备，这些设备之间通过路由器相互连接。在这个家庭中，每个人可以使用自己的设备，如手机、平板电脑等，形成一个PAN，这些设备之间可以通过Wi-Fi或蓝牙相互连接。如果这个家庭所在的小区内建立了一个公共的网络，那么这个公共网络可以被视为一个MAN，连接多个家庭的LAN，形成一个覆盖整个小区的网络。</p>
</blockquote>
</li>
</ul>
<h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p><strong>节点 （node）</strong></p>
<ol>
<li>主机及其上运行的应用程序</li>
<li>路由器、交换机等网络交换设备</li>
</ol>
</li>
<li><p><strong>边，通信链路（link）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</p>
<ol>
<li>接入网链路：主机连接到互联网的链路</li>
<li>主干链路：路由器间的链路</li>
</ol>
</li>
<li><p><strong>协议</strong>：Internet的所有通信行为都受协议制约</p>
<p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式</strong>和<strong>次序</strong>，以及在报文传输、接收或处理其他事件时所采取的<strong>动作</strong></p>
<blockquote>
<p>协议数据单元（Protocol Data Unit，PDU）</p>
<p>语法:格式 字段 长度</p>
<p>语义:字段的含义</p>
<p>时序:什么时候发，什么条件发</p>
<p>动作:收到请求报文，内部处理的动作</p>
</blockquote>
</li>
</ul>
<p><strong>Internet： 计算机网络（简称网络）把许多计算机连接在一起，而互联网基于TCP/IP协议簇把许多网络连接在一起，是网络的网络，仅仅互联但是不提供内容</strong></p>
<ul>
<li><p><strong>组成角度</strong>：由节点和边构成，基于以TCP/IP协议为主的一簇协议来正常运行的网络，由许多这样的网络构成的互联网络</p>
<p>包括数以亿计的互联设备（主机、网络应用程序）、通信链路（光纤、无线电等）、分组转发设备（路由器：网络层，连接不同的网络，局域网→互联网，通过IP识别不同地址；交换机：局域网内通信，连接多台计算机、服务器等，通过MAC地址识别不同设备）</p>
</li>
<li><p><strong>服务角度</strong>：互联网是分布式的应用进程（Web、email、网络游戏）及为分布式应用进程提供通信服务的基础设施</p>
<ul>
<li>将发送和接收数据的apps与互联网连接起来</li>
<li>为app应用提供服务选择（无连接不可靠服务，面向连接的可靠服务）</li>
</ul>
</li>
<li><p><strong>网络结构角度</strong>：互联网是一个一个子系统</p>
<ul>
<li>网络边缘（主机、网络应用：客户端和服务器）</li>
<li>网络核心（互联的路由器、网络的网络）</li>
<li>接入网、物理媒体（有线或者无线的通信链路）</li>
</ul>
</li>
</ul>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><ol>
<li><p>网络边缘：进行信息处理，用户直接使用的，用于通信、共享资源</p>
<p>主机、应用程序</p>
</li>
<li><p>网络核心：提供连通性和交换，由大量网络和连接这些网络的路由器构成，为边缘部分提供服务</p>
<p>互相连接的路由器、网络的网络</p>
</li>
<li><p>接入网、物理媒体：辅助网络核心提供连通性</p>
<p>有线、无线通信链路</p>
</li>
</ol>
<h4 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h4><p>端系统（主机）：运行应用程序，比如Web、email，在网络的边缘</p>
<p>计算机通信是计算机中进程（即运行着的程序）之间的通信</p>
<p>两种连接模式</p>
<ol>
<li><p>客户/服务器（C/S）模式</p>
<ul>
<li><p>客户端向服务器请求、接收服务 ，比如Web浏览器和服务器，email客户端和服务器</p>
</li>
<li><p>主从模式，主是服务器（所有资源都在服务器），从是客户端（资源需要从服务器那里请求）</p>
</li>
<li>缺陷在于 可扩展性差，随着请求载荷的增加，能力下降，但是是断崖式下降</li>
</ul>
</li>
<li><p>对等（Peer to Peer，P2P）模式</p>
<p>没有专门的服务器</p>
<ul>
<li>迅雷下载文件为例，我是一个迅雷的客户端，存储了某些资源，现在有远程的客户端对这些资源发出请求，那我其实也可是他的服务端，我同时也能够向另外一个迅雷客户端请求某个文件，此时我又是客户端</li>
<li>既是客户端又是服务器，随着用户数量增多，客户端变多，但是作为资源提供的服务器也会变多，可扩展性好</li>
</ul>
</li>
</ol>
<h4 id="网络边缘服务"><a href="#网络边缘服务" class="headerlink" title="网络边缘服务"></a>网络边缘服务</h4><h5 id="面向连接的服务（TCP）"><a href="#面向连接的服务（TCP）" class="headerlink" title="面向连接的服务（TCP）"></a>面向连接的服务（TCP）</h5><p>在端系统之间传输数据</p>
<p>握手：在数据传输之前做好准备，两个通信主机之间为连接建立状态</p>
<p><strong>传输控制协议（Transmission Control Protocol，TCP）：TCP报文</strong></p>
<ol>
<li><p><strong>可靠地、保序地传输数据</strong></p>
<p>确认和重传机制</p>
</li>
<li><p><strong>流量控制</strong></p>
<p>发送方不会淹没接收方</p>
</li>
<li><p><strong>拥塞控制</strong></p>
<p>网络拥塞时，发送方降低发送速率</p>
</li>
</ol>
<p>应用：HTTP（Web服务）、文件传输协议（File Transmission Protocol，FTP）、email服务（Simple Mail Transfer Protocol，SMTP）等<strong>对传输可靠性要求较高的应用</strong></p>
<p><strong>面向连接：通信的状态只有在端系统中维护，而中间节点不知道</strong></p>
<p><strong>有连接：中间节点也需要维护通信状态</strong></p>
<h5 id="无连接服务（UDP）"><a href="#无连接服务（UDP）" class="headerlink" title="无连接服务（UDP）"></a>无连接服务（UDP）</h5><p>在端系统之间传输数据</p>
<p><strong>用户数据报协议（User Datagram Protocol，UDP）：UDP用户数据报</strong></p>
<ol>
<li><strong>无连接</strong></li>
<li><strong>不可靠数据传输</strong></li>
<li><strong>无流量控制</strong></li>
<li><strong>无拥塞控制</strong></li>
</ol>
<p>应用：流媒体、远程会议之类<strong>对传输可靠性要求不高，但是对传输延迟要求较高的应用</strong></p>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>路由器的网状网络</p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>路由器是实现分组交换的关键构件，其任务是路由和转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据段的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p>
<h4 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h4><p>交换指的是按照某种方式动态分配传输线路的资源</p>
<h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><p>电话交换机接通电话线的方式，实际实现不是两两连接，而是通过连接到电话交换机上来实现</p>
<p>端到端的资源被分配给从源端到目标端的呼叫 “call”：  通过信令系统分配给源和目标的通讯分配一条独享线路（piece，两个路由器之间的链路通过各种方法划分为线路，即piece）</p>
<p>工作过程</p>
<ol>
<li>建立连接（分配通信资源）</li>
<li>通话（一直占用通信资源）</li>
<li>释放连接（归还通信资源）</li>
</ol>
<p><strong>特点</strong></p>
<ol>
<li>独享资源（线路），不同享，每个呼叫一旦建立起来就能够保证性能</li>
</ol>
<ul>
<li>为呼叫预留 端-端资源<ul>
<li>链路带宽、交换能力</li>
</ul>
</li>
<li>专用资源：不共享<ul>
<li>性能可以保证</li>
</ul>
</li>
<li>需要建立呼叫连接</li>
</ul>
<ol>
<li>如果呼叫没有数据发送，被分配的资源就会被浪费</li>
</ol>
<p><strong>缺陷</strong></p>
<ol>
<li><p>连接建立时间长  </p>
</li>
<li><p>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多</p>
<p>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用  </p>
</li>
<li><p>可靠性不高？</p>
<p>维护piece到piece的映射关系，一旦宕机，全部玩完</p>
</li>
</ol>
<h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><p>以分组为单位进行存储-转发，按照有无网络层的连接，可以分为</p>
<ol>
<li><p>数据报服务：分组的目标地址决定下一跳，在不同的阶段，路由可以改变，类比问路，Internet</p>
<p>无需建立连接，有数据就传输，每个分组独立路由（路径不一样，可能失序、丢失、重复），路由器根据分组的目标地址进行路由，决定下一跳</p>
</li>
<li><p>虚电路服务：每个分组都带标签（虚电路标识 VC ID），标签决定下一跳  ，建立连接时决定路径，路径保持不变，路由器需要维护每个连接的状态信息（虚电路网络提供网络层的连接服务）</p>
<p>有点类似电路交换，但是不是实际存在的物理电路，而是通过逻辑电路模拟物理电路，实现数据传输</p>
<p>需要在传输前<strong>建立连接，</strong>建立连接的意思就是通信双方协商建立一个虚电路，并分配一个唯一的ID</p>
<ol>
<li>呼叫建立</li>
<li>数据传输和虚电路释放</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>分组（packet ）</strong>：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</p>
<p><strong>存储转发（store and forward ）</strong>：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</p>
</blockquote>
<ul>
<li><p>网络带宽资源无需划分，传输时使用全部带宽</p>
</li>
<li><p>需要传输的数据被划分为一个一个分组，将分组从一个路由器传到相邻路由器（一跳 hop），一段一段地从源传输到目的地</p>
</li>
<li><p>在转发之前，节点（路由器）必须收到整个分组（不是完整数据），并且存在排队情况，因此延迟比线路交换大</p>
<p>分组到达速率&gt;链路的输出速率</p>
<ol>
<li>分组需要进行排队，等待传输</li>
<li>如果路由器的缓存用完了，就会丢弃分组</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>循环冗余检验码（Cyclic Redundancy Check, CRC）</strong>：是一种校验码（Checksum）技术，用于检测数据传输过程中是否出现错误。它通过对数据进行特定的计算，生成一个叫做校验和的数值，然后将这个校验和附加到数据末尾，在接收方计算校验和，验证数据是否完整、正确。</p>
</blockquote>
<h5 id="分组-vs-电路"><a href="#分组-vs-电路" class="headerlink" title="分组 vs 电路"></a>分组 vs 电路</h5><p><strong>电路传输</strong></p>
<p>适用范围广：数字信号和模拟信号都能传输</p>
<p>灵活性差：物理线路中任何一个节点出错，就需要重新拨号，建立新的连接</p>
<p>难以规格化：不同类型、规格、速率的终端很难相互进行通信</p>
<p><strong>分组传输</strong></p>
<p>提高线路利用率：某条线路出错，可以随时切换另外一条线路进行传输</p>
<p>提供多目标服务：一个报文可以同时发给多个目标</p>
<p>简化了存储过程：分组的大小是固定的，节点缓冲区的大小也是固定的，便于存储的管理</p>
<p>加速传输：后一个分组的存储和前一个分组的转发同时进行</p>
<p>出错概率和恢复代价：分组小于报文，出错概率小，只需重传出错的分组</p>
<h4 id="路由和转发"><a href="#路由和转发" class="headerlink" title="路由和转发"></a>路由和转发</h4><ul>
<li><p><strong>路由</strong>：计算路径，决定分组如何从源传输到目的地，路由选择算法</p>
</li>
<li><p><strong>转发</strong>：根据路径，查表决定当前分组从路由器的输入链路转移到哪一个输出链路</p>
</li>
<li><p><strong>统计多路复用</strong>：允许多个数据流共享一个通信信道，路由器通过识别每个数据流的目的地址决定从哪里输出，不需要分配固定的带宽、频率，根据实际需求动态分配，未被使用的带宽可以被共享，提高信道利用.</p>
<blockquote>
<p>例如，在一个局域网中，多个计算机可以共享同一通信信道，同时进行文件传输、Web浏览等不同类型的数据传输，这些数据流可以通过统计多路复用技术进行共享，从而提高带宽利用率，减少网络拥塞。</p>
</blockquote>
</li>
</ul>
<h3 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h3><h4 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p><strong>因特网内容提供者（Internet Content Provider，ICP）</strong>：提供网络服务，提供IP地址，导航服务、邮件服务、网络游戏服务</p>
</li>
<li><p><strong>因特网服务提供者（Internet Service Provider, ISP）：</strong>因特网服务提供商，提供接入互联网的服务，比如电信、联通、移动等</p>
</li>
<li><p><strong>接入ISP</strong>指的是提供互联网接入服务的服务提供商，例如电信运营商、有线电视公司等</p>
</li>
<li><p><strong>互联网交换点（Internet Exchange Point, IXP)：</strong>允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p>
</li>
<li><p><strong>请求评议（Request For  Comments）：</strong>包含了关于 Internet 几乎所有的重要的文字资料。</p>
</li>
</ul>
<p>Internet结构：网络的网络，端系统通过<strong>接入ISPs</strong>连接到互联网，<strong>接入ISPs</strong>必须是互联的，否则无意义了，如何互联呢？</p>
<h4 id="ISP互联"><a href="#ISP互联" class="headerlink" title="ISP互联"></a>ISP互联</h4><p>给定数百万的<strong>接入ISP</strong>s，如何互联</p>
<ol>
<li><p>两两互连，$O(N^2)$的连接<strong>=&gt;</strong>不可扩展</p>
</li>
<li><p>将每个<strong>接入ISP</strong>都连接到<strong>全局ISP</strong>（全局范围内覆盖）<strong>=&gt;</strong>一个全局的ISP肯定不够，而且可能造成垄断</p>
</li>
<li><p><strong>接入ISP</strong>连接到<strong>不同的全局ISP=&gt;</strong>不同的全局ISP之间合作，业务拓展</p>
</li>
<li><p>不同的全局ISP互相连接，<strong>对等连接（peering link）或者IXP连接</strong>=&gt;<strong>业务细分，一个国家、省份</strong></p>
<p>IXP同时连接到A B C A、C之间、B、C之间存在对等连接</p>
<p>本来A可能需要到C再到B，但是通过IXP可以直接实现A-B</p>
</li>
<li><p><strong>区域ISP</strong>完成区域范围内的接入，再通过全局ISP访问互联网</p>
<ol>
<li>主干网内部的ISP直接互连，拥有高速链路和交换设备</li>
<li>第二层ISP是第一层ISP的直接用户，和少量第一层ISP连接</li>
<li>本地ISP是第二层ISP的用户</li>
</ol>
</li>
</ol>
<h3 id="网络性能衡量指标"><a href="#网络性能衡量指标" class="headerlink" title="网络性能衡量指标"></a>网络性能衡量指标</h3><ul>
<li><p><strong>速率</strong>：连接在计算机网络上的主机在数字信道上传输bit的速率（比特率，bit/s b/s bps），这里的进制是10进制</p>
<p>kb/s = 10^3bit/s</p>
<p>计算机数据量的单位是2进制</p>
<p>$1KB =2^{10}~Byte =2^{10}*8~bits$</p>
</li>
<li><p><strong>带宽（bandwidth）</strong>：</p>
<ol>
<li>信号所包含的各种不同频率成分所占据的频率范围，单位是Hz</li>
<li>在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>
</ol>
<blockquote>
<p>带宽和速率：假设带宽是一条路，起点、终点都是停车场，每秒能够把多少汽车开出去叫速率（汽车之间有间隔），而当这条路满载（汽车之间紧贴着）时，每秒能够传输多少汽车是带宽</p>
</blockquote>
</li>
<li><p><strong>吞吐量（throughput ）</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制</p>
<blockquote>
<p>可以将带宽类比为道路的宽度，吞吐量则类比为车流量。带宽就像道路的宽度一样，它决定了网络所能支持的最大数据传输速率，而吞吐量则类似于道路上实际能够通过的车流量，受到道路状况、车辆速度等因素的影响。</p>
<p><strong>瓶颈链路</strong>：端到端路径上，限制端到端吞吐量的链路 ，平均吞吐$=min\{R_1，R_2,…,R_n\}$  </p>
</blockquote>
</li>
<li><p><strong>时延</strong>：发送时延+传播时延+处理时延（包括排队时延）</p>
</li>
<li><p><strong>时延带宽积</strong>：传播时延×带宽，若发送端连续发送bit，则在第一个bit抵达目标节点时，发送端就发送了时延带宽积这么多个bit，也就是以比特为单位的链路长度</p>
</li>
<li><p>往返时间（Round Trip Time，RTT）：一次双向交互的时间</p>
</li>
<li><p><strong>利用率</strong></p>
<ul>
<li>信道利用率：表示某信道有百分之几的时间是使用着的，有数据在传输的</li>
<li>网络利用率：全网络的信道利用率的加权平均<ul>
<li>网络利用率达到0.5，时延加倍</li>
<li>超过0.5，时延剧增</li>
<li>接近1，时延趋于无穷大</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>丢包率</strong>：在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比值</p>
<p>丢包一般是因为</p>
<ol>
<li>分组在传输过程中出错，被转发节点丢弃，无用了</li>
<li>分组到达某个转发节点，这个节点缓冲队列已经满了，被丢弃，也就是网络拥塞</li>
</ol>
</li>
</ul>
<h4 id="排队延时和丢失"><a href="#排队延时和丢失" class="headerlink" title="排队延时和丢失"></a>排队延时和丢失</h4><ol>
<li>分组到达链路的速率<strong>超过了</strong>链路输出的能力</li>
<li>分组需要排队等待被传输，造成<strong>延时</strong></li>
<li>如果路由器缓冲区用完了，新来的分组就会被<strong>丢失</strong>，丢失的可能会被重传，也可能不重传（UDP）</li>
</ol>
<h4 id="延时分类"><a href="#延时分类" class="headerlink" title="延时分类"></a>延时分类</h4><ol>
<li><p>节点处理延时，通常是微妙级，甚至更少</p>
<ol>
<li>检查bit级的错误</li>
<li>根据分组首部决定路由</li>
<li>包括排队延时，在缓冲区中等待输出的时间，受路由器拥塞程度的影响</li>
</ol>
</li>
<li><p>传输延时（存储转发延时，或者叫发送时延），低速率链路的这一项延时比较大，通常是微妙级</p>
<p>R=链路带宽（bps）</p>
<p>L=分组长度（bits）</p>
<p>T=L/R=s</p>
</li>
<li><p>传播延时，通常是微妙到毫秒</p>
<p>d=物理链路的长度</p>
<p>s=在物理链路上的传播速度（$2×10^8m/s$）</p>
<p>传播延时=d/s</p>
</li>
</ol>
<h4 id="排队延时"><a href="#排队延时" class="headerlink" title="排队延时"></a>排队延时</h4><p>a=分组到达队列的平均速率</p>
<p>流量强度=La/R</p>
<p>每秒有多少个分组抵达这个路由器，再乘上每个分组的长度，除链路的带宽，就是链路的流量强度</p>
<p>La/R趋向于0：延时很小</p>
<p>La/R趋向于1：延时急剧增大</p>
<p>La/R超过1：延时趋于无穷大</p>
<h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h4><p>Traceroute诊断程序:提供从源端，经过路由器，到目的的延时测量 Round Trip Time</p>
<p>For all i:</p>
<ul>
<li>沿着目的的路径，向每个路由器发送3个探测分组</li>
<li>路由器i将向发送方返回一个分组</li>
<li>发送方对发送和回复之间间隔计时</li>
</ul>
<p>基于互联网控制报文协议（ICMP，Internet Control Message Protocol）实现</p>
<p>报文的head里面有TTL，每过一跳就-1，直到为0，所抵达的路由器往回发送一个ICMP告知源，TTL设为1，到第一个路由器就结束了，路由器返回了ICMP，我的IP地址是啥，你的探测分组被我干掉了</p>
<p>设置TTL足够大，肯定能够到达目标主机，但是端口没有进程监听，就返回另外一种ICMP，由于目标端口不可达，丢了</p>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>实体</strong>：任何可以发送或者接收信息的硬件或者软件进程，对等实体就是指收发双方位于相同层次的实体</p>
<blockquote>
<p>应用层的Web浏览器和Web服务器</p>
</blockquote>
<p><strong>协议</strong>：控制两个对等实体进行逻辑通信的规则的集合，包括语法（定义所交换信息的格式）语义（信息中各个字段的含义以及收发双方要完成的动作[请求报文→响应报文→绘制、渲染Web页面] ）和同步（收发双方的时序关系，必须先请求再响应），水平方向</p>
<blockquote>
<p>应用层的HTTP SMTP</p>
<p>运输层的TCP UDP</p>
<p>网络层的IP</p>
<p>数据链路层的以太网的CSMA/CD</p>
<p>物理层的传统以太网使用的曼彻斯特编码</p>
</blockquote>
<p><strong>服务</strong>：体系结构中，低层基于协议，对等实体能够实现逻辑通信，进而向上层提供服务，垂直方向</p>
<p><strong>服务访问点（Service Access Point）</strong>：同一系统中，相邻两层实体交换信息的逻辑接口</p>
<blockquote>
<p>数据链路层的服务访问点是帧的类型字段</p>
<p>网络层的服务访问点是IP数据报首部的协议字段</p>
<p>运输层的服务访问点是端口</p>
</blockquote>
<p><strong>服务原语</strong>：上层使用下层的服务必须通过与下层交换一些命令，命令就是服务原语</p>
<p><strong>协议数据单元（Protocol Data Unit）</strong>：对等层次之间传送的数据包称为该层的协议数据单元</p>
<p><strong>服务数据单元（Service Data Unit，SDU）</strong>：服务数据单元是在计算机网络中传递的数据单位，它包含了应用程序要传输的数据和一些控制信息。在协议栈的不同层次中，服务数据单元可能会被封装为不同的数据单元</p>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><ol>
<li><p>OSI体系结构</p>
<p>自底向上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
</li>
<li><p>TCP/IP体系结构</p>
<p>自底向上依次是网络接口层、网络层、传输层、应用层</p>
</li>
<li><p>五层结构</p>
<p>自底向上依次是物理层、数据链路层、网络层、传输层、应用层</p>
</li>
</ol>
<h3 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a>协议层次和服务模型</h3><p>计算机网络的各层以及其协议集合，称为网络的体系结构。</p>
<p>网络是一个复杂的系统，如何组织和实现这个复杂的网络功能呢？OSI七层模型的设计理念</p>
<h4 id="相关概念-2"><a href="#相关概念-2" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p><strong>服务（Service）</strong>：低层实体为高层实体提供服务</p>
</li>
<li><p><strong>原语（primitive ）</strong>：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的—-形式</p>
</li>
<li><p><strong>服务访问点（Service Access Point，SAP）</strong>：上层使用下层提供的服务通过层间的接口—地点</p>
</li>
</ul>
<h4 id="层次化的优势"><a href="#层次化的优势" class="headerlink" title="层次化的优势"></a>层次化的优势</h4><ul>
<li>将网络的复杂功能分为功能明确的层次，每一层实现了其中一个或一组功能，每个层次实现功能为上层提供服务</li>
<li>服务本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务</li>
<li>在实现本层协议的时候，直接利用了下层所提供的服务</li>
<li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务</li>
</ul>
<p>不需要关心下层协议的具体实现细节，能够屏蔽下层的差异，提供统一的接口，使得不同的网络设备和协议能够互相协作，从而实现了互联网的互通和互操作</p>
<p>劣势在于效率比较低</p>
<h4 id="服务-VS-协议"><a href="#服务-VS-协议" class="headerlink" title="服务 VS 协议"></a>服务 VS 协议</h4><ul>
<li><p><strong>服务与协议的区别</strong></p>
<ul>
<li>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直方向</li>
<li>协议(Protocol)：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平方向</li>
</ul>
</li>
<li><p><strong>服务与协议的联系</strong></p>
<ul>
<li>本层协议的实现要靠下层提供的服务来实现</li>
<li>本层实体通过协议为上层提供更高级的服务</li>
</ul>
</li>
</ul>
<h4 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h4><p>层次间传输的数据统一称为数据单元，不同层对数据单元的命名不同，</p>
<ul>
<li>应用层：报文(message)，报文是应用程序中的数据，屏蔽传输层差异，用于在应用程序之间传输数据。</li>
<li>传输层：报文段(segment)：TCP段，UDP数据报，报文段包含了源和目的端口号、序号、确认号和数据等信息，屏蔽网络层差异，用于在端到端的通信中传输数据。最重要的是TCP和UDP协议</li>
<li>网络层：分组packet（如果无连接方式：<strong>数据报datagram</strong>），分组包含了源和目的地址、路由信息和数据等信息，屏蔽数据链路层差异，用于在网络中传输数据。最重要的是IP协议</li>
<li>数据链路层：帧(frame)，帧包含了数据和控制信息，屏蔽物理层差异，用于在物理介质上传输数据.</li>
<li>物理层：比特(bit)，表示数字信号的最小单位</li>
</ul>
<blockquote>
<p>假设有一个计算机A要向另一个计算机B发送一段数据，这时候就会涉及到各个层次的协议和相应的数据单元。</p>
<p>首先，应用层协议（比如HTTP协议）在计算机A上将数据封装为一个报文（Message），该报文包含了要发送的数据、目的地址和端口号等信息。</p>
<p>然后，传输层协议（比如TCP协议）在计算机A上将报文封装为一个报文段（Segment），该报文段包含了源端口号、目的端口号、序号、确认号和数据等信息，并将报文段发送给计算机B。</p>
<p>接着，网络层协议（比如IP协议）在计算机A上将报文段封装为一个分组（Packet），该分组包含了源地址、目的地址、路由信息和数据等信息，并将数据包通过网络传输到计算机B。</p>
<p>数据包到达计算机B后，网络层协议将数据包解封，将报文段交给传输层协议，传输层协议将报文段交给应用层协议，应用层协议将报文解封，提取出原始数据，并将数据传递给应用程序。</p>
</blockquote>
<p>数据单元的具体操作</p>
<ul>
<li><strong>服务数据单元（Service Data Unit，SDU）</strong>：服务数据单元是在计算机网络中传递的数据单位，它包含了应用程序要传输的数据和一些控制信息。在协议栈的不同层次中，服务数据单元可能会被封装为不同的数据单元进行传输。例如，在应用层，服务数据单元被封装为应用数据单元（Application Data Unit，ADU）进行传输。</li>
<li><strong>服务访问点（Service Access Point，SAP）</strong>：服务访问点是在计算机网络中不同层次的协议之间进行通信的接口，它定义了相邻协议之间的数据交换方式和协议类型。每个协议层次都有自己的服务访问点，用于与相邻层次的协议进行通信和数据交换</li>
<li><strong>接口数据单元（Interface Data Unit，IDU）</strong>：接口数据单元是在服务访问点之间传输的数据单位，它包含了服务访问点之间传输的数据和控制信息。接口数据单元是在协议栈的相邻层次之间传输的，用于实现不同层次之间的数据交换。</li>
<li><strong>协议数据单元（Protocol Data Unit，PDU）</strong>：协议数据单元是在协议栈的不同层次之间传输的数据单位，它包含了该层次所需的数据和控制信息。每个协议层次都有自己的协议数据单元，用于实现不同层次之间的数据交换和协议操作。</li>
<li><strong>接口控制信息（Interface Control Information，ICI)</strong>：接口控制信息是在服务访问点之间传输的控制信息，用于表示数据的类型、长度、校验和等控制信息。接口控制信息通常被封装在接口数据单元中，用于实现不同层次之间的数据交换和控制操作。</li>
</ul>
<p><img src="/posts/57351/image-20230524165550694.png" alt="image-20230524165550694"></p>
<h4 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h4><p>自顶向下</p>
<ol>
<li><p>应用层</p>
<p>目标：为用户或者其他应用程序提供网络应用服务</p>
<p>问题：如何通过应用进程间的交互实现各种网络应用</p>
<ol>
<li>FTM、SMTP、HTTP、DNS等</li>
</ol>
</li>
<li><p>传输层</p>
<p>目标：进程之间的数据传输</p>
<p>问题：如何解决进程间基于网络的通信（操作系统的进程间通信），出现传输错误时怎么处理</p>
<ul>
<li><p>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信</p>
</li>
<li><p>TCP和UDP</p>
</li>
</ul>
</li>
<li><p>网络层</p>
<p>目标：为数据报从源到目的地选择路由，进行转发（逻辑寻址）</p>
<p>问题：如何标识各个网络和网络中的主机（网络和主机的编址问题，IP地址）、路由器如何转发分组、如何进行路由选择</p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠</li>
<li>IP,路由协议</li>
</ul>
</li>
<li><p>数据链路层</p>
<p>目标：相邻网络节点间的数据传输（物理寻址）</p>
<p>问题：如何标识网络中的各个节点（物理设备，主机、路由器，主机编址问题，MAC地址），如何从比特流中区分出数据和地址，如何协调各个主机使用总线的冲突</p>
<ul>
<li>2个相邻2点的通信，点到点通信，可靠或不可靠  </li>
<li>点对对协议PPP, 802.11(wifi), Ethernet  </li>
</ul>
</li>
<li><p>物理层</p>
<p>目标：在线路上传输bit</p>
<p>问题：采用怎样的传输介质，采用怎样的物理接口，使用什么信号表示比特0和1</p>
</li>
</ol>
<h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>额外添加了表示层和会话层</p>
<p>表示层：允许应用解释传输的数据，加密解密、压缩解压缩、编码解码、封装解封装</p>
<p>会话层：管理应用程序之间的会话，数据交换的同步，检查点，恢复</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/posts/34443.html</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由传输层负责</strong></p>
<p>网络层协议存在于主机和路由器（检查每一个经过它的IP数据报的头部）中，负责主机之间的逻辑通信，包括转发和路由功能，数据单元被称为（packet）</p>
<p><strong>地址解析协议（Address Resolution Protocol，ARP）</strong> : 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组。</p>
<blockquote>
<p>ARP协议的作用就是通过查询本地网络中的ARP缓存表，找到目标IP地址对应的MAC地址，以便于进行数据传输</p>
<p>如果缓存没有命中，则主机会发送一个ARP请求广播，请求网络中所有主机回复自己的MAC地址。当目标主机收到ARP请求广播后，它会将自己的MAC地址回复给源主机，源主机收到回复后就可以使用目标主机的MAC地址进行数据传输了。同时，源主机还会将目标主机的IP地址和MAC地址保存到自己的ARP缓存表中，以便于下次数据传输时直接使用。</p>
</blockquote>
<p>发送端：将段封装到数据报中</p>
<p>接收端：将段上交给传输层实体</p>
<p><strong>转发</strong>：将分组从路由器的输入接口转发到合适的输出接口，<strong>转发</strong>功能对应<strong>数据平面</strong>，转发功能的实现方式如下</p>
<blockquote>
<p>路由器插了很多网卡，接入三个不同的物理网，从网卡收到一个帧，取出帧中的分组，交付网络层，网络层解析目标IP地址查路由表决定转发到哪个端口出去，将分组扔到对应端口网卡封装成帧中继的帧打出去</p>
</blockquote>
<ol>
<li>传统方式：基于目标地址+转发表</li>
<li>软件定义网络（Software Define Network，SDN）方式：基于多个字段+流表</li>
</ol>
<p><strong>路由</strong>：使用路由算法来决定分组从源主机到目标主机的路径，<strong>路由</strong>功能对应<strong>控制平面</strong>，控制平面的方法</p>
<ol>
<li>传统路由算法：在路由器中实现路由功能</li>
<li>SDN：在远程的服务器中实现</li>
</ol>
<p><strong>数据平面</strong>：本地服务，每个路由器的功能，负责转发</p>
<p><strong>控制平面</strong>：决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</p>
<blockquote>
<p>转发相当于碰到路口怎么转，路由相当于指定旅行计划</p>
</blockquote>
<p><strong>路由 ~ 转发</strong>：路由（控制平面）算法决定端到端路径，生成<strong>路由表</strong>，为转发（数据平面）功能服务，IP协议根据转发表决定了IP数据报在此路由器上的局部转发</p>
<p><strong>转发表 ~ 路由表</strong>：路由表是由路由算法生成的，转发表是根据路由表生成的。但是在讨论路由选择的原理时，往往不去区分路由表和转发表的区别，统一使用路由表一词</p>
<p><strong>软件定义网络中的控制平面</strong>：逻辑上集中的控制平面，一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互</p>
<p><strong>网络模型</strong>：网络层向上层提供服务，用哪些指标加以描述</p>
<ol>
<li><p>单个数据包的服务</p>
<ol>
<li>可靠传送</li>
<li>延迟保证</li>
</ol>
</li>
<li><p>数据包流的服务</p>
<ol>
<li><p>保序性</p>
</li>
<li><p>最小带宽保证</p>
</li>
<li><p>分组之间的延迟差</p>
<blockquote>
<p>每个分组打出去都有延迟，这些分组之间的延迟的差，延迟差为0，就是说发送方按照一定频率打，接收方也能够按照相同频率接受</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>网络层连接 vs 传输层连接：网络层的连接在两个主机之间，涉及到路径上的一些路由器，而传输层则在两个进程之间，很可能只体现在端系统上，不考虑中间的一些路由器</p>
<h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><h4 id="路由器的组成"><a href="#路由器的组成" class="headerlink" title="路由器的组成"></a>路由器的组成</h4><p><img src="/posts/34443/image-20230529144545425.png" alt="image-20230529144545425"></p>
<p>软件和硬件两个层面，路由功能在软件层面（运行路由选择算法生成路由表）实现，转发功能在硬件层面（从输入到输出链路交换数据包-根据路由表进行分组转发）实现</p>
<p>交换结构：输入到输出，完成一个局部转发</p>
<p>端口：既是输入端口也是输出端口，完成双向传输</p>
<h5 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h5><p><img src="/posts/34443/image-20230529144831883.png" alt="image-20230529144831883"></p>
<p><strong>line termination（行终止符）</strong>：物理层，Bit级别的数据接收</p>
<p><strong>link layer protocol</strong>：数据链路层，协议动作，封装解封装，判断哪里是帧头，帧尾，CRC检错，目标MAC和网卡MAC是否一致，</p>
<p><strong>lookup, forwarding（查找，转发）</strong>：分布式交换，根据数据报头部的信息如：目的地址，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动）</p>
<ol>
<li>基于目标的转发（传统方式）：仅仅依赖于IP数据报的目标IP地址（转发表）</li>
<li>通用转发（SDN方式）：基于头部字段的任意集合进行转发（流表）</li>
</ol>
<p><strong>queueing</strong>：输入可能需要排队，需要设置缓冲区，但是溢出也可能造成丢失</p>
<p>接收的速率和交换（交换到输出口）的速率不匹配（交换机构的速率小于输入端口的汇聚速率  ），需要缓冲区排队，缓冲区溢出需要丢弃</p>
<p>Head-of-the-Line (HOL) blocking: 排在队头的数据报阻止了队列中其他数据报向前移动</p>
<blockquote>
<p><img src="/posts/34443/image-20230529150500371.png" alt="image-20230529150500371"></p>
</blockquote>
<h5 id="交换机构"><a href="#交换机构" class="headerlink" title="交换机构"></a>交换机构</h5><p>功能：将分组从输入缓冲区传输到合适的输出端口</p>
<p>交换速率：分组可以按照该速率从输入传输到输出</p>
<ul>
<li>运行速度经常是输入/输出链路速率的若干倍（N个输入和输出端口，N倍速率才不会成为瓶颈）</li>
</ul>
<p><strong>典型交换机构</strong>：</p>
<ol>
<li><p>内存</p>
<p>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</p>
<p>转发速率被内存的带宽限制 (数据报通过BUS两遍，进去一次，出来一次)  </p>
<p>一次只能转发一个分组</p>
</li>
<li><p>总线</p>
<p>数据报通过共享总线，从输入端口转发到输出端口</p>
<p>交换速度受限于总线带宽</p>
<p>一次也是只能处理一个分组</p>
</li>
<li><p>互联网络</p>
<p>将多个处理器连接成多处理器，能够并发转发多个分组，克服总线带宽限制</p>
</li>
</ol>
<h5 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h5><p><img src="/posts/34443/image-20230529152126700.png" alt="image-20230529152126700"></p>
<p>将来自输入端口的数据报传输出去</p>
<p>queueing：当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存，数据报（分组）可能会被丢弃，由于拥塞，缓冲区没有空间</p>
<p>调度机制：选择哪个排队的数据报进行传输（通过链路进行传输）</p>
<ul>
<li><p>先进先出（first in first out，FIFO）调度</p>
<p>按照分组到来的次序进行发送</p>
<p>丢弃策略：</p>
<ul>
<li><p>tail drop：丢弃刚刚到达的分组</p>
</li>
<li><p>priority：基于优先级进行丢弃</p>
</li>
<li><p>random：随机选择一个幸运分组进行丢弃</p>
</li>
</ul>
</li>
<li><p>优先级调度</p>
<p>发送最高优先权的分组，多类：不同类别有不同的优先权，类比依赖于标记或者其他头部字段</p>
<p>先传输高优先级的队列中的分组（<a href>操作系统中的进程调度</a>），分组内部按照FIFO进行调度</p>
</li>
<li><p>Round Robin（RR）调度</p>
<p>多类别，循环扫描不同类型的队列，每个队列发送一个分组，再下一个类型，循环所有类</p>
</li>
<li><p>Weighted Fair Queuing</p>
<p>一般化的RR， 为每个队列设置权重，权重和队列服务时间成正比</p>
</li>
</ul>
<h5 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h5><p>longest prefix  matching：当给定目标地址查找转发表时，采用最长地址前缀匹配的目标地址表项</p>
<p><img src="/posts/34443/image-20230529151047659.png" alt="image-20230529151047659"></p>
<h4 id="网际互联协议"><a href="#网际互联协议" class="headerlink" title="网际互联协议"></a>网际互联协议</h4><p>Internet Protocol，IP：实现数据平面转发功能</p>
<p><img src="/posts/34443/image-20230529154116125.png" alt="image-20230529154116125"></p>
<h5 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h5><p><img src="/posts/34443/image-20230529154719003.png" alt="image-20230529154719003"></p>
<p>head len里面以1当4，基本单位就是4个字节，1→4，2→8</p>
<p>type of service：数据类型，分组做调度有依据，后面没用了，因为IP不是按照数据报收钱的，而是按照包月收钱的，分组都是包月的，可能打成高优先级的</p>
<p>time to live：最大剩余跳数，每过一个路由器-1，0丢弃，还要告知一下源主机，我把你的数据包丢了，你重发下吧（杀人还要诛心啊）</p>
<p>upper layer：这个数据往上给哪个协议 TCP 还是 UDP啊？有点类似TCP/IP的端口号字段，决定给上一层的哪个应用进程</p>
<p>Internet checksum ：IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段（生存时间、标志、<br>片偏移等）的取值可能发生变化。</p>
<h5 id="IP分片和重组（Fragmentation-amp-Reassembly）"><a href="#IP分片和重组（Fragmentation-amp-Reassembly）" class="headerlink" title="IP分片和重组（Fragmentation &amp; Reassembly）"></a>IP分片和重组（Fragmentation &amp; Reassembly）</h5><p><strong>最大传输单元（Maximum Transmission Unit，MTU）</strong>:表示数据链路层的一个帧所能携带的最大数据长度，因此对于大的数据报，一个MTU存不下，就需要分片</p>
<p><strong>分片</strong>：一个大的IP数据报在网络上被分片，即分割成若干个小的数据报，数据报都得带上head，这些数据报拥有相同ID、不同的偏移量，并且最后一个分片标记为0</p>
<p><strong>重组</strong>：<strong>在目标主机</strong>，将分片的数据报根据ID、偏移量（以1当8，8bits为最小单位）进行重组（乱序→有序）</p>
<p><strong>丢弃</strong>：（某个数据报的分片抵达就开始启动一个计时器，如果超时还没有完善，那就把所有的数据报都抛弃）</p>
<blockquote>
<p>比如一个网络的MTU是4000 另外一个是1500<br>同一个ID表示属于一个数据报,<br>头部20 应该是<br>20 + 1480 偏移量为0<br>20 + 1480 偏移量为1480<br>20 + 1020 偏移量为2960</p>
</blockquote>
<p>不在路由器进行重组，为什么？</p>
<ol>
<li>减少路由器的压力</li>
<li>路由表变化，可能后续分片的路径不一样了，那么理论上只有目标主机拥有完整分片</li>
</ol>
<p>MTU vs MSS</p>
<p><strong>MSS</strong>：最大报文段长度，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。</p>
<h5 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h5><p><strong>IP地址</strong>：32位标识，对主机或者路由器的接口进行编址，分为高位部分（子网部分）和低位部分（主机部分）</p>
<p><strong>接口</strong>：主机/路由器和物理链路的连接处</p>
<ol>
<li>路由器通常拥有多个接口</li>
<li>主机也有可能有多个接口</li>
<li>IP地址和接口绑定</li>
</ol>
<p><img src="/posts/34443/image-20230529161313093.png" alt="image-20230529161313093"></p>
<h6 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h6><p>结构上类比子图，一个子网内的节点（主机或者路由器）它们IP地址的高位相同，这些节点所构成的网络就叫子网</p>
<p>子网内部节点间通信不需要路由器接入，各个主机可以在物理上（借助交换机）相互直接可达，一跳可达</p>
<p>实际上网络层的数据传输是以子网为单位进行传输的，先到达子网，再寻找子网内的主机</p>
<p><strong>子网掩码</strong>：用于确定IP地址的高位和低位的分界线的一个32位二进制数，由连续的1和连续的0组成，1表示这一位是子网地址，0表示这以为是主机地址，用子网掩码去和IP地址作 按位与 运算即可得到IP地址的子网部分地址</p>
<ol>
<li><blockquote>
<p><img src="/posts/34443/image-20230529164951654.png" alt="image-20230529164951654"></p>
</blockquote>
</li>
</ol>
<p>如图存在6个子网，两个路由器之间也能构建子网</p>
<p><strong>转发表和转发算法</strong>：</p>
<ol>
<li><p>获取IP数据报的<strong>目标地址</strong>，查转发表</p>
<p>202.38.64.1</p>
</li>
<li><p>用<strong>IP地址</strong>和<strong>表内子网掩码</strong>作 <strong>按位与</strong> 运算 得到 <strong>子网地址</strong></p>
<p>202.38.64.1 &amp; 255.255.255.192=202.38.64.0</p>
</li>
<li><p>比较子网地址和目标地址，匹配则按照表项找到对应接口进行转发，否则使用默认表项（默认路由）转发数据报</p>
<p>202.38.64.0==202.38.64.0？</p>
<blockquote>
<p><img src="/posts/34443/image-20230529183811306.png" alt="image-20230529183811306"></p>
</blockquote>
</li>
</ol>
<h6 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h6><p>依据子网部分的IP地址长度进行分类，一共有A B C D E五类</p>
<p><img src="/posts/34443/image-20230529165232844.png" alt="image-20230529165232844"></p>
<h6 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h6><ol>
<li>子网部分全是0-本网络</li>
<li>主机部分全是0-本主机</li>
<li>主机部分全是1-广播地址，广播给这个网络的所有主机</li>
</ol>
<p><img src="/posts/34443/image-20230529165417924.png" alt="image-20230529165417924"></p>
<h6 id="无类域间路由"><a href="#无类域间路由" class="headerlink" title="无类域间路由"></a>无类域间路由</h6><p><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无类域间路由 ，消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号，即可以在任意位置划分网络号和主机号，然后<strong>通过从主机号借位实现子网划分</strong></p>
<blockquote>
<p>例：某个机构拥有一个大的CDR地址块，即206.0.64.0/18，现在某个高校需要申请一个较大的CDR地址块以供学校使用，学校内部又分为4个系，由于每个系的人数不一样，所以要给人数较多的系分配较多的P地址，人数较少的系分配较少的P地址，现在采用以下的分配方案：<br>机构分配给该高校一个C1DR地址块：206.0.68.0/22，然后该高校内部的分配方案如下：<br>一系：206.0.68.0/23，一系内部又分为206.0.68.0/25、206.0.68.128/25、206.0.69.0/25和206.0.69.128/25四个子网。<br>二系：206.0.70.0/24，二系内部又分为206.0.70.0/26、206.0.70.64/26、206.0.70.128/26和206.0.70.192/26四个子网。<br>三系：206.0.71.0/25，三系内部又分为206.0.71.0/26和206.0.71.64/26两个子网。<br>四系：206.0.71.128/25，四系内部又分为206.0.71.128/26和206.0.71.192/26两个子网。<br>请分析以上方案划分的具体细节。</p>
<p>206.0.64.0/18=&gt;11001110 00000000 01-000000 00000000<br>最小地址是 206.0.64.0/18<br>最大地址是 206.0.127.255/18<br>子网掩码为 255.255.192.0/18<br>地址总数为 2^14=16384</p>
<p>机构给学校的地址是206.0.68.0/22 =&gt; 206.0.01<strong>0001</strong> 00.0/22<br>子网掩码为 255.255.252.0/22<br>地址总数为 2^10 = 1024<br>从18变成了22 取出4位作为子网划分的依据 最多16个子网：<strong>0001是给高校的子网，是第二个子网</strong></p>
<p>进一步划分 逻辑上4个子网 但是划分时是如图所示<br>一系68 69<br>    206.0.01 0001 <strong>00</strong>.00000000/23<br>206.0.01 0001 <strong>01</strong>.00000000/23</p>
<p>子网掩码为 255.255.254.0 地址总数为2^9 = 512个<br>内部划分4个子网 再取出两位 每个子网128个地址<br>206.0.0100010<strong>0.0</strong> <0000000,1111111> 0-127<br>206.0.0100010<strong>0.1</strong> <0000000,1111111> 0-127<br>206.0.0100010<strong>1.0</strong> <0000000,1111111> 0-127<br>206.0.0100010<strong>1.1</strong> <0000000,1111111> 0-127</0000000,1111111></0000000,1111111></0000000,1111111></0000000,1111111></p>
<p>二系 207.0.010001<strong>10</strong>.0/24 最后8位表示主机 地址总数为2^8=256<br>二系 70<br>进一步划分为4个子网 又取走两位作为子网 每个子网 64个地址<br>206.0.01000110.<strong>00</strong> <00000,11111> 0-63<br>206.0.01000110.<strong>01</strong> <00000,11111> 0-63<br>206.0.01000110.<strong>10</strong> <00000,11111> 0-63<br>206.0.01000110.<strong>11</strong> <00000,11111> 0-63</00000,11111></00000,11111></00000,11111></00000,11111></p>
<p>三系 207.0.010001<strong>11</strong>.0/25 最后7位表示主机 地址总数为2^7=128<br>三系 71</p>
<p>进一步划分为两个子网 又取走1位 每个子网64个地址</p>
<p>206.0.01000111.0<strong>0</strong> <000000,111111> 0-63<br>206.0.01000111.0<strong>1</strong> <000000,111111> 0-63</000000,111111></000000,111111></p>
<p>四系 27.0.010001<strong>11</strong>.0/25 最后7位表示主机 地址总数为2^7=128</p>
<p>四系 71</p>
<p>进一步划分为两个子网 又取走1位 每个子网64个地址</p>
<p>206.0.01000111.1<strong>0</strong> <000000,111111> 0-63<br>206.0.01000111.1<strong>1</strong> <000000,111111> 0-63</000000,111111></000000,111111></p>
</blockquote>
<p><img src="/posts/34443/20151117195849426.png" alt="img"></p>
<h6 id="层间编址：路由聚集"><a href="#层间编址：路由聚集" class="headerlink" title="层间编址：路由聚集"></a>层间编址：路由聚集</h6><p>route aggregation</p>
<p>目标：通过层次的聚集减少路由表表项，简化路由表</p>
<p>层次：子网的子网</p>
<p>路由通告：哪些子网前缀的数据发给我，这个路由器的这个端口的IP是这些数据的下一跳</p>
<p><img src="/posts/34443/image-20230529190934507.png" alt="image-20230529190934507"></p>
<p>前23位的聚集→前20位聚集</p>
<p><img src="/posts/34443/image-20230529191110972.png" alt="image-20230529191110972"></p>
<blockquote>
<p>组织1被收购了，重新通告，200.23.18.x的路由器说 23为前缀是200.23.18的发给我，然后到了IPy的地方，199和200虽然不能聚集，但是可以通告，前16位是199.31.0.0以及前23位是200.23.18的发给我</p>
</blockquote>
<h5 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h5><p>网络地址转换（Network Address Translation，NAT）</p>
<p><img src="/posts/34443/image-20230529191821649.png" alt="image-20230529191821649"></p>
<p><strong>目的</strong>：使本地网络对外只有一个有效的IP地址</p>
<ol>
<li>不需要从ISP分配一块地址，只用一个IP就可以用于所有的局域网内的设备—省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界—对外还是原来那个IP地址</li>
<li>可以改变ISP（地址变化）而不需要改变内部的设备地址—对外IP地址变化不影响内网的设备的地址</li>
<li>局域网内部的设备没有明确的地址，对外是不可见的—安全  </li>
</ol>
<p><strong>实现</strong>：</p>
<p>外出数据包：替换源地址和端口号为NAT IP地址（机构公用IP）和新的端口号（当前空闲的端口号），目标IP和端口不变（远端的主机返回数据时，就会用NAT IP地址和新端口号作为目标IP和端口号）</p>
<p>映射：在NAT转换表中记录每一转换替换对（源IP 源端口-NAT IP地址 新端口）新端口需要独一无二</p>
<p>进入数据包：查询NAT转换表，替换为源IP和源端口，再转发</p>
<p><img src="/posts/34443/image-20230529192308661.png" alt="image-20230529192308661"></p>
<p><strong>NAT穿越问题（内网穿透）</strong>：外网的设备怎么主动联系内网的设备呢？</p>
<ol>
<li><p>静态配置NAT：将所有主动访问的数据都转发到某个特定的内网设备商</p>
</li>
<li><p>Universal Plug and Play (UPnP) Internet Gateway Device (IGD)  协议：允许内网设备查询NAT表项，就是之前转换的关系，主增删端口映射，这样外网就可以通过表项访问内网设备</p>
<blockquote>
<p>比如 添加映射 138.76.29.7:80=&gt;10.0.0.1:80 </p>
</blockquote>
</li>
<li><p>中继</p>
<ol>
<li><p>NAT后面的服务器建立和中继的连接</p>
</li>
<li><p>外部的客户端链接到中继</p>
</li>
<li><p>中继在2个连接之间桥接</p>
<p><img src="/posts/34443/image-20230529193020735.png" alt="image-20230529193020735"></p>
</li>
</ol>
</li>
</ol>
<h5 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h5><p><strong>目的</strong>：</p>
<ol>
<li><strong>32-bit的IPv4地址空间快用完了</strong></li>
<li>头部格式改变帮助加速处理和转发<ol>
<li>每一跳TTL都得-1，都要重新计算checksum</li>
<li>分片再重组，偏移量，浪费时间</li>
</ol>
</li>
<li>头部格式改变帮助QoS</li>
</ol>
<p><strong>IPv6数据报</strong></p>
<ol>
<li>固定的40字节头部</li>
<li>数据传输不允许分片，太大的直接丢掉，同时给主机返回一个ICMP错误报packet too big</li>
</ol>
<p><img src="/posts/34443/image-20230529194228552.png" alt="image-20230529194228552"></p>
<p><strong>IPv4→IPv6</strong></p>
<ol>
<li><p>Checksum:被移除掉，降低在每一段中的处理速度</p>
</li>
<li><p>Options:允许，但是在头部之外,被 “NextHeader” 字段标示</p>
</li>
<li><p>ICMPv6: ICMP的新版本附加了报文类型</p>
<blockquote>
<p>“Packet Too Big”</p>
<p>多播组管理功能</p>
</blockquote>
</li>
</ol>
<p><strong>过渡</strong>：基于隧道进行过渡</p>
<p><strong>隧道</strong>：</p>
<ol>
<li><p>IPv4的设备数量远远超过IPv6的设备数量：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报</p>
<blockquote>
<p>IPv4是海洋，IPv6是孤岛，孤岛内部是IPv6通信</p>
<p>v4~v4没问题</p>
<p>v4~v6、v6~v6需要处理：IPv4内嵌IPv6</p>
</blockquote>
</li>
<li><p>IPv6的设备数量远远超过IPv4的设备数量：在IPv6路由器之间传输的IPv6数据报中携带IPv4数据报</p>
</li>
</ol>
<p><img src="/posts/34443/image-20230529194530174.png" alt="image-20230529194530174"></p>
<h5 id="虚拟专用网络"><a href="#虚拟专用网络" class="headerlink" title="虚拟专用网络"></a>虚拟专用网络</h5><p>Virtual Private Network，VPN，在公用网络上建立专用网络，进行加密通讯</p>
<p>VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密</p>
<p>使用VPN技术后，用户的数据流量会被加密，而且流量也会被伪装成VPN服务提供商的流量，使得中国政府无法通过对数据包的识别和过滤来限制和屏蔽特定的网站和服务。因此，用户可以通过VPN技术翻墙访问外网资源，绕过中国政府的审查和限制。</p>
<p>其实就是代理访问，你无法访问外网，但是VPN服务提供商可以访问，所以你将请求发给VPN服务器，VPN服务器代替你进行访问，再将外网资源通过加密和隧道等方式返回给你</p>
<h4 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h4><h5 id="传统方式的路由转发"><a href="#传统方式的路由转发" class="headerlink" title="传统方式的路由转发"></a>传统方式的路由转发</h5><p>每个路由器上都有实现路由算法元件（它们之间需要相互交互）- 形成传统IP实现方式的控制平面</p>
<ol>
<li>每台设备上既实现控制功能、又实现数据平面</li>
<li>控制功能分布式实</li>
<li>路由表-粘连</li>
</ol>
<p>但是存在数量众多、功能各异的中间盒，需要不同的设备实现不同的网络功能</p>
<ol>
<li><p>每台设备垂直集成了控制平面和数据平面的功能</p>
<p>路由器自己计算路由表，自己对到来的分组进行转发（交给IP协议实体）</p>
<p>硬件、操作系统一系列协议的私有实现，都由一个厂商提供，封闭</p>
</li>
<li><p>控制平面<strong>分布式</strong>地实现了各种控制平面功能</p>
<p>路由器分布式计算路由表</p>
</li>
<li><p>升级和部署网络设备非常困难</p>
<p>设备基本上只能按照固定方式进行工作，控制逻辑固化</p>
</li>
</ol>
<p><strong>问题</strong></p>
<ol>
<li>垂直集成&gt;昂贵、不便于创新的生态</li>
<li>分布式、固化设备功能==网络设备种类繁多<ol>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设备：管理困难</li>
<li>要增加新的网络功能，需要设计、实现以及部署新的特定设备，设备种类繁多</li>
</ol>
</li>
</ol>
<h5 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h5><p>控制平面和数据平面分离</p>
<ol>
<li><p>数据平面-分组交换机</p>
<p>将路由器、交换机和目前大多数网络设备的功能进一步抽象成：按照流表（由控制平面设置的控制逻辑，可以匹配目标IP 源IP 目标端口 源端口 MAC 还有一些头部字段）进行PDU（帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</p>
<p>统一化设备功能：SDN交换机（分组交换机），执行控制逻辑</p>
</li>
<li><p>控制平面-控制器+网络应用</p>
<p>分离、集中</p>
<p>计算和下发控制逻辑：流表</p>
</li>
</ol>
<p>逻辑上集中的控制平面，一个远程控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑  </p>
<ol>
<li>集中：远程的控制器集中实现控制逻辑</li>
<li>远程：数据平面和控制平面的分离</li>
</ol>
<p><img src="/posts/34443/image-20230529195943883.png" alt="image-20230529195943883"></p>
<p><strong>优势</strong>：</p>
<ol>
<li><p>非私有实现控制平面，开放的产业生态，促进发展</p>
</li>
<li><p>集中式实现控制逻辑，便于网络管理</p>
<p>集中式控制器了解网络状况，编程简单  </p>
</li>
<li><p>支持可编程的分组交换机</p>
<p>实现流量工程等高级特性</p>
</li>
</ol>
<h5 id="流量工程"><a href="#流量工程" class="headerlink" title="流量工程"></a>流量工程</h5><p><img src="/posts/34443/image-20230529201320375.png" alt="image-20230529201320375"></p>
<ol>
<li><p>网管如果需要u到z的流量走uvwz,x到z的流量走xwyz，怎么办？</p>
<p>传统方式：定义链路代价→流量路由算法</p>
<p>SDN：动态配置路由走法</p>
</li>
<li><p>如果网管需要将u到z的流量分成2路：uvwz 和uxyz (负载均衡)，怎么办?（ IP路由面向目标）  </p>
<p>传统方式：无法完成(在原有体系下只有使用新的路由选择算法，而在全网部署新的路由算法是个大的事情)  </p>
<p>SDN：端口号区分应用，决定不同的输出端口，不同的路径</p>
</li>
<li><p>如果需要w对蓝色的和红色的流量采用不同的路由，怎么办</p>
<p>传统方式：无法操作 (基于目标的转发，采用LS, DV 路由)  </p>
<p>SDN：w基于源IP就可以区分两路流量</p>
</li>
</ol>
<p><strong>SDN特点</strong></p>
<p><img src="/posts/34443/image-20230529200702724.png" alt="image-20230529200702724"></p>
<h5 id="SDN结构"><a href="#SDN结构" class="headerlink" title="SDN结构"></a>SDN结构</h5><p>自南向北方依次是数据平面交换机→SDN控制器→网络控制应用</p>
<ol>
<li><p>数据平面交换机：采用硬件实现通用转发功能，流表被控制器计算和安装</p>
<p>基于南向API（例如OpenFlow），SDN控制器访问基于流的交换机，定义哪些可以控制哪些不能控制</p>
</li>
<li><p>SDN控制器（网络OS）</p>
<ol>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法</li>
</ol>
</li>
<li><p>采用下层提供的服务（SDN控制器提供的API)，实现网络功能</p>
<ol>
<li>路由</li>
<li>接入控制</li>
<li>负载均衡</li>
</ol>
<p>可以被第三方提供</p>
</li>
</ol>
<h5 id="OpenFlow"><a href="#OpenFlow" class="headerlink" title="OpenFlow"></a>OpenFlow</h5><p>流：由分组（帧）头部字段所定义</p>
<p>模式：将分组头部字段和流表进行匹配</p>
<p>行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器</p>
<p>优先权Priority: 几个模式匹配了，优先采用哪个，消除歧义</p>
<p>计数器Counters: #bytes 以及 #packets，对模式的匹配次数进行计数，统计数据流量的相关信息</p>
<p>![image-20230529202310457](计算机网络.assets/image-20230529202310457.png</p>
<p><img src="/posts/34443/image-20230529202321967.png" alt="image-20230529202321967"></p>
<p><img src="/posts/34443/image-20230529202607901.png" alt="image-20230529202607901"></p>
<blockquote>
<p>s3：源是10.3，目标是10.2的，都转发到输出端口3</p>
<p>s1：源是10.3，目标是10.2的且从端口1进来的，都转发到输出端口4</p>
<p>s2：目标是10.2.0.3且从端口2进来的，都转发到输出端口3</p>
<p>s2：目标是10.2.0.4且从端口2进来的，都转发到输出端口4</p>
</blockquote>
<p>match+action</p>
<ol>
<li><p>路由器</p>
<p>match：最长前缀匹配</p>
<p>action：选择某条链路转发</p>
</li>
<li><p>交换机</p>
<p>match：目标MAC地址</p>
<p>action：转发或者泛洪</p>
</li>
<li><p>防火墙</p>
<p>match：IP地址和TCP/UDP端口号</p>
<p>action：允许或者禁止</p>
</li>
<li><p>NAT</p>
<p>match：IP地址和端口号</p>
<p>action：替换IP地址和端口号</p>
</li>
</ol>
<h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>主要功能：路由，确定分组从源到目标的路径</p>
<p>路由实现方式：</p>
<ol>
<li>传统方式，每个路由器独立实现路由，分布式</li>
<li>SDN方式，逻辑上集中的控制器实现路由功能，集中式</li>
</ol>
<p>路由层次：</p>
<ol>
<li>内部网关协议</li>
<li>外部网关协议</li>
</ol>
<h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><p>理论上的路由实现</p>
<p><strong>路由</strong>：按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路（这里的节点应该是子网，以网络为单位进行路由）</p>
<ol>
<li><p>网络为单位进行路由，路由信息传输、计算和匹配的代价低</p>
</li>
<li><p>前提条件：一个网络所有节点地址前缀相同，且在物理上聚集</p>
</li>
<li><p>路由就是计算网络 到其他网络如何走的问题  </p>
</li>
<li><p>网络到网络其实就是网络对应的路由器到另一个网络对应的路由器</p>
<p>路由器之间的最优路径就是主机之间的最优路径</p>
<p>路由器连接子网内部所有主机，子网到路由器1跳，且必须要走</p>
</li>
</ol>
<ol>
<li><p>网络内部，路由器到主机的通信，由链路层解决</p>
<blockquote>
<p>到了这个路由器，相当于就到了这个网络，也就可以到了这个主机</p>
</blockquote>
</li>
</ol>
<p><strong>汇集树</strong>：此节点到所有其它节点的最优路径形成的树  </p>
<blockquote>
<p>路由选择算法就是需要所有路由器找到并使用汇集树</p>
</blockquote>
<p><img src="/posts/34443/image-20230530140433320.png" alt="image-20230530140433320"></p>
<p><strong>路由原则</strong></p>
<ol>
<li><strong>正确性(correctness)</strong>:算法必须是正确的和完整的，使分组一站一站接力，正确发向目标站：完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址</li>
<li><strong>简单性(simplicity)</strong>:算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量</li>
<li><strong>健壮性(robustness)</strong>:算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发送数据</li>
<li><strong>稳定性(stavility)</strong>:计算得到的路由不应该摇摆，一会这样走，一会那样走</li>
<li><strong>公平性(fairness)</strong>:对每一个站点都公平</li>
<li><strong>最优性(optimality)</strong>：某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ol>
<p><strong>路由算法分类</strong></p>
<p>全局 vs 局部</p>
<ul>
<li>全局：所有的路由器拥有完整的拓扑和边的代价的信息，link state算法</li>
<li>局部（分布式）：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值，迭代地与邻居交换路由信息、计算路由信息，distance vector算法</li>
</ul>
<p>动态 vs 静态</p>
<ul>
<li>静态：路由随时间变化缓慢  </li>
<li>动态：路由变化很快，周期性更新，根据链路代价的变化而变化</li>
</ul>
<p>自适应 vs 非自适应</p>
<ul>
<li>non-adaptive algorithm：不能适应网络拓扑和通信量的变化,路由表是事先计算好的</li>
<li>adaptive algorithm：能适应网络拓扑和通信量的变化</li>
</ul>
<h5 id="Link-State"><a href="#Link-State" class="headerlink" title="Link State"></a>Link State</h5><p>工作过程</p>
<ol>
<li><p>各个节点通过各种渠道（泛洪）获得整个网络拓扑,网络中所有链路代价等信息（这部分和算法没关系，属于协议和实现）</p>
<ol>
<li><p>发现相邻节点,获知对方网络地址</p>
<ul>
<li><p>路由器启动后，向所有输出链路发送HELLO分组</p>
</li>
<li><p>其他路由器收到了HELLP分组，返回应答，在应答分组中，告知自己的名字（全局唯一）</p>
<p>引入一个人工节点</p>
</li>
</ul>
</li>
<li><p>测量到相邻节点的代价(延迟,开销)</p>
<ul>
<li>实测法,发送一个分组要求对方立即响应</li>
<li>回送一个ECHO分组</li>
<li>通过测量时间可以估算出延迟情况</li>
</ul>
</li>
<li><p>组装一个LS分组,描述它到相邻节点的代价情况</p>
<ul>
<li>发送者名称 、序号、年龄</li>
<li>列表:给出它相邻节点,和它到相邻节点的延迟  </li>
</ul>
</li>
<li><p>将分组通过扩散的方法发到所有其它路由器</p>
<p>泛洪：有环→广播风暴</p>
<p>顺序号:用于控制无穷的扩散,每个路由器都记录(源路由器,顺序号),发现重复的或老的就不扩散</p>
<ol>
<li>如何循环使用顺序号</li>
<li>路由器崩溃之后序号从0开始</li>
<li>序号出现错误，咋办？</li>
</ol>
<p>年龄字段：</p>
<ul>
<li>生成一个分组时,年龄字段不为0</li>
<li>每隔一个时间段,AGE字段减1  </li>
<li>AGE字段为0的分组将被抛弃 </li>
</ul>
<p>扩散分组的数据结构：</p>
<p>Source :从哪个节点收到LS分组 </p>
<p>Seq,Age:序号,年龄 </p>
<p>Send flags:发送标记,必须向指定的哪些相邻站点转发LS分组 </p>
<p>ACK flags:本站点必须向哪些相邻站点发送应答 </p>
<p>DATA:来自source站点的LS分组</p>
</li>
</ol>
</li>
<li><p>使用<strong>LS路由算法</strong>,计算本站点到其它站点的最优路径(汇集树),得到路由表</p>
<ol>
<li>通过dijkstra算法寻找最短路径<ol>
<li>每个节点独立算出来到其他节点（路由器=网络）的最短路径</li>
<li>迭代算法：第k步能够知道本节点到k个其他节点的最短路径</li>
<li>将计算结果安装到路由表中</li>
</ol>
</li>
</ol>
<p><strong>震荡</strong>：链路代价如果设置为链路承载的流量，那么可能会由于链路的代价发生改变而频繁计算路由</p>
<p><img src="/posts/34443/image-20230530155404971.png" alt="image-20230530155404971"></p>
<p>比如C向A发送数据，一开始C到B到A，B觉得流量太多了，重新选路，C到D到A，这个时候D又流量太多了，又换路</p>
</li>
</ol>
<h5 id="Distance-Vector"><a href="#Distance-Vector" class="headerlink" title="Distance Vector"></a>Distance Vector</h5><p><strong>基本思想</strong></p>
<ol>
<li><p>每个路由器各自维护一张路由表</p>
<p>| to   | next | cost |<br>| —— | —— | —— |<br>| A    | Z    | 14   |</p>
<p>当前路由器想要到A，下一条要去Z，总代价是14</p>
</li>
<li><p>路由表与相邻路由表交换路由表</p>
</li>
<li><p>根据获得的路由表更新路由表</p>
</li>
</ol>
<p><strong>实现策略</strong></p>
<ol>
<li><p>代价及相邻节点间代价的获得</p>
<p>跳数(hops),延迟(delay),队列长度</p>
<p>相邻节点间代价的获得：通过实测  </p>
</li>
<li><p>路由信息的更新</p>
<ol>
<li>根据实测 得到本节点A到相邻站点的代价（如:延迟）  </li>
<li>根据各相邻站点声称它们到目标站点B的代价</li>
<li>计算出本站点A经过各相邻站点到目标站点B的代价</li>
<li>找到一个最小的代价，和相应的下一个节点Z，到达节点B经过此节点Z，并且代价为A-Z-B的代价</li>
</ol>
<p>其他所有的目标节点同样计算</p>
<p><img src="/posts/34443/image-20230530145923285.png" alt="image-20230530145923285"></p>
<p>绿色表示之前的最短路径，红色表示无效（自身到自身），更新的最短路径用黄色表示，灰色表示不是当前节点的邻居的节点</p>
<p><img src="/posts/34443/image-20230530150123232.png" alt="image-20230530150123232" style="zoom:150%;"></p>
<p>每个人都向邻居广播自己的路由表，A→<B,C>,B→<A,C>等等，根据邻居的路由表可以重新计算自己的路由表</A,C></B,C></p>
<p>比如A从C接到一个通告，C告诉A：C→D=5，A就更新A→D via C=23+5=<strong>28</strong>，同理A→B via C = 23+2=25</p>
<p>A→C via B = 3+2=<strong>5</strong></p>
<p>B→D via C = 2+5=<strong>7</strong></p>
<p>C→A via B = <strong>5</strong></p>
<p>D→A B via C=<strong>28 7</strong></p>
<p><img src="/posts/34443/image-20230530150600495.png" alt="image-20230530150600495"></p>
<p>B告诉A B到D的距离是7  A→D=3+7=10</p>
<p><img src="/posts/34443/image-20230530150645703.png" alt="image-20230530150645703"></p>
<p>A和D可以广播，但是没有产生更短路径，因此不更新路由表</p>
<p><img src="/posts/34443/image-20230530150819406.png" alt="image-20230530150819406"></p>
<p>现在没有一个路由器有任何新的最短广播路径，停止</p>
</li>
</ol>
<p><strong>路由更新</strong></p>
<ol>
<li>异步式,迭代: 每次本地迭代被以下事件触发:<ol>
<li>本地链路代价变化了</li>
<li>从邻居来了DV的更新消息</li>
</ol>
</li>
<li>分布式: 每个节点只是在自己的DV改变之后向邻居通告<ol>
<li>然后邻居们在有必要的时候通知他们的邻居</li>
</ol>
</li>
<li>每个节点：<ol>
<li>等待 (本地链路代价变化或者从邻居传送新的DV报文)  </li>
<li>重新计算各目标代价估计值 </li>
<li>如果到任何目标的DV发生变化,通告邻居 </li>
</ol>
</li>
</ol>
<p><strong>好消息传得快，坏消息传的慢</strong></p>
<p>好消息是指，抵达某个路由器有更短的路径了</p>
<p>好消息的传播以一个交换周期扩散一跳的速度进行</p>
<blockquote>
<p><img src="/posts/34443/image-20230530151915160.png" alt="image-20230530151915160"></p>
<p>A到B的最短路径变为1，下一次广播，到C的距离就变为2，依次进行下去</p>
</blockquote>
<p>坏消息是指，抵达某个路由器的路径变长了</p>
<p>坏消息的传播速度非常慢（无穷计算问题 count-to-infinity）</p>
<blockquote>
<p>图是这样的：A←1→B←1→C</p>
<p>假设现在A到B的链路不通了</p>
<ol>
<li><p>第一次交换之后, B从C处获得信息,C可以到达A(C-A,要经过B本身),但是路径是2,因此B变成3,从C处走 （B→<strong>C→B→A</strong>）=1+2=3</p>
<p>C误以为自己还能经过B到达A</p>
</li>
<li><p>第二次交换，C从B处获得消息，B可以到达A，路径为3，因此,C到A从B走,代价为3  （C→<strong>B→C→B→A</strong>）=4</p>
<p>B误以为自己还能经过C到达A</p>
</li>
<li><p>无数次交换之后，A到B的距离才会变成INF，不可达</p>
</li>
</ol>
</blockquote>
<p><strong>解决</strong></p>
<p>水平分裂（split horizon）算法</p>
<p>关公面前不耍大刀：<strong>任意节点</strong>不向<strong>自己的中转节点</strong>告知抵达某个<strong>中转节点的目标节点</strong>的距离（INF）</p>
<blockquote>
<p><img src="/posts/34443/image-20230530153841722.png" alt="image-20230530153841722"></p>
<ol>
<li>C知道要经过B才能到达A，所以C向B报告它到A的距离为INF；C告诉D它到A的真实距离</li>
<li>D告诉E,它到A的距离,但D告诉C它通向A的距离为INF</li>
<li>第一次交换: B通过测试发现到A的路径为INF,而C也告诉B到A的距离为INF,因此,B到A的距离为INF</li>
<li>第二次交换: C从B和D那里获知,到A的距离为INF,因此将它到A的距离为INF</li>
</ol>
</blockquote>
<p>坏消息以一次交换一个节点的速度传播 </p>
<p>但是如果链路存在环，依然会失败</p>
<p><img src="/posts/34443/image-20230530154219184.png" alt="image-20230530154219184"></p>
<blockquote>
<p>A,B到D的距离为2, C到D的距离为1</p>
<p>如果C-D路径失败</p>
<p>C获知到D为INF,从A,B获知到D的距离为INF,因此C认为D不可达</p>
<p>A从C获知D的距离为INF,但从B处获知它到D的距离为2,因此A到B的距离为3,从B走</p>
<p>B也有类似的问题</p>
<p>经过无限次之后,A和B都知道到D的距离为INF</p>
</blockquote>
<h5 id="LS-vs-DV"><a href="#LS-vs-DV" class="headerlink" title="LS vs DV"></a>LS vs DV</h5><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>LS</th>
<th>DV</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>消息复杂度</td>
<td>有n节点, E条链路,发送报文O(nE)个<br>局部的路由信息：全局传播</td>
<td>DV:只和邻居交换信息<br>全局的路由信息：局部传播</td>
<td>DV√</td>
</tr>
<tr>
<td>收敛时间</td>
<td>固定时间开销$n^2$，可能震荡</td>
<td>环路、无穷计算</td>
<td>LS√</td>
</tr>
<tr>
<td>健壮性</td>
<td>节点会通告不正确的链路代价<br>每个节点只计算自己的路由表<br>错误信息影响较小，局部，路由较健壮</td>
<td>DV节点可将不正确路径的代价通告给全网所有节<br>每一个节点的路由表可能被其它节点使用<br>错误可以扩散到全网</td>
<td>LS√</td>
</tr>
</tbody>
</table>
</div>
<h4 id="因特网中自治系统内部的路由选择"><a href="#因特网中自治系统内部的路由选择" class="headerlink" title="因特网中自治系统内部的路由选择"></a>因特网中自治系统内部的路由选择</h4><p>内部网关协议</p>
<h5 id="路由信息协议"><a href="#路由信息协议" class="headerlink" title="路由信息协议"></a>路由信息协议</h5><p>Routing Information Protocol，RIP适用于小网</p>
<p>基于DV算法实现，每条链路的代价为1，就是跳数，最大跳数为15，16表示不可达</p>
<p>DV每隔30s（对方请求通过，我就发送通过）和邻居交换DV，通告（advertisement  ），包括最多25个目标子网</p>
<p>如果180s没有收到通告信息：邻居或者链路失效</p>
<p>使用说水平分裂阻止无穷计算问题</p>
<p>基于UDP实现，以进程的方式实现网络层的功能，还借助传输层的协议</p>
<h5 id="开放最短路径优先"><a href="#开放最短路径优先" class="headerlink" title="开放最短路径优先"></a>开放最短路径优先</h5><p>Open Shortest Path First，OSPF</p>
<p>基于LS算法，LS分组在网络中分发，全局网络拓扑、代价都在任意节点内维护</p>
<p>路由计算采用dijkstra算法</p>
<p>在IP数据报上直接传输OSPF报文，无需借助UDP或者TCP</p>
<p>相较于RIP的改进</p>
<ol>
<li><p>安全：所有的OSPF报文都是经过认证的 (防止恶意的攻击)  </p>
</li>
<li><p>多路：允许有多个代价相同的路径存在 (在RIP协议中只有一个)  </p>
</li>
<li><p>多重代价矩阵：支持按照不同的代价计算最优路径</p>
</li>
<li><p>层次性OSPF</p>
<p><img src="/posts/34443/image-20230530161517779.png" alt="image-20230530161517779"></p>
</li>
</ol>
<p><strong>层次路由</strong></p>
<p>将互联网分成一个个路由器区域，自治系统（autonomous system，AS），用AS number表示</p>
<h4 id="因特网控制消息协议"><a href="#因特网控制消息协议" class="headerlink" title="因特网控制消息协议"></a>因特网控制消息协议</h4><p>Internet Control Message Protocol，ICMP</p>
<p>由主机、路由器、网关用于传达网络层控制信息</p>
<ol>
<li><p>差错报文</p>
<ol>
<li><p>终点不可达：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误</p>
</li>
<li><p>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</p>
<ol>
<li><p>超时：当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段的值减1。若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文。</p>
<p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超时报文。</p>
</li>
<li><p>参数问题：当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文</p>
<ol>
<li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>查询报文</p>
</li>
</ol>
<p>ICMP在网络层，但是在IP协议的上面，ICMP信息由IP数据报承载</p>
<p>ICMP报文包括类型和编码</p>
<p>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</p>
<p>在IPv6中，ICMP添加了新的控制信息，比如Packet Too Big</p>
<p><strong>基于ICMP的应用</strong></p>
<ol>
<li>ping：是否连通</li>
<li>traceroute：经过哪些路由器</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络重点知识解析-HTTP的发展和演变</title>
    <url>/posts/60485.html</url>
    <content><![CDATA[<h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h3><h4 id="HTTP是啥"><a href="#HTTP是啥" class="headerlink" title="HTTP是啥"></a>HTTP是啥</h4><p>超文本传输协议（HyperText Transfer Protocol，HTTP）</p>
<ul>
<li><strong>超文本</strong>：传输内容除了文本外，还包括图片、音频、视频、超链接等等</li>
<li><strong>传输</strong>：该协议的任务就是数据传输</li>
<li><strong>协议</strong>：通信双方想要交互需要遵循的约定和规范</li>
</ul>
<blockquote>
<p><strong>HTTP就是一种用于在网络的两个端点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p>
</blockquote>
<h4 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h4><p>五大类</p>
<ul>
<li>1xx：提示信息，基本用不到</li>
<li>2xx：成功，200就是最常见的成功状态，204则表示响应头没有body，206表示body的数据不完整</li>
<li>3xx：重定向，需要用新的url才能访问到，包括301(永久) | 302(临时) | 304(可以使用缓存资源)</li>
<li>4xx：客户端错误 | 无权限，请求报文有误，服务器无法处理，403(禁止客户端访问) | 404（请求的资源不存在）</li>
<li>5xx：服务端错误，501(服务器还没正式开放) | 502(网关) | 503(服务器繁忙)</li>
</ul>
<h4 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h4><p>Host字段：服务器域名</p>
<p>Content-length字段：数据长度，为了解决body内容的TCP半包和粘包问题[头部信息通过设置回车符、换行符来解决]</p>
<p>Connection字段：keep-alive表示连接模式是长连接</p>
<p>Content-type字段：数据格式和编码</p>
<p>Content-encoding字段：数据压缩格式</p>
<h4 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h4><p>GET指的是从服务器获取指定资源，资源标识一般是附加到url里，因为只是获取资源，所以不会对服务器的数据进行操作，本身就是幂等和安全的，同时可以用缓存进行优化</p>
<p>POST指的是根据body内容对指定资源做操作，数据一般就是放到body里面，POST会对服务器产生影响，本身不安全和非幂等的</p>
<p>实际上，GET和POST的上述区别只是一种规范，我们也可以在GET请求的body中携带数据，只是根据GET的规范，不需要用到body罢了，而POST也可以在url中携带参数的</p>
<h4 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h4><p>缓存的意思就是将服务端返回的数据在本地缓存下来，下次再访问时可以直接用，但是需要设置过期时间，没超时直接用本地缓存，超时就去问浏览器，是不是真的超时了，浏览器基于最后修改时间或者资源的唯一标识判断是否过期，没有过期返回304，客户端可以继续使用本地缓存；过期，返回200和新数据</p>
<h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><p>HTTP一般包括HTTP/1.0、HTTP/1.1、HTTP/2.0、HTTP/3.0</p>
<p>HTTP的特性基本在HTTP/1.1就比较完善了，后续HTTP/2.0和HTTP/3.0主要是优化性能</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p>HTTP报文就是head+body，head的内容也是key-value的形式，整体比较简单，利于理解</p>
</li>
<li><p>HTTP工作在浏览器上，天生具备跨平台的特性</p>
</li>
<li><p>HTTP工作在应用层，并且head字段非常灵活，所以可以很方便地对HTTP协议进行拓展</p>
<p>比如HTTPS引入TLS安全协议，实现加密传输</p>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><p>无状态，服务器不会保存HTTP连接的状态，虽然能够减轻服务器负担，但是使用很不方便，比如购物流程的每个阶段都得验证身份信息</p>
<p>通过客户端的Cookie和服务器的Session实现状态</p>
<p>简单来说，第一次访问时，服务器会捎带Cookie给客户端，客户端记录下来第二次访问携带上这个Cookie，服务器就知道是谁访问了</p>
</li>
<li><p>明文传输，HTTP传输的数据都是明文的，虽然方便调试，但是显然不安全</p>
<ol>
<li>内容可能被窃听</li>
<li>无法验证通信双方的身份</li>
<li>内容可能被篡改</li>
</ol>
</li>
</ol>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ol>
<li>长连接：HTTP/1.0时代一次请求对应一次TCP连接，频繁创建和销毁连接增加了无谓的通信开销，HTTP/1.1时代引入了长连接，实现多个请求工作在一个TCP连接上</li>
<li>管道传输：一个TCP连接上的多个请求可以连续发送出去，比如A和B请求，以前是A发出，得到响应，再发B，现在可以一起发</li>
<li>队头阻塞：虽然客户端可以连续发送多个请求，但是服务端处理请求还是一个一个处理的，所以如果处理前面的请求时间太久，就会发生队头阻塞</li>
</ol>
<h3 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h3><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul>
<li>HTTPS通过引入TLS安全协议，实现加密传输，解决了包括内容窃听、篡改、身份无法验证的安全问题</li>
<li>HTTPS由于引入TLS安全协议，所以连接建立过程比较复杂，除了TCP三次握手，还有TLS的握手</li>
<li>HTTP的默认端口是80，HTTPS则是443</li>
</ul>
<h4 id="HTTPS解决了哪些安全问题"><a href="#HTTPS解决了哪些安全问题" class="headerlink" title="HTTPS解决了哪些安全问题"></a>HTTPS解决了哪些安全问题</h4><ol>
<li><p><strong>窃听风险：内容被拦截</strong></p>
<p>结合对称加密和非对称加密的<strong>混合加密</strong>确保内容不会被窃听</p>
<p>对称加密就是通信双方都有公钥，公钥能加密和解密，但是公钥需要在网络上传输，存在被拦截的可能，无法解决窃听风险</p>
<p>非对称加密就是接收方拥有私钥，发送方申请公钥，用公钥加密，接收方用私钥解密，虽然可以防止窃听风险，但是计算开销太大</p>
<p><strong>所以现在用的就是混合加密，服务端先基于非对称加密给发送方发送公钥，发送方用这个公钥加密自己的对称公钥发给服务器，服务器用私钥解密得到对称公钥，后续通信基于对称公钥实现</strong></p>
</li>
<li><p><strong>篡改风险：客户收到的内容被篡改甚至替换</strong></p>
<p><strong>摘要算法+数字签名</strong>，其实就是服务端可以根据信息内容生成哈希值并用私钥加密生成数字签名，接收方自己根据内容计算哈希值并用公钥解密，再对比哈希值是否一致，就能避免篡改风险</p>
<p>首先，哈希值一致，能够避免内容被篡改，但是如果哈希值和内容都被替换了，那么就需要私钥加密哈希值了，因为第三方是没有私钥的，替换了内容和哈希值后，客户端无法用公钥解密，就能发现被替换了</p>
</li>
<li><p><strong>身份验证：客户无法保证自己访问的网页是官方的</strong></p>
<p><strong>数字证书</strong>，其实就是通过第三方机构证明服务器的身份，第三方机构发好人卡，浏览器能够识别好人卡就是官方服务器</p>
<p>具体来讲，官方服务器可以向数字证书机构注册自己的公钥，CA用自己的私钥加密并颁发数字证书，并且浏览器本身拥有对应的公钥可以解密</p>
<p>此时，某个服务器向客户端发送自己的公钥和数字证书，浏览器能够用CA的公钥解密说明是官方的服务器</p>
</li>
</ol>
<h4 id="HTTPS一定能够保证安全可靠吗"><a href="#HTTPS一定能够保证安全可靠吗" class="headerlink" title="HTTPS一定能够保证安全可靠吗"></a>HTTPS一定能够保证安全可靠吗</h4><p>理论上，只要我们操作是正常的，HTTPS就能保证安全可靠</p>
<p>那么什么是不正常的操作呢？就是比如说，有一个中间服务器拦截了我们的请求，伪装成我们向服务器发数据，这样当然就会造成不安全，但是发生这个问题的前提是我们接受了中间服务器发给我们的证书</p>
<p>实际上，浏览器会提示我们浏览的网站的安全证书存在问题，如果点击了&lt;继续浏览此网站&gt;，那么就可能被中间服务器拦截</p>
<p>此外，这种拦截模式也是抓包的工作原理，抓包根据自己签发证书，并且被浏览器信任</p>
<h3 id="HTTP演变"><a href="#HTTP演变" class="headerlink" title="HTTP演变"></a>HTTP演变</h3><h4 id="HTTP-1-0→HTTP-1-1"><a href="#HTTP-1-0→HTTP-1-1" class="headerlink" title="HTTP/1.0→HTTP/1.1"></a>HTTP/1.0→HTTP/1.1</h4><p>长连接：优化频繁创建和销毁TCP连接的开销</p>
<h4 id="HTTP-1-1→HTTP-2-0"><a href="#HTTP-1-1→HTTP-2-0" class="headerlink" title="HTTP/1.1→HTTP/2.0"></a>HTTP/1.1→HTTP/2.0</h4><div class="table-container">
<table>
<thead>
<tr>
<th>HTTP/1.1</th>
<th>HTTP/2.0</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>只能压缩body</td>
<td>进一步压缩head</td>
<td>减少数据传输量</td>
<td>多个请求头的重复部分会被消除</td>
</tr>
<tr>
<td>传输文本</td>
<td>传输二进制数据，并且常用、固定字段可以用静态表索引，索引的建立用哈夫曼编码，实现目标就是常用的字段索引小，不常用的索引大，当然，双方也可以协商建立动态表索引</td>
<td>二进制是计算机能够直接理解的数据格式，增加解析效率，并且能够减少数据传输量</td>
<td>如200本来需要三个字节分别表示2 0 0，但是现在可以直接用索引的二进制形式来代替，即10001000，节省了2个字节，第一个1是静态表，第二个1表示索引下标是8</td>
</tr>
<tr>
<td>响应的队头阻塞，服务端接收一个请求报文就处理一个，处理时间长，后续请求阻塞了</td>
<td>基于Stream实现并发传输，解决了响应的队头阻塞问题，不同Stream对应不同请求和响应，Stream的帧可以并发传输，接收方可以根据Stream ID组装成不同的HTTP报文</td>
<td>增加传输效率</td>
<td></td>
</tr>
<tr>
<td>请求啥，响应啥</td>
<td>服务器主动推送</td>
<td>减少请求次数</td>
<td>比如服务器直接把html和css都返回，不需要两次请求了</td>
</tr>
</tbody>
</table>
</div>
<h4 id="HTTP-2-0→HTTP-3-0"><a href="#HTTP-2-0→HTTP-3-0" class="headerlink" title="HTTP/2.0→HTTP/3.0"></a>HTTP/2.0→HTTP/3.0</h4><div class="table-container">
<table>
<thead>
<tr>
<th>HTTP/2.0</th>
<th>HTTP/3.0</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>即便使用了流传输，丢包时，TCP协议为了保证传输有序性所造成的阻塞没有解决</td>
<td>每个Stream拥有独立的缓冲区</td>
<td>丢包的流阻塞，其他流不受影响</td>
<td></td>
</tr>
<tr>
<td>基于四元组唯一标识一个连接，网络环境一变就得重新连接</td>
<td>通过新的连接ID标识一个连接</td>
<td>即便网络环境发生变化，也能够实现连接迁移，复用原始连接</td>
<td>比如从4G切换到Wifi，源IP地址自然发生了变化</td>
</tr>
</tbody>
</table>
</div>
<h3 id="HTTP-vs-RPC"><a href="#HTTP-vs-RPC" class="headerlink" title="HTTP vs RPC"></a>HTTP vs RPC</h3><p>HTTP叫超文本传输协议，就是浏览器浏览网页所用的协议</p>
<p>RPC叫做远程过程调用，听名字就知道其实不是协议，而是一种规范，RPC的目标就是使得开发人员调用远程服务器的方法时，能够像调用本地方法一样简单，不需要考虑底层的网络细节</p>
<p>实际上，是先有了RPC，后有HTTP的，因为RPC一般就是自家的软件和自己的服务器通信时需要用到，不需要考虑异构性，而HTTP则不一样，浏览器想要访问网页就需要和不同公司的服务器进行交互，这些服务器存在一定差异</p>
<p><strong>既然现在有了HTTP，HTTP理论上也能实现RPC的目标，为什么还要RPC呢？</strong></p>
<p>RPC不用考虑异构性，性能上有一定优势，但是HTTP/2.0在性能上优于RPC，所以不换是因为投入和回报不成正比吧，很多公司内部已经用了RPC很久了，换成HTTP/2.0也不会带来多大的性能提升和经济效益，还要投入一定的人力物力，得不偿失</p>
<h3 id="HTTP-vs-WebSocket"><a href="#HTTP-vs-WebSocket" class="headerlink" title="HTTP vs WebSocket"></a>HTTP vs WebSocket</h3><p>两者都是基于TCP协议的，TCP协议本身是支持全双工通信的，而HTTP实际上更偏向单工通信，请求一个响应一个，浏览网页没啥问题，但是一些需要服务器主动推送数据的应用就不太行了</p>
<p>虽然可以通过定时轮询的方式实现服务器主动推送，比如扫码，前端显示二维码后，浏览器不知道用户到底扫没扫，就需要定时去服务器询问，本质上还是客户端主动获取数据</p>
<p>这种方式对于频繁交互的场景就不太行了，比如网页游戏，因此，WebSocket应运而生，WebSocket赋予服务端主动发送数据的能力</p>
]]></content>
      <categories>
        <category>扩展学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科扩展知识</tag>
        <tag>待补充图片</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络重点知识解析-IP地址和MAC地址</title>
    <url>/posts/43112.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ol>
<li>为什么不能直接用MAC地址作为终点地址？反而需要引入IP地址，还要用APR协议得到MAC地址</li>
<li>为什么有了IP地址，还需要MAC地址来进行物理寻址</li>
</ol>
<h3 id="网络设计角度"><a href="#网络设计角度" class="headerlink" title="网络设计角度"></a>网络设计角度</h3><h4 id="两台主机"><a href="#两台主机" class="headerlink" title="两台主机"></a>两台主机</h4><p>假设只有两台主机A和B，A和B连一条线就完成了通信</p>
<p><img src="/posts/43112/image-20230828123103189.png" alt="image-20230828123103189"></p>
<h4 id="多台主机"><a href="#多台主机" class="headerlink" title="多台主机"></a>多台主机</h4><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><p>现在有很多台电脑需要通信，不可能两两互联，开销太大，所以就引出两个子问题</p>
<ol>
<li><strong>设备标识问题</strong>：主机怎么知道数据是不是发给自己的？给设备取名字——MAC地址，这是一个全局唯一的名字，这样数据包前面拼接上MAC地址，主机比对一下就知道自己是不是接收方了</li>
</ol>
<p><img src="/posts/43112/image-20230828124326881.png" alt="image-20230828124326881"></p>
<ol>
<li><strong>数据传输问题</strong>：不能两两互联，怎么传输给指定设备呢？引入了集线器，集线器就是把所有收到的信息都广播出去（集线器的功能就是转发，所以工作在物理层）</li>
</ol>
<p><img src="/posts/43112/image-20230828125009203.png" alt="image-20230828125009203"></p>
<h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p>集线器收到的每个数据包都得广播给子网内所有主机，影响性能，也不安全，所以就引入了更为智能的集线器——交换机（交换机多了一点智能，工作在数据链路层）</p>
<p><img src="/posts/43112/image-20230828125313538.png" alt="image-20230828125313538"></p>
<p>交换机怎么实现的定点传输呢？<strong>MAC地址表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MAC地址</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>aa-aa-aa-aa-aa-aa</td>
<td>1</td>
</tr>
<tr>
<td>MAC-B</td>
<td>2</td>
</tr>
<tr>
<td>MAC-C</td>
<td>3</td>
</tr>
<tr>
<td>MAC-D</td>
<td>4</td>
</tr>
<tr>
<td>MAC-E</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p>想要发给A，发现MAC地址表中有A的MAC地址表项，那就从端口1发出去</p>
<p>基于交换机互联的小范围的网络就叫<strong>以太网</strong></p>
<p>MAC地址表一开始肯定是空的，人为去设置也不可能，因此就需要自动进行设置</p>
<p>比如D的数据从端口4进来，那么可以先记录D的表项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MAC地址</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC-D</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>查找发现MAC地址表里没有A的表项，那就得广播，此时A就发现自己是目标主机，就会做出响应，交换机收到从端口1返回的数据，就添加A的表项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MAC地址</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>MAC-D</td>
<td>4</td>
</tr>
<tr>
<td>MAC-A</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>后面就可以正常发送数据了，不断重复上述过程，MAC地址表就能填充完毕</p>
<h4 id="多个子网"><a href="#多个子网" class="headerlink" title="多个子网"></a>多个子网</h4><h5 id="交换机互联"><a href="#交换机互联" class="headerlink" title="交换机互联"></a>交换机互联</h5><p><img src="/posts/43112/image-20230828130251441.png" alt="image-20230828130251441"></p>
<p>两个交换机都得记录A-F的所有映射关系，以太网规模小问题不大，一旦电脑数量过多，就无法支持了</p>
<p><strong>左边交换机的MAC地址表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MAC-A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">MAC-D</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">MAC-E</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">MAC-F</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">MAC-B</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">MAC-C</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</div>
<h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>问题的根本在于红色的线的两端不知道有多少设备需要连接进来，每个设备都会增加一个表项，设备数量一多就不行了，所以就引入了聚集操作</p>
<p>也就是说如果我们能够保证设备D、E、F的MAC前缀都是FFFF-FFFF且在互联的子网中保证唯一，那么就可以用一个表项表示所有设备</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MAC地址</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>FFFF-FFFF-XXXX-XXXX-XXXX-XXXX</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>问题在于MAC地址无法保证这样的特性，因为MAC地址是物理设备（端口）的唯一标识，是设备生产商生产设备时确定的，虽然设备生产商可以保证这样的特性，但是我们不可能所有设备都从一家生产商处购买，而且也徒增了设备配置的复杂性</p>
<p>因此，就引入了一种新的逻辑地址——IP地址以及为逻辑寻址服务的设备路由器（路由器基于IP地址做逻辑寻址，工作在网络层），IP地址是一个32位的编号，有了IP地址就可以做基于<strong>前缀的路由聚集</strong>，来减少表项的数量了，这个前缀实际上就叫子网地址，所以IP地址实际上由子网地址和主机地址构成，可以通过子网掩码+按位与操作进行计算。</p>
<p>有了IP地址，那么就可以实现“所有要发到192.168.0.xxx这个子网下任意设备的数据，都从端口1发出；所有要发到192.168.1.xxx这个子网下任意设备的数据，都从端口2发出”</p>
<p>同时传输过程中就得带上MAC地址和IP地址，IP地址一直不变，MAC地址逐跳变化</p>
<p><img src="/posts/43112/image-20230828132414969.png" alt="image-20230828132414969"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>为什么不能直接用MAC地址作为终点地址？反而需要引入IP地址，还要用APR协议得到MAC地址</strong></p>
<p>最初，以太网内部就是通过MAC地址区分不同设备的，但是随着网络设备越来越多，单纯用MAC地址来寻址会使得交换机的地址表过于臃肿，根本存储不下。因此就引入了子网的概念，把网络划分成不同的子网，数据传输先传到对方的子网，然后再传给目标主机。子网内部的所有设备有相同的子网地址和不同的主机地址，子网地址和主机地址合在一起就是IP地址，通过基于子网地址的路由聚集就可以显著压缩路由表大小。</p>
<p>实际上IP地址只是为了在路由表上做匹配，匹配后还得把IP映射为MAC地址，基于MAC才能完成相邻节点传输</p>
</li>
<li><p><strong>新的问题是既然有了IP地址，IP地址也能唯一标识一台主机，为什么不能完全取代MAC地址呢？</strong></p>
<p>这是因为IP地址是设备上线后，根据所在子网来分配的，那么设备还没有IP地址的时候，如何区分子网内的不同设备呢？所以分配IP地址的时候就需要MAC地址来区分不同设备</p>
</li>
<li><p><strong>如果子网内所有设备IP地址已经确定，能不能子网内部也用IP地址寻址呢？</strong></p>
<p>理论上可以，但是没有必要，因为子网内部的交换机已经具备了通过MAC地址找到目标主机的功能，何必多次一举再用IP地址寻址呢，这样还得给交换机增加网络层的功能，得不偿失，所以干脆所有相邻节点的转发都用MAC地址</p>
</li>
</ol>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><ol>
<li><p><strong>主机A向主机B发送数据，怎么知道需要通过路由器转发呢？</strong></p>
<p>通过子网掩码+按位与操作来计算主机A和B各自所在的子网</p>
<p>如果是一个子网，那么不需要通过路由器转发；否则，需要通过路由器转发</p>
</li>
<li><p><strong>主机A发送的数据如果要通过路由器转发，怎么知道发给哪个路由器呢？</strong></p>
<p>在主机A上配置好默认网关，默认网关就是往不同子网发数据的路由器</p>
</li>
<li><p><strong>路由器怎么知道要怎么转发呢？</strong></p>
<p>路由表其实就是IP地址版本的地址表，路由表需要通过路由算法进行计算和配置，包括链路状态算法和距离矢量算法，链路状态其实就是dijkstra算法，距离矢量则类似2-hop索引，迭代更新路由表项</p>
</li>
<li><p><strong>ARP协议怎么做得IP地址到MAC地址的映射？</strong></p>
<p>ARP协议会配置一个IP地址到MAC地址的ARP缓存表，这个表一开始是空的，比如主机A想要知道IP地址为192.168.0.1的主机B的MAC地址，就把这个IP地址带上广播一下，主机B收到请求后，就做出响应，A就可以更新自己的ARP缓存表，大家不断广播ARP请求，就可以指导子网内部设备IP地址到MAC地址的映射关系了。所以ARP协议本身工作在网络层</p>
</li>
</ol>
]]></content>
      <categories>
        <category>扩展学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科扩展知识</tag>
        <tag>待补充图片</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络重点知识解析-TCP/IP层次模型</title>
    <url>/posts/5743.html</url>
    <content><![CDATA[<h3 id="为什么需要引入协议？"><a href="#为什么需要引入协议？" class="headerlink" title="为什么需要引入协议？"></a>为什么需要引入协议？</h3><p>同一台设备的进程间通信有很多实现方式，包括（匿名）管道、共享内存、消息队列、信号、同步等，但是这些实现方式都是以同一个物理设备为前提，而针对位于不同设备的进程间的通信，就需要基于网络实现通信，受制于网络设备的异构性，需要兼容不同网络设备，这就是为什么需要协议，协议规定了不同网络设备之间通信的规则，包括数据格式、次序、动作等，遵循通信协议的设备之间才能正常交互</p>
<h3 id="为什么网络协议是分层的？"><a href="#为什么网络协议是分层的？" class="headerlink" title="为什么网络协议是分层的？"></a>为什么网络协议是分层的？</h3><p>分层使得高层的服务不需要关心下层协议的具体实现细节，屏蔽下层的差异，提供统一的接口，使不同的网络设备能够互相通信</p>
<h3 id="TCP-IP层次模型"><a href="#TCP-IP层次模型" class="headerlink" title="TCP/IP层次模型"></a>TCP/IP层次模型</h3><p>自顶向下依次是应用层、传输层、网络层、网络接口层</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>电脑、手机使用的各种软件都是在应用层实现的，应用层只需要借助传输层服务，为用户提供各种应用功能，包括HTTP、FTP、DNS、SMTP协议等</p>
<p>应用层只需要知道哪些数据需要被传输 | 收到传输层交付的数据应该怎么处理，然后数据传输任务就交给传输层了，不需要关心后续传输层怎么传的</p>
<p>应用层协议体现在需要在应用层数据前封装头部信息</p>
<p><img src="/posts/5743/image-20230827191913000.png" alt="image-20230827191913000"></p>
<p>此外，应用层工作在<strong>用户态</strong>，传输层及以下都工作在<strong>内核态</strong></p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层的功能在于建立进程粒度的逻辑通信关系，如果远端IP地址和端口号一致，那么本地进程间通过端口号进行区分</p>
<blockquote>
<p>80号端口用于Web服务器监听HTTP请求，而浏览器中的每个标签都是一个独立进程，操作系统会为其分配临时端口</p>
</blockquote>
<p>传输层包括两个传输协议，传输控制协议（Transmission Control Protocol，TCP）和用户数据报协议（User Datagram Protocol）</p>
<p>TCP在IP协议的基础上，引入了很多新的机制，比如流量控制、拥塞控制、超时重传，这些都是为了保证传输的可靠性。此外，传输层的数据包会进行分段，分段阈值叫TCP最大报文段长度（Maximum Segment Size，MSS），每一个分段叫TCP段，通过分段机制能够减少重传的代价，比如某个数据报是10MSS大小，如果不分段，数据丢失或者损坏，就需要重传10MSS的数据，而有了分段，就只用重传丢失或者损坏的TCP段。</p>
<p>UDP只是在IP协议的基础上增加了进程间的逻辑通信关系，只负责发数据，不保证数据传输的可靠性。相对来说，实时性更好，传输效率也高。</p>
<p>为了实现传输层的功能，需要在应用层数据的每一个TCP段前附加TCP头部</p>
<p><img src="/posts/5743/image-20230827194104215.png" alt="image-20230827194104215"></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层的功能在于建立主机层面的逻辑通信关系，具体包括两个任务，一个是如何区分主机，另外一个是如何发送数据。</p>
<p>要区分主机，自然先要编址，主机之间通过IP地址进行区分，IP地址32位分为网络号和主机号，利用子网掩码进行按位与计算就可以拆分出网络号和主机号，类似思想在Java线程池的实现中也有体现，线程池有一个原子性的32位状态量叫ctl，其中前3位表示线程池状态，后29位表示线程池中线程的数量，利用最大线程数与ctl做按位与就能得到当前线程数量，取反按位与可得到状态</p>
<blockquote>
<p> 实际上网络层是先根据网络号寻找设备所在子网，然后再在内部根据主机号匹配到MAC地址再寻找端主机</p>
</blockquote>
<p>如何发送数据呢？首先我们要明确，两台主机之间一般不是直连的，需要经过网关、路由器、交换机等众多设备，那抽象出来就是一种图结构。</p>
<p>因此，要发送数据就需要路由和转发功能，路由的意思就是基于路由选择算法在全局上告诉数据包要怎么走才能走到目的地，有了路径，在节点上，还需要局部的转发，所以转发就是根据路径选择一个端口把数据发送出去</p>
<blockquote>
<p>路由相当于导航，转发相当于下一个路口怎么转</p>
</blockquote>
<p>为了实现网络层的功能，就得继续封装IP头部，如果IP数据包超过最大传输单元（Maximum Transform Unit, MTU）那也得进行分片，实际上由于TCP协议已经进行了分片，所以在网络层针对TCP报文段是不会进行分片的，分片是针对UDP数据报的</p>
<p><img src="/posts/5743/image-20230827194140779.png" alt="image-20230827194140779"></p>
<h4 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h4><p>网络接口层的主要作用就是物理寻址，物理寻址依赖于网络上各接口唯一的MAC地址，实际上在数据包的传输过程中，源IP地址和目标IP地址是不会变的，但是源MAC地址和目标MAC地址则是随着一跳一跳传输不断变化的</p>
<p>因此，传输内容还需要封装上MAC头部，然后又封装了帧头和帧尾用于帧定界，帧头包括源和目标MAC地址、上一层的协议信息，帧尾包括差错控制信息，即循环冗余校验码</p>
<p><img src="/posts/5743/image-20230827195524872.png" alt="image-20230827195524872"></p>
]]></content>
      <categories>
        <category>扩展学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科扩展知识</tag>
        <tag>待补充图片</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络重点知识解析-优化HTTP/1.1的可行措施</title>
    <url>/posts/22398.html</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>避免发送HTTP请求——缓存</li>
<li>减少HTTP请求次数<ol>
<li>减少重定向查询次数</li>
<li>合并请求</li>
<li>延迟加载</li>
</ol>
</li>
<li>减少响应数据大小——压缩</li>
</ol>
<h3 id="避免发送HTTP请求"><a href="#避免发送HTTP请求" class="headerlink" title="避免发送HTTP请求"></a>避免发送HTTP请求</h3><p>可以设置本地缓存，通过超时时间和版本号来避免访问旧数据</p>
<p>具体来讲</p>
<ol>
<li>根据超时时间判断是否过期，没有过期直接用本地缓存，过期了转2</li>
<li>携带版本号访问服务器，服务器通过版本号看是否有修改<ol>
<li>没有修改返回缓存可用</li>
<li>修改了返回新的数据</li>
</ol>
</li>
</ol>
<h3 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h3><h4 id="减少重定向查询次数"><a href="#减少重定向查询次数" class="headerlink" title="减少重定向查询次数"></a>减少重定向查询次数</h4><p>针对浏览器-代理服务器-业务服务器这样的服务场景进行优化</p>
<ul>
<li><p>不需要重定向</p>
<p>浏览器→代理服务器→业务服务器→代理服务器→浏览器</p>
<p>共4次数据交互</p>
</li>
<li><p>发生了重定向</p>
<ul>
<li><p>如果不进行重定向优化，则需要多次重定向查询</p>
<ol>
<li>客户端用旧的url访问代理服务器</li>
<li>代理服务器也用旧的url访问业务服务器</li>
<li>业务服务器返回新的url</li>
<li>代理服务器返回新的url</li>
<li>客户端用新的url访问代理服务器</li>
<li>代理服务器用新的url访问业务服务器</li>
<li>业务服务器返回数据到代理服务器</li>
<li>代理服务器返回数据到浏览器</li>
</ol>
<p><strong>总共8次数据交互</strong></p>
</li>
<li><p>进行优化后，代理服务器负责重定向</p>
<ol>
<li>客户端用旧的url访问代理服务器</li>
<li>代理服务器发现资源失效，直接用新的url访问业务服务器</li>
<li>业务服务器返回数据到代理服务器</li>
<li>代理服务器返回数据到浏览器</li>
</ol>
<p><strong>总共4次数据交互</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h4><p>把多个小文件的访问请求合并为一个大的访问请求，比如我们可以在服务端将多个图片合并为一个图片，只需请求一次，客户端这边做图片分割即可</p>
<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>按需获取，比如一个网页很长，不需要打开网页的时候全部加载出来，而是等到用户浏览到下面时再加载</p>
]]></content>
      <categories>
        <category>扩展学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科扩展知识</tag>
        <tag>待补充图片</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络重点知识解析-输入URL后发生了什么</title>
    <url>/posts/37373.html</url>
    <content><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>浏览器浏览网页是基于应用层的HTTP协议来实现的，而HTTP协议基于传输层的TCP协议和网络层的IP协议来实现，同时还要借助数据链路层和物理层完成数据传输，因此浏览器发送请求到网页显示的过程实际上可以理解为数据包的封装、解封装和传输过程</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p><img src="/posts/37373/image-20230903192430612.png" alt="image-20230903192430612"></p>
<p>浏览器第一步要做的就是解析url，解析url需要知道</p>
<ol>
<li>采用什么协议 http | https | ftp</li>
<li>web服务器的域名是啥 www.baidu.com</li>
<li>需要访问的文件路径（可有可无，如果没有访问的就是默认文件，比如index.html | default.html）</li>
</ol>
<p><img src="/posts/37373/image-20230903192441088.png" alt="image-20230903192441088"></p>
<p>接下来就是构造HTTP请求报文了，其实就是封装请求报文的信息体，并添加http头部</p>
<p><img src="/posts/37373/image-20230827191913000-1693741086876-7.png" alt="image-20230827191913000"></p>
<p>HTTP报文格式如下</p>
<p><img src="/posts/37373/image-20230903193731565.png" alt="image-20230903193731565"></p>
<h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>我们现在只知道web服务器的域名<code>www\.server.com.</code>，还不知道真正的IP地址是啥，只通过域名是无法送达的，所以就需要DNS协议，即域名解析协议去查询域名所对应的IP地址，查询过程如下</p>
<ol>
<li>首先查浏览器缓存、主机缓存、hosts文件，如果都没有</li>
<li>就向本地DNS服务器发起DNS查询请求，本地DNS服务器也先查自己的缓存，也没有</li>
<li>那么就以本地DNS服务器为中心，依次问询根服务器[.]、顶级域服务器[.com | .cn]、权威服务器[server.com]，最后肯定可以在权威服务器查找到IP地址，因为权威服务器就是web服务器的原始出处</li>
</ol>
<p><img src="/posts/37373/image-20230903190945704.png" alt="image-20230903190945704"></p>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>现在有了IP地址了，我们还得区分不同进程并且能够保证可靠传输，这就需要TCP协议的帮助，比如浏览器的每一个标签页都是不同的进程，需要分配不同的端口号</p>
<p>而TCP进行数据传输前需要建立三次握手，并且TCP还会将过大的HTTP报文分成多个TCP段，每个TCP段都要添加头部</p>
<p><img src="/posts/37373/image-20230827194104215-1693741098133-9.png" alt="image-20230827194104215"></p>
<p>头部中包括源端口号、目标端口号以区分不同进程，还包括保证可靠传输的序号、确认序号、窗口大小等字段以及用于确定报文功能的状态位，ACK、FIN还是SYN等</p>
<p><img src="/posts/37373/image-20230903193449576.png" alt="image-20230903193449576"></p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>接下来到了IP协议，IP协议需要封装IP头部才知道要发到哪个子网，这个IP头部比较重要的信息就是源IP地址和DNS解析得到的目标IP地址，然后上层协议字段选择TCP-06</p>
<p><img src="/posts/37373/image-20230903194153224.png" alt="image-20230903194153224"></p>
<p>到这实际上数据包已经添加了IP头部、TCP头部和HTTP头部，从网络层面上来说已经可以进行传输了，但是从物理层面还不行</p>
<p><img src="/posts/37373/image-20230827194140779.png" alt="image-20230827194140779"></p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>物理层面，实际上就是在一个以太网内部的物理寻址是基于MAC地址的，所以最后还要封装源和目标的MAC地址以及上层协议</p>
<p><img src="/posts/37373/image-20230903194831435.png" alt="image-20230903194831435"></p>
<p>源MAC地址就是客户端的MAC地址，目标MAC地址就需要通过ARP协议以广播的形式来匹配<strong>网关</strong>的IP地址到MAC地址的映射关系了，当然一般是存储在本地的ARP缓存中的，不需要每次都广播，上层协议要么是0800IP协议，要么是0806ARP协议</p>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>封装帧定界符和差错检验[循环冗余校验码]</p>
<p><img src="/posts/37373/image-20230827195524872.png" alt="image-20230827195524872"></p>
<h4 id="交换机-基于MAC寻址"><a href="#交换机-基于MAC寻址" class="headerlink" title="交换机[基于MAC寻址]"></a>交换机[基于MAC寻址]</h4><p>交换机就是连接以太网内所有设备的网络设备，交换机工作在数据链路层，可以基于MAC地址实现定向传输数据</p>
<h4 id="网关-基于MAC和IP寻址"><a href="#网关-基于MAC和IP寻址" class="headerlink" title="网关[基于MAC和IP寻址]"></a>网关[基于MAC和IP寻址]</h4><p>网关，就是以太网的大门，本质上也是一种路由器，MAC地址保证可以在以太网内部通信，IP地址保证基于路由表可以把数据转发到不同子网</p>
<p>基于FCS进行差错检验，然后把MAC解析出来，验证是否匹配，再检查IP，用IP去查路由表看到底从哪个端口出去</p>
<ul>
<li>如果网关字段是IP地址，则说明还未抵达目标子网，需要继续借助路由器转发</li>
<li>如果网关字段是空，这说明已经抵达目标子网，后续就是基于MAC地址做以太网内部转发</li>
</ul>
<p><img src="/posts/37373/image-20230903201539921.png" alt="image-20230903201539921"></p>
<p>实际上，旧的MAC会被丢掉，然后封装新的源MAC和目标MAC</p>
<h4 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h4><p>子网内部，交换机，只要解析到MAC地址，看是否匹配</p>
<p>子网间，路由器，解析MAC地址和IP地址，看是否匹配</p>
<p><strong>传输过程的MAC地址是逐跳变化的，相邻节点之间用的是MAC地址，而IP地址是始终不变的，起到的是导航作用，最后抵达目标服务器</strong></p>
<h3 id="解封装"><a href="#解封装" class="headerlink" title="解封装"></a>解封装</h3><p>服务器需要做的就是层层解封，检验MAC地址是否匹配、IP地址是否匹配、查看是TCP协议还是UDP协议、如果是TCP还得看序号并且查看目标端口号是否有进程监听，这里HTTP服务器正在监听，发现这个请求是要访问某个网页，就打包这个网页为HTTP响应报文，返回给客户端，客户端收到后也是层层解封，然后把响应报文取出来交给浏览器渲染，网页就显示出来了</p>
]]></content>
      <categories>
        <category>扩展学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学科扩展知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat了解</title>
    <url>/posts/17791.html</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="Tomcat是什么"><a href="#Tomcat是什么" class="headerlink" title="Tomcat是什么"></a>Tomcat是什么</h2><p>我们开发的<code>App</code>后端需要部署到服务器上才能运行，而服务器需要配置必要的环境才能支持<code>App</code>的运行，比如一个<code>java</code>程序，需要配置<code>JRE</code>环境和<code>Tomcat</code>（<code>java</code>实现的服务器软件，运行在<code>JRE</code>环境中，专门用于运行<code>web</code>应用程序），相当于是由<code>Tomcat</code>来运行<code>java</code>程序</p>
<p>简单理解：<code>JRE</code>是靶场，<code>Tomcat</code>是枪，我们的<code>App</code>是子弹</p>
<p>类似的服务器软件还包括<code>Jetty</code>、<code>JBoss</code>、<code>Resin</code>等等，<code>Tomcat</code>应用最为广泛，技术先进、性能稳定、项目开源还免费</p>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p><a href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a></p>
<p><img src="/posts/17791/image-20240124151921260.png" alt="image-20240124151921260"></p>
<p><strong>导包问题</strong></p>
<blockquote>
<p>Users of Tomcat 10 onwards should be aware that, as a result of the move from Java EE to Jakarta EE as part of the transfer of Java EE to the Eclipse Foundation, the primary package for all implemented APIs has changed from <strong><code>javax.*</code> to <code>jakarta.*</code></strong>. This will almost certainly require code changes to enable applications to migrate from Tomcat 9 and earlier to Tomcat 10 and later. A <a href="https://github.com/apache/tomcat-jakartaee-migration">migration tool</a> has been developed to aid this process.</p>
</blockquote>
<p><strong>版本匹配问题</strong></p>
<p><img src="/posts/17791/image-20240124152647022.png" alt="image-20240124152647022"></p>
<p><strong>下载包</strong></p>
<p><img src="/posts/17791/image-20240124152834182.png" alt="image-20240124152834182"></p>
<p><strong>配置环境变量</strong></p>
<ol>
<li><p>需要保证电脑已经配置好<code>JAVA_HOME</code>[系统变量以及<code>Path</code>]，注意用户变量有可能覆盖系统变量，<code>java -version</code>验证是否配置成果</p>
<p><img src="/posts/17791/image-20240124153500312.png" alt="image-20240124153500312" style="zoom: 25%;"><img src="/posts/17791/image-20240124153649884.png" alt="image-20240124153649884" style="zoom:25%;"><img src="/posts/17791/image-20240124153857562.png" alt="image-20240124153857562" style="zoom:25%;"></p>
</li>
<li><p>解压压缩包到合适的目录</p>
</li>
<li><p>打印日志中文原本是乱码，这是因为默认使用<code>UTF-8</code>打印日志，应该在<code>conf/logging.properties</code>中将<code>java.util.logging.ConsoleHandler.encoding</code>修改为<code>GBK</code></p>
</li>
<li><p>双击<code>bin/startup.bat</code>启动<code>Tomcat</code>[点击<code>shutdown.bat</code>或者直接关闭<code>cmd</code>就关闭了]，检查输出指令没有异常，打开本地<code>8080</code>端口</p>
<p><img src="/posts/17791/image-20240124155257572.png" alt="image-20240124155257572" style="zoom: 25%;"><img src="/posts/17791/image-20240124154954905.png" alt="image-20240124154954905" style="zoom: 25%;"></p>
</li>
<li><p>配置系统变量[没有必要配置，因为一台机器可能会部署多个<code>Tomcat</code>版本，后续可以关联到<code>IDEA</code>，如果配置了该环境变量，那么即便打开的是其他版本的<code>startup.bat</code>，启动的也是环境变量的版本，但是如果部署到<code>Linux</code>服务器上时就需要配置环境变量了]</p>
<p><img src="/posts/17791/image-20240124155911292.png" alt="image-20240124155855309" style="zoom: 25%;"><img src="/posts/17791/image-20240124155921261.png" alt="image-20240124155921261" style="zoom: 25%;"></p>
</li>
<li><p>验证是否配置成功，直接<code>cmd</code>输入<code>startup.bat</code>能够运行成果</p>
</li>
</ol>
<p><img src="/posts/17791/image-20240124160408166.png" alt="image-20240124160408166"></p>
<h2 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h2><ul>
<li><p><code>bin</code>：该目录下存放的是二进制可执行文件。如果是安装版，那么这个目录下会有两个<code>exe</code>文件：<code>tomcat10.exe</code>、<code>tomcat10w.exe</code>，前者是在控制台下启动<code>Tomcat</code>，后者是弹出<code>GUI</code>窗口启动<code>Tomcat</code>；如果是解压版，那么会有<code>startup.bat</code>和<code>shutdown.bat</code>文件，<code>startup.bat</code>用来启动<code>Tomcat</code>，但需要先配置<code>JAVA_HOME</code>环境变量才能启动，<code>shutdown.bat</code>用来停止<code>Tomcat</code>；</p>
</li>
<li><p><code>conf</code>：配置目录，用于配置<code>Tomcat</code>的相关信息</p>
<ul>
<li><p><code>server.xml</code>：配置整个服务器信息，包括修改端口号[默认8080]</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">maxParameterCount</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">               /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>logging.properties</code>：配置打印日志的行为</p>
</li>
<li><p><code>tomcat-users.xml</code>：后台管理需要配置账号密码</p>
</li>
<li><p><code>web.xml</code>：控制所部署项目的公共属性</p>
</li>
<li><p><code>Catalina</code>：引擎相关的配置</p>
</li>
</ul>
</li>
<li><p><code>lib</code>：<code>Tomcat</code>的类库，<code>web</code>项目所导入的<strong>公共</strong><code>jar</code>包也可以放到<code>lib</code>里</p>
</li>
<li><p><code>logs</code>：记录日志，以文件的形式存储，包括<code>cmd</code>的输出、访问请求历史记录，可以定期清理</p>
</li>
<li><p><code>temp</code>：临时文件</p>
</li>
<li><p><strong><code>webapps</code></strong>：存放<code>web</code>项目的文件夹，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是<code>Tomcat</code>自带的项目。其中<code>ROOT</code>是一个特殊的项目，在地址栏中访问<a href="http://127.0.0.1:8080，没有给出项目目录时，对应的就是`ROOT`项目。如果访问http://localhost:8080/examples，就会进入示例项目。其中`examples`就是项目名，即文件夹的名字">http://127.0.0.1:8080，没有给出项目目录时，对应的就是`ROOT`项目。如果访问http://localhost:8080/examples，就会进入示例项目。其中`examples`就是项目名，即文件夹的名字</a></p>
</li>
</ul>
<p><img src="/posts/17791/image-20240124163451368.png" alt="image-20240124163451368" style="zoom:25%;"></p>
<ul>
<li><code>work</code>：运行时生成的文件，与<code>JSP</code>密切相关，现在基本用不到了，最终运行的文件都在这里。通过<code>webapps</code>中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成<code>work</code>目录。当客户端用户访问一个<code>JSP</code>文件时，<code>Tomcat</code>会通过<code>JSP</code>生成<code>Java</code>文件，然后再编译<code>Java</code>文件生成<code>class</code>文件，生成的<code>java</code>和<code>class</code>文件都会存放到这个目录下。</li>
<li><code>LICENSE</code>：许可证</li>
<li><code>NOTICE</code>：说明文件</li>
</ul>
<h2 id="web应用的标准结构"><a href="#web应用的标准结构" class="headerlink" title="web应用的标准结构"></a>web应用的标准结构</h2><p>一个可以用于发布的标准<code>Web</code>项目的结构如下：</p>
<ul>
<li><p><code>app</code></p>
<ul>
<li><p><code>static</code><strong>[比较随意]</strong></p>
<ul>
<li><code>css</code></li>
<li><code>img</code></li>
<li><code>js</code></li>
</ul>
</li>
<li><p><code>WEB-INF</code>：该目录下的资源是受保护的，不可通过浏览器或者客户端直接访问<strong>[强制约束]</strong></p>
<p>  <img src="/posts/17791/image-20240124164956183.png" alt="image-20240124164956183"></p>
<ul>
<li><p><code>classes</code>：字节码根路径，<code>java</code>代码经过编译得到的<code>.class</code>文件就存放在这里</p>
</li>
<li><p><code>lib</code>：导入的第三方依赖<code>jar</code>包，比如连接数据库的<code>MySQL</code>驱动包</p>
<p>  <code>web.xml</code>：当前项目的配置文件</p>
<p><code>index.html</code>：主页文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="部署项目方式"><a href="#部署项目方式" class="headerlink" title="部署项目方式"></a>部署项目方式</h2><ol>
<li>直接部署：直接将编译好的项目放在<code>webapp</code>目录下</li>
<li>war包部署：将编译好的项目打成<code>war</code>包放在<code>webapps</code>目录下，<code>Tomcat</code>启动后会自动解压<code>war</code>包（和第一种一样）</li>
<li>映射部署：可以将项目放在非<code>webapps</code>的其他目录下，在<code>tomcat</code>中通过配置文件指向<code>app</code>的实际磁盘路径</li>
</ol>
<p><strong>映射部署</strong></p>
<p>只需要在<code>conf/Catalina/localhost</code>目录下创建一个<code>examples.xml</code>文件[和项目同名，三个名称保持一致]</p>
<p><img src="/posts/17791/image-20240124171430036.png" alt="image-20240124171430036"></p>
<p>日志证明使用了映射部署方式</p>
<p><img src="/posts/17791/image-20240124171730103.png" alt="image-20240124171730103" style="zoom:25%;"></p>
<p><code>url</code>的组成部分和项目种资源的对应关系图</p>
<p><img src="/posts/17791/image-20240124172115353.png" alt="image-20240124172115353" style="zoom:25%;"></p>
<ol>
<li><p>资源路径不一定完全等同于项目中的资源</p>
</li>
<li><p><code>ROOT</code>项目不需要上下文，直接跟资源路径即可</p>
</li>
<li><p><code>manager</code>和<code>host-manager</code>项目需要输入账号和密码，通过<code>conf/tomcat-users.xml</code>进行配置</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tomcat.apache.org/xml&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;robot&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="IDEA关联Tomcat"><a href="#IDEA关联Tomcat" class="headerlink" title="IDEA关联Tomcat"></a>IDEA关联Tomcat</h2><p><code>javaweb</code>工程（包括<code>html</code>、<code>css</code>、<code>js</code>、<code>.java</code>、<code>lib</code>、<code>web.xml</code>等文件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    javaweb工程--&gt;|构建|App--&gt;|部署|Tomcat中的webApp;</span><br></pre></td></tr></table></figure>
<p>上述过程均可以使用<code>IDEA</code>进行实现</p>
<ol>
<li><p>建立<code>IDEA</code>和<code>Tomcat</code>的关联（可以关联多个，开发时可选）</p>
<p> <img src="/posts/17791/image-20240125165751241.png" alt="image-20240125165751241" style="zoom:25%;"></p>
</li>
<li><p>创建一个<code>javaweb</code>工程</p>
<ol>
<li><p>创建<code>web-all</code>文件夹用于管理所有<code>web</code>项目</p>
</li>
<li><p>用<code>IDEA</code>打开该文件夹，将其转化为工作目录，并进行初始设置，包括SDK、语言级别、输出文件夹等</p>
<p> <img src="/posts/17791/image-20240125170341590.png" alt="image-20240125170341590" style="zoom:25%;"></p>
</li>
</ol>
</li>
<li><p>创建项目</p>
<ol>
<li><p>创建项目</p>
<p><img src="/posts/17791/image-20240125170435272.png" alt="image-20240125170435272" style="zoom:25%;"></p>
<p>用模块创建项目，能够避免多个项目频繁切换</p>
</li>
<li><p>转化为<code>web</code>项目</p>
<p><img src="/posts/17791/image-20240125170917030.png" alt="image-20240125170917030" style="zoom:25%;"><img src="/posts/17791/image-20240125171041454.png" alt="image-20240125171041454" style="zoom: 25%;"></p>
<p>添加<code>Tomcat</code>依赖</p>
<p><img src="/posts/17791/image-20240125170731759.png" alt="image-20240125170731759" style="zoom:25%;"><img src="/posts/17791/image-20240125171236130.png" alt="image-20240125171236130" style="zoom:25%;"></p>
<p>初始化工程目录（右键“将目录标记为” “添加为库” 或者 ）</p>
<p><img src="/posts/17791/image-20240125173409458.png" alt="image-20240125173409458" style="zoom:25%;"></p>
</li>
</ol>
</li>
<li><p>将工程构建成一个可以发布的<code>App</code></p>
<p> <img src="/posts/17791/image-20240125173553791.png" alt="image-20240125173553791" style="zoom:25%;"><img src="/posts/17791/image-20240125173602332.png" alt="image-20240125173602332" style="zoom:25%;"><img src="/posts/17791/image-20240125174050855.png" alt="image-20240125174050855" style="zoom:25%;"></p>
<p> 因为<code>static</code>文件夹中没有有效的文件，所以构建后抛弃了该文件夹</p>
<p> <code>classes</code>就是前面的<code>src</code>和<code>resources</code>编译后合并得到的字节码</p>
</li>
<li><p>将<code>App</code>部署到<code>Tomcat</code>中，启动运行</p>
<p> 添加<code>Tomcat</code>运行配置</p>
<p> <img src="/posts/17791/image-20240125174330418.png" alt="image-20240125174330418"><img src="/posts/17791/image-20240125174444197.png" alt="image-20240125174444197" style="zoom:25%;"><img src="/posts/17791/image-20240125174514355.png" alt="image-20240125174514355" style="zoom:25%;"><img src="/posts/17791/image-20240125174541285.png" alt="image-20240125174541285" style="zoom:25%;"></p>
<p> 实际运行</p>
<p> <img src="/posts/17791/image-20240125174723476.png" alt="image-20240125174723476"></p>
<p> 两种输出日志，服务器日志正常，但是Tomcat Catalina日志乱码</p>
<p> <img src="/posts/17791/image-20240125175016739.png" alt="image-20240125175016739" style="zoom:25%;"></p>
<p> 在<a href="Tomcat/conf">Tomcat/conf</a>中的<code>logging.properties</code>将<code>1catalina.org.apache.juli.AsyncFileHandler.encoding</code>修改为<code>GBK</code>，原本是<code>UTF-8</code></p>
<p> <img src="/posts/17791/image-20240125175226246.png" alt="image-20240125175226246" style="zoom:25%;"></p>
</li>
</ol>
<blockquote>
<p>实际上不需要构建输出到<code>out</code>也可以直接运行，<code>IDEA</code>的部署原理实际上就是对<code>Tomcat</code>进行一次拷贝，然后在副本中进行部署，而副本中存放仅仅和需要部署的项目相关的配置文件，实际的运行是用原本的<code>Tomcat</code>软件使用副本的配置文件来运行<code>javaweb</code>项目</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-行为模式</title>
    <url>/posts/23570.html</url>
    <content><![CDATA[<h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><p>行为模式包括以下几种具体模式：</p>
<ul>
<li>责任链（Chain of Responsibility）：允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。  </li>
<li>命令（Command）：它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。</li>
<li>迭代器（Iterator）：让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素</li>
<li>中介者（Mediator）：能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。</li>
<li>备忘录（Memento）：允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。  </li>
<li>观察者（Observer）：允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象</li>
<li>状态（State）：让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。  </li>
<li>策略（Strategy）：能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换</li>
<li>模板方法（Template Method）：在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤</li>
<li>访问者（Visitor）：将算法与其所作用的对象隔离开来</li>
</ul>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><blockquote>
<p>职责链模式、命令链、CoR、Chain of Command、Chain of Responsibility</p>
</blockquote>
<p>责任链是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设需要开发一个在线订购系统，希望对系统访问进行限制，只允许认证用户创建订单。此外，拥有管理权限的用户也拥有所有订单的完全访问权限。<br>简单规划后，你会意识到这些检查必须依次进行。只要接收到包含用户凭据的请求，应用程序就可尝试对进入系统的用户进行认证。 但如果由于用户凭据不正确而导致认证失败，那就没有必要进行后续检查了。</p>
<p><img src="/posts/23570/image-20240410190903638.png" alt="image-20240410190903638" style="zoom: 33%;"></p>
<p>后续有新增了如下功能：</p>
<ol>
<li>直接将原始数据传递给订购系统存在安全隐患。因此你新增了额外的验证步骤来清理请求中的数据。</li>
<li>系统无法抵御暴力密码破解方式的攻击。为了防范这种情况，你立刻添加了一个检查步骤来过滤来自同一 IP 地址的重复错误请求</li>
<li>对包含同样数据的重复请求返回缓存中的结果，从而提高系统响应速度。因此，你新增了一个检查步骤，确保只有没有满足条件的缓存结果时，请求才能通过并被发送给系统</li>
</ol>
<p><img src="/posts/23570/image-20240410191212009.png" alt="image-20240410191212009" style="zoom: 33%;"></p>
<p>检查代码本来就已经混乱不堪，而每次新增功能都会使其更加臃肿。修改某个检查步骤有时会影响其他的检查步骤。最糟糕的是，当你希望复用这些检查步骤来保护其他系统组件时，你只能复制部分代码，因为这些组件只需部分而非全部的检查步骤</p>
<p>系统会变得让人非常费解，而且其维护成本也会激增。你在艰难地和这些代码共处一段时间后，有一天终于决定对整个系统进行重构</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>责任链会将特定行为转换为被称作处理者的独立对象。在上述示例中，每个检查步骤都可被抽取为仅有单个方法的类，并执行检查操作。请求及其数据则会被作为参数传递给该方法。</p>
<p>责任链模式建议将这些处理者连成一条链。链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。除了处理请求外，处理者还负责沿着链传递请求。请求会在链上移动，直至所有处理者都有机会对其进行处理。</p>
<p>最重要的是：处理者可以决定不再沿着链传递请求，这可高效地取消所有后续处理步骤。</p>
<p>在订购系统示例中，处理者会在进行请求处理工作后决定是否继续沿着链传递请求。如果请求中包含正确的数据，所有处理者都将执行自己的主要行为，无论该行为是身份验证还是数据缓存。</p>
<p><img src="/posts/23570/image-20240410191935810.png" alt="image-20240410191935810" style="zoom: 33%;"></p>
<p>不过还有一种稍微不同的方式（也是更经典一种），那就是处理者接收到请求后自行决定是否能够对其进行处理。如果自己能够处理，处理者就不再继续传递请求。因此在这种情况下，每个请求要么最多有一个处理者对其进行处理，要么没有任何处理者对其进行处理。在处理图形用户界面元素栈中的事件时，这种方式非常常见。</p>
<p>例如，当用户点击按钮时，按钮产生的事件将沿着GUI元素链进行传递，最开始是按钮的容器（如窗体或面板），直至应用程序主窗口。链上第一个能处理该事件的元素会对其进行处理。此外，该例还有另一个值得我们关注的地方：它表明我们总能从对象树中抽取出链来。</p>
<p><img src="/posts/23570/image-20240410192324723.png" alt="image-20240410192324723" style="zoom:33%;"></p>
<p>所有处理者类均实现同一接口是关键所在。每个具体处理者仅关心下一个包含 execute 执行 方法的处理者。 这样一来，你就可以在运行时使用不同的处理者来创建链，而无需将相关代码与处理者的具体类进行耦合。  </p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240410192410454.png" alt="image-20240410192410454" style="zoom:33%;"></p>
<ol>
<li><p>处理者（<code>Handler</code>）声明了所有具体处理者的通用接口。该接口通常仅包含单个方法用于请求处理，但有时其还会包含一个设置链上下个处理者的方法。</p>
</li>
<li><p>基础处理者（<code>Base Handler</code>）是一个可选的类，你可以将所有处理者共用的样本代码放置在其中</p>
<p>通常情况下，该类中定义了一个保存下个处理者引用的成员变量。客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。该类还可以实现默认的处理行为：确定下个处理者存在后再将请求传递给它  </p>
</li>
<li><p>具体处理者（<code>Concrete Handlers</code>）包含处理请求的实际代码。每个处理者接收到请求后，都必须决定是否进行处理，以及<br>是否沿着链传递请求</p>
<p>处理者通常是独立且不可变的，需要通过构造函数一次性地获得所有必要的数据</p>
</li>
<li><p>客户端（<code>Client</code>）可根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非<br>必须是第一个处理者</p>
</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>责任链模式负责为活动的GUI元素显示上下文帮助信息</p>
<p><img src="/posts/23570/image-20240410192736440.png" alt="image-20240410192736440" style="zoom:33%;"></p>
<p>应用程序的GUI通常为对象树结构。 例如， 负责渲染程序主窗口的 对话框 类就是对象树的根节点。 对话框包含面板 ，而面板可能包含其他面板，或是 按钮 和 文本框等下层元素  </p>
<p><img src="/posts/23570/image-20240410193119506.png" alt="image-20240410193119506" style="zoom:33%;"></p>
<p>只要给一个简单的组件指定帮助文本，它就可显示简短的上下文提示。但更复杂的组件可自定义上下文帮助文本的显示方式，例如显示手册摘录内容或在浏览器中打开一个网页</p>
<p>当用户将鼠标指针移动到某个元素并按下 F1 键时，程序检测到指针下的组件并对其发送帮助请求。该请求不断向上传递到该元素所有的容器，直至某个元素能够显示帮助信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">implements</span> <span class="title class_">ComponentWithContextualHelp</span> is</span><br><span class="line">	field tooltipText: string</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 组件容器在处理者链中作为“下一个”链接</span></span><br><span class="line">	<span class="keyword">protected</span> field container: Container</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果组件设定了帮助文字，那它将会显示提示信息。如果组件没有帮助文字且其容器存在，那它会将调用传递给容器。</span></span><br><span class="line">	method <span class="title function_">showHelp</span><span class="params">()</span> is</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">if</span> <span class="params">(tooltipText != <span class="literal">null</span>)</span></span><br><span class="line">		<span class="comment">// 显示提示信息。</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	container.showHelp()</span><br><span class="line">  	</span><br><span class="line"><span class="comment">// 容器可以将简单组件和其他容器作为其子项目。链关系将在这里建立。该类将从其父类处继承showHelp（显示帮助）的行为。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Container</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">	<span class="keyword">protected</span> field children: array of Component</span><br><span class="line">	method <span class="title function_">add</span><span class="params">(child)</span> is</span><br><span class="line">		children.add(child)</span><br><span class="line">		child.container = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始组件应该能够使用帮助操作的默认实现..</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_">Component</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">但复杂组件可能会对默认实现进行重写。如果无法以新的方式来提供帮助文字，那组件总是还能调用基础实现的（参见Component类）。<span class="keyword">class</span> <span class="title class_">Panel</span> <span class="keyword">extends</span> <span class="title class_">Container</span> is</span><br><span class="line">	field modalHelpText: string</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">showHelp</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(modalHelpText != <span class="literal">null</span>)</span></span><br><span class="line">			<span class="comment">//显示包含帮助文字的模态窗口。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	Super.showHelp()</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line"><span class="comment">//...同上...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> <span class="keyword">extends</span> <span class="title class_">Container</span> is</span><br><span class="line">	field wikiPageURL: String</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">showHelp</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(wikiPageURL != <span class="literal">null</span>)</span></span><br><span class="line">			<span class="comment">//打开百科帮助页面。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	Super.showHelp()</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line"><span class="comment">//客户端代码。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">	<span class="comment">//每个程序都能以不同方式对链进行配置。</span></span><br><span class="line">	method <span class="title function_">createUI</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(<span class="string">&quot;预算报告&quot;</span>)</span><br><span class="line">		dialog.wikiPageURL = <span class="string">&quot;http://...&quot;</span></span><br><span class="line">		panel = <span class="keyword">new</span> <span class="title class_">Panel</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">800</span>)</span><br><span class="line">		panel.modalHelpText=<span class="string">&quot;本面板用于...&quot;</span></span><br><span class="line">		ok=<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="number">250</span>，<span class="number">760</span>，<span class="number">50</span>，<span class="number">20</span>，“确认<span class="string">&quot;)</span></span><br><span class="line"><span class="string">		ok.tooltipText=&quot;</span>这是一个确认按钮...<span class="string">&quot;</span></span><br><span class="line"><span class="string">		cancel=newButton（320，760，50，20，&quot;</span>取消<span class="string">&quot;)</span></span><br><span class="line"><span class="string">		panel.add(ok)</span></span><br><span class="line"><span class="string">		panel.add(cancel)</span></span><br><span class="line"><span class="string">		dialog.add(panel)</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">  method onF1KeyPress()</span></span><br><span class="line"><span class="string">  	component = this.getComponentAtMouseCoords()</span></span><br><span class="line"><span class="string">  	component.showHelp()</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式</p>
<p>该模式能将多个处理者连接成一条链。接收到请求后，它会“询问”每个处理者是否能够对其进行处理。这样所有处理者都有机会来处理请求</p>
</li>
<li><p>当必须按顺序执行多个处理者时，可以使用该模式</p>
<p>无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。</p>
</li>
<li><p>如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式</p>
<p>如果在处理者类中有对引用成员变量的设定方法，你将能动态地插入和移除处理者，或者改变其顺序</p>
</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>声明处理者接口并描述请求处理方法的签名</p>
<p>确定客户端如何将请求数据传递给方法。最灵活的方式是将请求转换为对象，然后将其以参数的形式传递给处理函数  </p>
</li>
<li><p>为了在具体处理者中消除重复的样本代码，你可以根据处理者接口创建抽象处理者基类</p>
<p>该类需要有一个成员变量来存储指向链上下个处理者的引用。你可以将其设置为不可变类。但如果你打算在运行时对链进行改变，则需要定义一个设定方法来修改引用成员变量的值</p>
<p>为了使用方便，你还可以实现处理方法的默认行为。如果还有剩余对象，该方法会将请求传递给下个对象。具体处理者还能够通过调用父对象的方法来使用这一行为  </p>
</li>
<li><p>依次创建具体处理者子类并实现其处理方法。每个处理者在接收到请求后都必须做出两个决定</p>
<ul>
<li>是否自行处理这个请求</li>
<li>是否将该请求沿着链进行传递</li>
</ul>
</li>
<li><p>客户端可以自行组装链，或者从其他对象处获得预先组装好的链。在后一种情况下，你必须实现工厂类以根据配置或环境设置来创建链</p>
</li>
<li><p>客户端可以触发链中的任意处理者，而不仅仅是第一个。请求将通过链进行传递，直至某个处理者拒绝继续传递，或者请求到达链尾</p>
</li>
<li><p>由于链的动态性，客户端需要准备好处理以下情况：</p>
<ul>
<li>链中可能只有单个链接</li>
<li>部分请求可能无法到达链尾</li>
<li>其他请求可能直到链尾都未被处理</li>
</ul>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以控制请求处理的顺序</li>
<li>单一职责原则。你可对发起操作和执行操作的类进行解耦</li>
<li>开闭原则。你可以在不更改现有代码的情况下在程序中新增处理者</li>
</ul>
<hr>
<ul>
<li>部分请求可能未被处理</li>
</ul>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p>责任链、命令、中介者和观察者用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理</li>
<li>命令在发送者和请求者之间建立单向连接</li>
<li>中介者清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通</li>
<li>观察者允许接收者动态地订阅或取消接收请求</li>
</ul>
</li>
<li><p>责任链通常和组合模式结合使用。在这种情况下，叶组件接收到请求后，可以将请求沿包含全体父组件的链一直传递至<br>对象树的底部</p>
</li>
<li><p>责任链的管理者可使用命令模式实现。在这种情况下，你可以对由请求代表的同一个上下文对象执行许多不同的操作</p>
<p>还有另外一种实现方式，那就是请求自身就是一个命令对象。在这种情况下，你可以对由一系列不同上下文连接而成的链执行相同的操作</p>
</li>
<li><p>责任链和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处</p>
<p>责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断请求的传递。</p>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><blockquote>
<p>动作、事务、Action、Transaction、Command</p>
</blockquote>
<p>命令是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作</p>
<h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你正在开发一款新的文字编辑器，当前的任务是创建一个包含多个按钮的工具栏，并让每个按钮对应编辑器的不同操作。你创建了一个非常简洁的 按钮 类，它不仅可用于生成工具栏上的按钮，还可用于生成各种对话框的通用按钮。</p>
<p><img src="/posts/23570/image-20240412184528332.png" alt="image-20240412184528332" style="zoom:50%;"></p>
<p>尽管所有按钮看上去都很相似，但它们可以完成不同的操作（打开、保存、打印和应用等）。你会在哪里放置这些按钮的点击处理代码呢？最简单的解决方案是在使用按钮的每个地方都创建大量的子类。这些子类中包含按钮点击后必须执行的代码。</p>
<p><img src="/posts/23570/image-20240412185130774.png" alt="image-20240412185130774"></p>
<p>你很快就意识到这种方式有严重缺陷。首先，你创建了大量的子类，当每次修改基类 按钮 时，你都有可能需要修改所有子类的代码。简单来说，GUI代码以一种拙劣的方式依赖于业务逻辑中的不稳定代码。</p>
<p><img src="/posts/23570/image-20240412185243002.png" alt="image-20240412185243002"></p>
<p>还有一个部分最难办。复制/粘贴文字等操作可能会在多个地方被调用。例如用户可以点击工具栏上小小的“复制”按钮，或者通过上下文菜单复制一些内容，又或者直接使用键盘上的 Ctrl+C。</p>
<p>我们的程序最初只有工具栏，因此可以使用按钮子类来实现各种不同操作。换句话来说， 复制按钮 <code>CopyButton</code> 子类包含复制文字的代码是可行的。在实现了上下文菜单、快捷方式和其他功能后，你要么需要将操作代码复制进许多个类中，要么需要让菜单依赖于按钮，而后者是更糟糕的选择</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>优秀的软件设计通常会将关注点进行分离，而这往往会导致软件的分层。最常见的例子：一层负责用户图像界面；另一层负责业务逻辑。GUI层负责在屏幕上渲染美观的图形，捕获所有输入并显示用户和程序工作的结果。当需要完成一些重要内容时（比如计算月球轨道或撰写年度报告），GUI层则会将工作委派给业务逻辑底层。</p>
<p>这在代码中看上去就像这样：一个 GUI 对象传递一些参数来调用一个业务逻辑对象。这个过程通常被描述为一个对象发送请求给另一个对象</p>
<p> <img src="/posts/23570/image-20240412190345111.png" alt="image-20240412190345111"></p>
<p>命令模式建议GUI对象不直接提交这些请求。<strong>你应该将请求的所有细节（例如调用的对象、方法名称和参数列表）抽取出来组成命令类，该类中仅包含一个用于触发请求的方法。</strong></p>
<p>命令对象负责连接不同的GUI和业务逻辑对象。此后，GUI对象无需了解业务逻辑对象是否获得了请求，也无需了解其对请求进行处理的方式。GUI对象触发命令即可，命令对象会自行处理所有细节工作。</p>
<p><img src="/posts/23570/image-20240412190415337.png" alt="image-20240412190415337"></p>
<p>下一步是让所有命令实现相同的接口。该接口通常只有一个没有任何参数的执行方法，让你能在不和具体命令类耦合的情况下使用同一请求发送者执行不同命令。此外还有额外的好处，现在你能在运行时切换连接至发送者的命令对象，以此改变发送者的行为。</p>
<p>你可能会注意到遗漏的一块拼图——请求的参数。GUI 对象可以给业务层对象提供一些参数。但执行命令方法没有任何参数，所以我们如何将请求的详情发送给接收者呢？答案是：使用数据对命令进行预先配置，或者让其能够自行获取数据</p>
<p><img src="/posts/23570/image-20240412190602039.png" alt="image-20240412190602039" style="zoom:50%;"></p>
<p>让我们回到文本编辑器。应用命令模式后，我们不再需要任何按钮子类来实现点击行为。我们只需在 按钮 Button 基类中添加一个成员变量来存储对于命令对象的引用，并在点击后执行该命令即可  </p>
<p>你需要为每个可能的操作实现一系列命令类，并且根据按钮所需行为将命令和按钮连接起来</p>
<p>其他菜单、快捷方式或整个对话框等 GUI 元素都可以通过相同方式来实现。当用户与 GUI 元素交互时，与其连接的命令将会被执行。现在你很可能已经猜到了，与相同操作相关的元素将会被连接到相同的命令，从而避免了重复代码</p>
<p>最后，命令成为了减少 GUI 和业务逻辑层之间耦合的中间层。而这仅仅是命令模式所提供的一小部分好处  </p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240412191011676.png" alt="image-20240412191011676" style="zoom:50%;"></p>
<ol>
<li><p>发送者（<code>Sender</code>）——亦称“触发者（<code>Invoker</code>）”类负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。发送者触发命令，而不向接收者直接发送请求。注意，发送者并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令</p>
</li>
<li><p>命令（<code>Command</code>）接口通常仅声明一个执行命令的方法</p>
</li>
<li><p>具体命令（<code>Concrete Commands</code>） 会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。但为了简化代码，这些类可以进行合并</p>
<p>接收对象执行方法所需的参数可以声明为具体命令的成员变量。你可以将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化。  </p>
</li>
<li><p>接收者（<code>Receiver</code>）类包含部分业务逻辑。几乎任何对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作</p>
</li>
<li><p>客户端（<code>Client</code>）会创建并配置具体命令对象。客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了</p>
</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>命令模式会记录已执行操作的历史记录，以在需要时撤销操作</p>
<p><img src="/posts/23570/image-20240412191420413.png" alt="image-20240412191420413" style="zoom: 25%;"></p>
<p>有些命令会改变编辑器的状态（例如剪切和粘贴），它们可在执行相关操作前对编辑器的状态进行备份。命令执行后会和当前点备份的编辑器状态一起被放入命令历史（命令对象栈）。此后，如果用户需要进行回滚操作，程序可从历史记录中取出最近的命令，读取相应的编辑器状态备份，然后进行恢复。  </p>
<p>客户端代码（GUI 元素和命令历史等）没有和具体命令类相耦合，因为它通过命令接口来使用命令。这使得你能在无需修改已有代码的情况下在程序中增加新的命令  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/／命令基类会为所有具体命令定义通用接口。</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Command</span> is</span><br><span class="line">	<span class="keyword">protected</span> field app:Application</span><br><span class="line">	<span class="keyword">protected</span> field editor:Editor</span><br><span class="line">	<span class="keyword">protected</span> field backup:text</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Command</span><span class="params">(app: Application, editor: Editor)</span> is</span><br><span class="line">		<span class="built_in">this</span>.app = app</span><br><span class="line">		<span class="built_in">this</span>.editor = editor</span><br><span class="line">		</span><br><span class="line">  <span class="comment">//备份编辑器状态。	</span></span><br><span class="line">  method <span class="title function_">saveBackup</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">backup</span> <span class="operator">=</span> editor.text</span><br><span class="line">  	</span><br><span class="line">  <span class="comment">//恢复编辑器状态。</span></span><br><span class="line">  method <span class="title function_">undo</span><span class="params">()</span> is</span><br><span class="line">  	editor.text = backup</span><br><span class="line">  	</span><br><span class="line">  <span class="comment">//执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根据命令是否更改编辑器的状态返回true 或false。</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">execute</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//这里是具体命令。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line"><span class="comment">//复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。</span></span><br><span class="line">  method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">    app.clipboard = editor.getSelection()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CutCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line"><span class="comment">//剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法返回true，它就会被保存。</span></span><br><span class="line">	method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">saveBackup</span><span class="params">()</span></span><br><span class="line">		app.clipboard = editor.getSelection()</span><br><span class="line">		editor.deleteSelection()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PasteCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line">	method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">saveBackup</span><span class="params">()</span></span><br><span class="line">		editor.replaceSelection(app.clipboard)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//撤销操作也是一个命令。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UndoCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> is</span><br><span class="line">	method <span class="title function_">execute</span><span class="params">()</span> is</span><br><span class="line">		app.undo()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//全局命令历史记录就是一个堆栈。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandHistory</span> is</span><br><span class="line">	<span class="keyword">private</span> field history: array of Command</span><br><span class="line">	<span class="comment">//后进...</span></span><br><span class="line">	method <span class="title function_">push</span><span class="params">(c: Command)</span> is</span><br><span class="line">		<span class="comment">//将命令压入历史记录数组的末尾。</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//...先出</span></span><br><span class="line">	method <span class="title function_">pop</span><span class="params">()</span>:Command is</span><br><span class="line">		<span class="comment">//从历史记录中取出最近的命令。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会将执行工作委派给编辑器的方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> is</span><br><span class="line">	field text: string</span><br><span class="line">	method <span class="title function_">getSelection</span><span class="params">()</span> is</span><br><span class="line">		<span class="comment">//返回选中的文字。</span></span><br><span class="line">  method <span class="title function_">deleteSelection</span><span class="params">()</span> is</span><br><span class="line">  	<span class="comment">//删除选中的文字。</span></span><br><span class="line">  method <span class="title function_">replaceSelection</span><span class="params">(text)</span> is</span><br><span class="line">  	<span class="comment">//在当前位置插入剪贴板中的内容。</span></span><br><span class="line">  	</span><br><span class="line"><span class="comment">//应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工作时，它会创建并执行一个命令对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">	field clipboard: string</span><br><span class="line">	field editors: array of Editors</span><br><span class="line">	field activeEditor: Editor</span><br><span class="line">	field history: CommandHistory</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将命令分派给UI对象的代码可能会是这样的。</span></span><br><span class="line">	method <span class="title function_">createUI</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">copy</span> <span class="operator">=</span> function() &#123; executeCommand(</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">CopyCommand</span>(<span class="built_in">this</span>, activeEditor))&#125;</span><br><span class="line">    copyButton.setCommand(copy)</span><br><span class="line">    shortcuts.onKeyPress(<span class="string">&quot;Ctrl+C&quot;</span>, copy)</span><br><span class="line">    </span><br><span class="line">    cut = function() &#123;executeCommand(</span><br><span class="line">      	<span class="keyword">new</span> <span class="title class_">CutCommand</span>(<span class="built_in">this</span>, activeEditor))&#125;</span><br><span class="line">		cutButton.setCommand(cut)</span><br><span class="line">    shortcuts.onKeyPress(<span class="string">&quot;Ctrl+x&quot;</span>, cut)</span><br><span class="line">      </span><br><span class="line">    paste = function() &#123;executeCommand(<span class="keyword">new</span> <span class="title class_">PasteCommand</span>(<span class="built_in">this</span>, activeEditor))&#125;</span><br><span class="line">		pasteButton.setCommand(paste)</span><br><span class="line">    shortcuts.onKeyPress(<span class="string">&quot;Ctrl+V&quot;</span>, paste)</span><br><span class="line">      </span><br><span class="line">    undo = function() &#123; executeCommand(<span class="keyword">new</span> <span class="title class_">UndoCommand</span>(<span class="built_in">this</span>, activeEditor))&#125;</span><br><span class="line">		undoButton. setCommand(undo)</span><br><span class="line">    shortcuts.onKeyPress(<span class="string">&quot;Ctrl+Z&quot;</span>, undo)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">  <span class="comment">//执行一个命令并检查它是否需要被添加到历史记录中。</span></span><br><span class="line">  method <span class="title function_">executeCommand</span><span class="params">(command)</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(command.execute)</span></span><br><span class="line">          history.push(command)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从历史记录中取出最近的命令并运行其undo（撤销）方法。请注意，你并不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销其动作。</span></span><br><span class="line">  method <span class="title function_">undo</span><span class="params">(） is</span></span><br><span class="line"><span class="params">    command = history.pop()</span></span><br><span class="line">      <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">        command.undo( )</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你需要通过操作来参数化对象，可使用命令模式</p>
<p>命令模式可将特定的方法调用转化为独立对象。这一改变也带来了许多有趣的应用：你可以将命令作为方法的参数进行传递、将命令保存在其他对象中，或者在运行时切换已连接的命令等</p>
<p>举个例子： 你正在开发一个 GUI 组件（例如上下文菜单），<br>你希望用户能够配置菜单项，并在点击菜单项时触发操作</p>
</li>
<li><p>如果你想要将操作放入队列中、操作的执行或者远程执行操作，可使用命令模式</p>
<p>同其他对象一样，命令也可以实现序列化（序列化的意思是转化为字符串），从而能方便地写入文件或数据库中。一段时间后，该字符串可被恢复成为最初的命令对象。因此，你可以延迟或计划命令的执行。但其功能远不止如此！使用同样的方式，你还可以将命令放入队列、记录命令或者通过网络发送命令</p>
</li>
<li><p>如果你想要实现操作回滚功能，可使用命令模式</p>
<p>尽管有很多方法可以实现撤销和恢复功能，但命令模式可能是其中最常用的一种。</p>
<p>为了能够回滚操作，你需要实现已执行操作的历史记录功能。命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构</p>
<p>这种方法有两个缺点。首先，程序状态的保存功能并不容易实现，因为部分状态可能是私有的。你可以使用备忘录模式来在一定程度上解决这个问题。</p>
<p>其次，备份状态可能会占用大量内存。因此，有时你需要借助另一种实现方式：命令无需恢复原始状态，而是执行反向操作。反向操作也有代价：它可能会很难甚至是无法实现  </p>
</li>
</ul>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>声明仅有一个执行方法的命令接口</li>
<li>抽取请求并使之成为实现命令接口的具体命令类。每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。所有这些变量的数值都必须通过命令构造函数进行初始化</li>
<li>找到担任发送者职责的类。在这些类中添加保存命令的成员变量。发送者只能通过命令接口与其命令进行交互。发送者自身通常并不创建命令对象，而是通过客户端代码获取</li>
<li>修改发送者使其执行命令，而非直接将请求发送给接收者</li>
<li>客户端必须按照以下顺序来初始化对象：<ol>
<li>创建接收者</li>
<li>创建命令，如有需要可将其关联至接收者</li>
<li>创建发送者并将其与特定命令关联</li>
</ol>
</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>单一职责原则。你可以解耦触发和执行操作的类</li>
<li>开闭原则。你可以在不修改已有客户端代码的情况下在程序中创建新的命令</li>
<li>你可以实现撤销和恢复功能</li>
<li>你可以实现操作的延迟执行</li>
<li>你可以将一组简单命令组合成一个复杂命令</li>
</ul>
<hr>
<ul>
<li>代码可能会变得更加复杂，因为你在发送者和接收者之间增加了一个全新的层次</li>
</ul>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>责任链、命令、中介者和观察者用于处理请求发送者和接收者之间的不同连接方式：<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理</li>
<li>命令在发送者和请求者之间建立单向连接</li>
<li>中介者清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通</li>
<li>观察者允许接收者动态地订阅或取消接收请求</li>
</ul>
</li>
<li>责任链的管理者可使用命令模式实现。在这种情况下，你可以对由请求代表的同一个上下文对象执行许多不同的操作。<br>还有另外一种实现方式，那就是请求自身就是一个命令对象。在这种情况下，你可以对由一系列不同上下文连接而成的链执行相同的操作</li>
<li>你可以同时使用命令和备忘录来实现“撤销”。在这种情况下，命令用于对目标对象执行各种不同的操作，备忘录用来保存一条命令执行前该对象的状态</li>
<li>命令和策略看上去很像，因为两者都能通过某些行为来参数化对象。但是，它们的意图有非常大的不同<ul>
<li>你可以使用命令来将任何操作转换为对象。操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、将操作放入队列、保存历史命令或者向远程服务发送命令等</li>
<li>另一方面，策略通常可用于描述完成某件事的不同方式，让你能够在同一个上下文类中切换算法</li>
</ul>
</li>
<li>原型可用于保存命令的历史记录</li>
<li>你可以将访问者视为命令模式的加强版本，其对象可对不同类的多种对象执行操作</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>Iterator</p>
</blockquote>
<p>迭代器是一种行为设计模式，让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素。</p>
<h3 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h3><p>集合是编程中最常使用的数据类型之一。尽管如此，集合只是一组对象的容器而已。</p>
<p>大部分集合使用简单列表存储元素。但有些集合还会使用栈、树、图和其他复杂的数据结构。</p>
<p>无论集合的构成方式如何，它都必须提供某种访问元素的方式，便于其他代码使用其中的元素。集合应提供一种能够遍历元素的方式，且保证它不会周而复始地访问同一个元素。 </p>
<p>如果你的集合基于列表， 那么这项工作听上去仿佛很简单。但如何遍历复杂数据结构（例如树）中的元素呢？例如，今天你需要使用深度优先算法来遍历树结构，明天可能会需要广度优先算法；下周则可能会需要其他方式（比如随机存取树中的元素）。</p>
<p>不断向集合中添加遍历算法会模糊其“高效存储数据”的主要职责。此外，有些算法可能是根据特定应用订制的，将其加入泛型集合类中会显得非常奇怪。</p>
<p>另一方面，使用多种集合的客户端代码可能并不关心存储数据的方式。不过由于集合提供不同的元素访问方式，你的代码将不得不与特定集合类进行耦合。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。</p>
<p><img src="/posts/23570/image-20240415181916755.png" alt="image-20240415181916755" style="zoom:33%;"></p>
<p>除实现自身算法外， 迭代器还封装了遍历操作的所有细节，例如当前位置和末尾剩余元素的数量。因此，多个迭代器可以在相互独立的情况下同时访问集合。</p>
<p>迭代器通常会提供一个获取集合元素的基本方法。客户端可不断调用该方法直至它不返回任何内容，这意味着迭代器已经遍历了所有元素。</p>
<p>所有迭代器必须实现相同的接口。这样一来，只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。如果你需要采用特殊方式来遍历集合，只需创建一个新的迭代器类即可，无需对集合或客户端进行修改。</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240415182302505.png" alt="image-20240415182302505" style="zoom:33%;"></p>
<ol>
<li><p>迭代器（<code>Iterator</code>）接口声明了遍历集合所需的操作：获取下<br>一个元素、获取当前位置和重新开始迭代等。</p>
</li>
<li><p>具体迭代器（<code>Concrete Iterators</code>）实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一集合。</p>
</li>
<li><p>集合（<code>Collection</code>）接口声明一个或多个方法来获取与集合兼容的迭代器。请注意，返回方法的类型必须被声明为迭代器接口，因此具体集合可以返回各种不同种类的迭代器</p>
</li>
<li><p>具体集合（<code>Concrete Collections</code>）会在客户端请求迭代器时返回一个特定的具体迭代器类实体。你可能会琢磨，剩下的集合代码在什么地方呢？不用担心，它也会在同一个类中。只是这些细节对于实际模式来说并不重要，所以我们将其省略了而已。 </p>
</li>
<li><p>客户端（<code>Client</code>）通过集合和迭代器的接口与两者进行交互。这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用各种不同的集合和迭代器。</p>
<p>客户端通常不会自行创建迭代器，而是会从集合中获取。但在特定情况下，客户端可以直接创建一个迭代器（例如当客户端需要自定义特殊迭代器时）。    </p>
</li>
</ol>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。该集合提供使用不同方式遍历档案资料的多个迭代器</p>
<p><img src="/posts/23570/image-20240415182716568.png" alt="image-20240415182716568" style="zoom:33%;"></p>
<p>“好友（<code>friends</code>）”迭代器可用于遍历指定档案的好友。“同事（<code>colleagues</code>）”迭代器也提供同样的功能，但仅包括与目标用户在同一家公司工作的好友。这两个迭代器都实现了同一个通用接口，客户端能在不了解认证和发送 REST 请求等实现细节的情况下获取档案。  </p>
<p>客户端仅通过接口与集合和迭代器交互，也就不会同具体类耦合。如果你决定将应用连接到全新的社交网络，只需提供新的集合和迭代器类即可，无需修改现有代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合接口必须声明一个用于生成迭代器的工厂方法。如果程序中有不同类型的迭代器，你也可以声明多个方法。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SocialNetwork</span> is</span><br><span class="line">	method <span class="title function_">createFriendsIterator</span><span class="params">(profileId)</span>:ProfileIterator</span><br><span class="line">	method <span class="title function_">createCoworkersIterator</span><span class="params">(profileId)</span>:ProfileIterator</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">//每个具体集合都与其返回的一组具体迭代器相耦合。但客户并不是这样的，因为这些方法的签名将会返回迭代器接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeChat</span> <span class="keyword">implements</span> <span class="title class_">SocialNetwork</span> is</span><br><span class="line">	<span class="comment">// ...大量的集合代码应该放在这里</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 迭代器创建代码。</span></span><br><span class="line">	method <span class="title function_">createFriendsIterator</span><span class="params">(profileId)</span> is</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeChatIterator</span>(<span class="built_in">this</span>, profileId,，<span class="string">&quot;friends&quot;</span>)</span><br><span class="line">  method <span class="title function_">createCoworkersIterator</span><span class="params">(profileId)</span> is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WeChatIterator</span>(<span class="built_in">this</span>, profileId, <span class="string">&quot;coworkers&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//所有选代器的通用接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProfileIterator</span> is</span><br><span class="line">  method <span class="title function_">getNext</span><span class="params">()</span>:Profile</span><br><span class="line">  method <span class="title function_">hasMore</span><span class="params">()</span>:bool</span><br><span class="line">  </span><br><span class="line"><span class="comment">//具体选代器类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeChatIterator</span> <span class="keyword">implements</span> <span class="title class_">ProfileIterator</span> is</span><br><span class="line">  <span class="comment">//选代器需要一个指向其遍历集合的引用。</span></span><br><span class="line">  <span class="keyword">private</span> field weChat: WeChat</span><br><span class="line">  <span class="keyword">private</span> field profileId, type: string</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//选代器对象会独立于其他选代器来对集合进行遍历。因此它必须保存迭代器的状态。	</span></span><br><span class="line">  <span class="keyword">private</span> field currentPosition</span><br><span class="line">  <span class="keyword">private</span> field cache: array of Profile</span><br><span class="line">    </span><br><span class="line">  constructor <span class="title function_">WeChatIterator</span><span class="params">(weChat, profileId, type)</span> is</span><br><span class="line">    <span class="built_in">this</span>.weChat = weChat</span><br><span class="line">    <span class="built_in">this</span>.profileId = profileId</span><br><span class="line">    <span class="built_in">this</span>.type = type</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> method <span class="title function_">lazyInit</span><span class="params">()</span> is</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(cache == <span class="literal">null</span>)</span></span><br><span class="line">      cache = weChat.socialGraphRequest(profileId, type)</span><br><span class="line">      </span><br><span class="line"><span class="comment">//每个具体选代器类都会自行实现通用选代器接口。</span></span><br><span class="line">  method <span class="title function_">getNext</span><span class="params">()</span> is</span><br><span class="line">     <span class="title function_">if</span> <span class="params">(hasMore()</span>)</span><br><span class="line">       currentPosition++</span><br><span class="line">     <span class="keyword">return</span> cache[currentPosition]</span><br><span class="line">       </span><br><span class="line">	method <span class="title function_">hasMore</span><span class="params">()</span> is</span><br><span class="line">     <span class="title function_">lazyInit</span><span class="params">()</span></span><br><span class="line">     <span class="keyword">return</span> currentPosition &lt; cache.length</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 这里还有一个有用的绝招：你可将选代器传递给客户端类，无需让其拥有访问整个集合的权限。这样一来，你就无需将集合暴露给客户端了。</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">// 还有另一个好处：你可在运行时将不同的选代器传递给客户端，从而改变客户端与集合互动的方式。这一方法可行的原因是客户端代码并没有和具体迭代器类相耦合。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocialSpammer</span> is</span><br><span class="line">  method <span class="title function_">send</span><span class="params">(iterator: ProfileIterator, message: string)</span> is</span><br><span class="line">  	<span class="title function_">while</span> <span class="params">(iterator.hasMore()</span>)</span><br><span class="line">      profile = iterator.getNext()</span><br><span class="line">      System.sendEmail(profile.getEmail(), message)</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment">//应用程序（Application）类可对集合和选代器进行配置，然后将其传递给客户端代码。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  field network: SocialNetwork</span><br><span class="line">  field spammer: SocialSpammer</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">config</span><span class="params">()</span> is</span><br><span class="line">    <span class="keyword">if</span> working with WeChat</span><br><span class="line">      <span class="built_in">this</span>.network = <span class="keyword">new</span> <span class="title class_">WeChat</span>()</span><br><span class="line">  	<span class="keyword">if</span> working with LinkedIn</span><br><span class="line">      <span class="built_in">this</span>.network = <span class="keyword">new</span> <span class="title class_">LinkedIn</span>()</span><br><span class="line">    <span class="built_in">this</span>.spammer = <span class="keyword">new</span> <span class="title class_">Socialspammer</span>()</span><br><span class="line">      </span><br><span class="line">  method <span class="title function_">sendSpamToFriends</span><span class="params">(profile)</span> <span class="type">is</span></span><br><span class="line">    <span class="variable">iterator</span> <span class="operator">=</span> network.createFriendsIterator(profile.getId())</span><br><span class="line">    spammer.send（iterator，<span class="string">&quot;非常重要的消息&quot;</span>）</span><br><span class="line">      </span><br><span class="line">	method <span class="title function_">sendSpamToCoworkers</span><span class="params">(profile)</span> <span class="type">is</span></span><br><span class="line">    <span class="variable">iterator</span> <span class="operator">=</span> network.createCoworkersIterator(profile.getId())</span><br><span class="line">    spammer.send（iterator，<span class="string">&quot;非常重要的消息&quot;</span>）</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器模式。</p>
<p>迭代器封装了与复杂数据结构进行交互的细节，为客户端提供多个访问集合元素的简单方法。这种方式不仅对客户端来说非常方便，而且能避免客户端在直接与集合交互时执行错误或有害的操作，从而起到保护集合的作用</p>
</li>
<li><p>使用该模式可以减少程序中重复的遍历代码</p>
<p>重要迭代算法的代码往往体积非常庞大。当这些代码被放置在程序业务逻辑中时，它会让原始代码的职责模糊不清，降低其可维护性。因此，将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p>
</li>
<li><p>如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式</p>
<p>该模式为集合和迭代器提供了一些通用接口。如果你在代码中使用了这些接口，那么将其他实现了这些接口的集合和迭代器传递给它时，它仍将可以正常运行。</p>
</li>
</ul>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>声明迭代器接口。该接口必须提供至少一个方法来获取集合中的下个元素。但为了使用方便，你还可以添加一些其他方法，例如获取前一个元素、记录当前位置和判断迭代是否已结束。</li>
<li>声明集合接口并描述一个获取迭代器的方法。其返回值必须是迭代器接口。如果你计划拥有多组不同的迭代器，则可以声明多个类似的方法。</li>
<li>为希望使用迭代器进行遍历的集合实现具体迭代器类。迭代器对象必须与单个集合实体链接。链接关系通常通过迭代器的构造函数建立。</li>
<li>在你的集合类中实现集合接口。其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。</li>
<li>检查客户端代码，使用迭代器替代所有集合遍历代码。每当客户端需要遍历集合元素时都会获取一个新的迭代器。</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>单一职责原则。通过将体积庞大的遍历算法代码抽取为独立的类，你可对客户端代码和集合进行整理</li>
<li>开闭原则。你可实现新型的集合和迭代器并将其传递给现有代码，无需修改现有代码。</li>
<li>你可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态。</li>
<li>相似的，你可以暂停遍历并在需要时继续。</li>
</ul>
<hr>
<ul>
<li>如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正。</li>
<li>对于某些特殊集合，使用迭代器可能比直接遍历的效率低。</li>
</ul>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>你可以使用迭代器来遍历组合树</li>
<li>你可以同时使用工厂方法和迭代器来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配</li>
<li>你可以同时使用备忘录和迭代器来获取当前迭代器的状态，并且在需要的时候进行回滚。</li>
<li>可以同时使用访问者和迭代器来遍历复杂数据结构，并对其中的元素执行所需操作，即使这些元素所属的类完全不同。  </li>
</ul>
<h2 id="中介者"><a href="#中介者" class="headerlink" title="中介者"></a>中介者</h2><blockquote>
<p>调解人、控制器、Intermediary、Controller、Mediator</p>
</blockquote>
<p>中介者是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象　　进行合作。</p>
<h3 id="问题背景-3"><a href="#问题背景-3" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你有一个创建和修改客户资料的对话框，它由各种控件组成， 例如文本框（TextField）、 复选框（<code>Checkbox</code>）和按钮（<code>Button</code>）等。</p>
<p><img src="/posts/23570/image-20240422190409968.png" alt="image-20240422190409968"></p>
<p>某些表单元素可能会直接进行互动。例如，选中“我有一只狗”复选框后可能会显示一个隐藏文本框用于输入狗狗的名字。另一个例子是提交按钮必须在保存数据前校验所有输入内容。</p>
<p><img src="/posts/23570/image-20240422191038669.png" alt="image-20240422191038669"></p>
<p>元素间存在许多关联。因此，对某些元素进行修改可能会影响其他元素。</p>
<p>如果直接在表单元素代码中实现业务逻辑，你将很难在程序其他表单中复用这些元素类。例如，由于复选框类与狗狗的文本框相耦合，所以将无法在其他表单中使用它。你要么使用渲染资料表单时用到的所有类，要么一个都不用  </p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>中介者模式建议你停止组件之间的直接交流并使其相互独立。这些组件必须调用特殊的中介者对象，通过中介者对象重定向调用行为，以间接的方式进行合作。最终，组件仅依赖于一个中介者类，无需与多个其他组件相耦合。</p>
<p>在资料编辑表单的例子中，对话框（Dialog）类本身将作为中介者，其很可能已知自己所有的子元素，因此你甚至无需在该类中引入新的依赖关系。</p>
<p><img src="/posts/23570/image-20240422192149797.png" alt="image-20240422192149797"></p>
<p>绝大部分重要的修改都在实际表单元素中进行。让我们想想提交按钮。之前，当用户点击按钮后，它必须对所有表单元素数值进行校验。而现在它的唯一工作是将点击事件通知给对话框。收到通知后，对话框可以自行校验数值或将任务委派给各元素。这样一来，按钮不再与多个表单元素相关联，而仅依赖于对话框类。</p>
<p>你还可以为所有类型的对话框抽取通用接口，进一步削弱其依赖性。接口中将声明一个所有表单元素都能使用的通知方法，可用于将元素中发生的事件通知给对话框。这样一来，所有实现了该接口的对话框都能使用这个提交按钮了。</p>
<p>采用这种方式，中介者模式让你能在单个中介者对象中封装多个对象间的复杂关系网。类所拥有的依赖关系越少，就越易于修改、扩展或复用。</p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240423100304200.png" alt="image-20240423100304200" style="zoom: 33%;"></p>
<ol>
<li><p>组件（Component）是各种包含业务逻辑的类。每个组件都有一个指向中介者的引用，该引用被声明为中介者接口类型。组件不知道中介者实际所属的类，因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</p>
</li>
<li><p>中介者（Mediator）接口声明了与组件交流的方法，但通常仅包括一个通知方法。组件可将任意上下文（包括自己的对象）作为该方法的参数，只有这样接收组件和发送者类之间才不会耦合。</p>
</li>
<li><p>具体中介者（Concrete Mediator）封装了多种组件间的关系。具体中介者通常会保存所有组件的引用并对其进行管理，甚至有时会对其生命周期进行管理。</p>
</li>
<li><p>组件并不知道其他组件的情况。如果组件内发生了重要事件，它只能通知中介者。中介者收到通知后能轻易地确定发送者，这或许已足以判断接下来需要触发的组件了。</p>
<p>对于组件来说，中介者看上去完全就是一个黑箱。发送者不知道最终会由谁来处理自己的请求，接收者也不知道最初是谁发出了请求。  </p>
</li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>中介者模式可帮助你减少各种 UI 类（按钮、复选框和文本标签）之间的相互依赖关系。</p>
<p><img src="/posts/23570/image-20240423101135481.png" alt="image-20240423101135481" style="zoom:33%;"></p>
<p>用户触发的元素不会直接与其他元素交流，即使看上去它们应该这样做。相反，元素只需让中介者知晓事件即可，并能在发出通知时同时传递任何上下文信息。</p>
<p>本例中的中介者是整个认证对话框。对话框知道具体元素应如何进行合作并促进它们的间接交流。当接收到事件通知后，对话框会确定负责处理事件的元素并据此重定向请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中介者接口声明了一个能让组件将各种事件通知给中介者的方法。中介者可对这些事件做出响应并将执行工作传递给其他组件。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> is</span><br><span class="line">	method <span class="title function_">notify</span><span class="params">(sender: Component, event: string)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体中介者类可解开各组件之间相互交叉的连接关系并将其转移到中介者中。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationDialog</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> is</span><br><span class="line">	<span class="keyword">private</span> field title: string</span><br><span class="line">	<span class="keyword">private</span> field loginorRegisterChkBx: Checkbox</span><br><span class="line">	<span class="keyword">private</span> field loginUsername, loginPassword: Textbox</span><br><span class="line">	<span class="keyword">private</span> field registrationUsername, registrationPassword,registrationEmail: Textbox</span><br><span class="line">	<span class="keyword">private</span> field okBtn, cancelBtn: Button</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">AuthenticationDialog</span><span class="params">()</span> is</span><br><span class="line">		<span class="comment">//创建所有组件对象并将当前中介者传递给其构造函数以建立连接。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//当组件中有事件发生时，它会通知中介者。中介者接收到通知后可自行处理，也可将请求传递给另一个组件。</span></span><br><span class="line"></span><br><span class="line">	method <span class="title function_">notify</span><span class="params">(sender, event)</span> is</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(sender == loginorRegisterChkBx and event == <span class="string">&quot;check&quot;</span>)</span></span><br><span class="line">			<span class="keyword">if</span> (loginOrRegisterChkBx.checked)</span><br><span class="line">				title = <span class="string">&quot;登录&quot;</span></span><br><span class="line">				<span class="comment">//1，显示登录表单组件。</span></span><br><span class="line">				<span class="comment">//2. 隐藏注册表单组件。</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      	title=“注册<span class="string">&quot;</span></span><br><span class="line"><span class="string">      	//1，显示注册表单组件。</span></span><br><span class="line"><span class="string">      	//2. 隐藏登录表单组件。</span></span><br><span class="line"><span class="string">      if (sender == okBtn &amp;&amp; event == &quot;</span>click<span class="string">&quot;)</span></span><br><span class="line"><span class="string">      	if ( loginOrRegister.checked)</span></span><br><span class="line"><span class="string">      		//尝试找到使用登录信息的用户。</span></span><br><span class="line"><span class="string">      		if (!found)</span></span><br><span class="line"><span class="string">      			// 在登录字段上方显示错误信息。</span></span><br><span class="line"><span class="string">      		else</span></span><br><span class="line"><span class="string">      			//1. 使用注册字段中的数据创建用户账号。</span></span><br><span class="line"><span class="string">      			</span></span><br><span class="line"><span class="string">//组件会使用中介者接口与中介者进行交互。因此只需将它们与不同的中介者连接起来，你就能在其他情境中使用这些组件了。</span></span><br><span class="line"><span class="string">class Component isfield dialog: Mediator</span></span><br><span class="line"><span class="string">	constructor Component(dialog)is</span></span><br><span class="line"><span class="string">		this.dialog = dialog</span></span><br><span class="line"><span class="string">  method click() is</span></span><br><span class="line"><span class="string">  	dialog.notify(this, &quot;</span>click<span class="string">&quot;)</span></span><br><span class="line"><span class="string">  method keypress() is</span></span><br><span class="line"><span class="string">  	dialog.notify(this, &quot;</span>keypress<span class="string">&quot;)</span></span><br><span class="line"><span class="string">  	</span></span><br><span class="line"><span class="string">//具体组件之间无法进行交流。它们只有一个交流渠道，那就是向中介者发送通知。</span></span><br><span class="line"><span class="string">class Button extends Component is</span></span><br><span class="line"><span class="string">	// ...</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">class Textbox extends Component is</span></span><br><span class="line"><span class="string">	// ...</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">class Checkbox extends Component is</span></span><br><span class="line"><span class="string">	method check() is</span></span><br><span class="line"><span class="string">		dialog.notify(this, &quot;</span>check<span class="string">&quot;)</span></span><br><span class="line"><span class="string">  // ...</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>当一些对象和其他对象紧密耦合以致难以对其进行修改时，可使用中介者模式</p>
<p>该模式让你将对象间的所有关系抽取成为一个单独的类，以使对于特定组件的修改工作独立于其他组件</p>
</li>
<li><p>当组件因过于依赖其他组件而无法在不同应用中复用时，可使用中介者模式</p>
<p>应用中介者模式后，每个组件不再知晓其他组件的情况。尽管这些组件无法直接交流，但它们仍可通过中介者对象进行间接交流。如果你希望在不同应用中复用一个组件，则需要为其提供一个新的中介者类  </p>
</li>
<li><p>如果为了能在不同情景下复用一些基本行为，导致你需要被迫创建大量组件子类时，可使用中介者模式</p>
<p>由于所有组件间关系都被包含在中介者中，因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式</p>
</li>
</ul>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>找到一组当前紧密耦合，且提供其独立性能带来更大好处的类（例如更易于维护或更方便复用）</li>
<li>声明中介者接口并描述中介者和各种组件之间所需的交流接口。在绝大多数情况下，一个接收组件通知的方法就足够了。如果你希望在不同情景下复用组件类，那么该接口将非常重要。只要组件使用通用接口与其中介者合作，你就能将该组件与不同实现中的中介者进行连接。</li>
<li>实现具体中介者类。该类可从自行保存其下所有组件的引用中受益。  </li>
<li>你可以更进一步，让中介者负责组件对象的创建和销毁。此后，中介者可能会与工厂或外观类似。  </li>
<li>组件必须保存对于中介者对象的引用。该连接通常在组件的构造函数中建立，该函数会将中介者对象作为参数传递。</li>
<li>修改组件代码，使其可调用中介者的通知方法，而非其他组件的方法。 然后将调用其他组件的代码抽取到中介者类中，并在中介者接收到该组件通知时执行这些代码。  </li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>单一职责原则。你可以将多个组件间的交流抽取到同一位置，使其更易于理解和维护。</li>
<li>开闭原则。你无需修改实际组件就能增加新的中介者。</li>
<li>你可以减轻应用中多个组件间的耦合情况</li>
<li>你可以更方便地复用各个组件</li>
</ul>
<hr>
<ul>
<li>一段时间后，中介者可能会演化成为上帝对象</li>
</ul>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p>责任链、命令、中介者和观察者用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求  </li>
</ul>
</li>
<li><p>外观和中介者的职责类似：它们都尝试在大量紧密耦合的类中组织起合作。</p>
<ul>
<li>外观为子系统中的所有对象定义了一个简单接口，但是它不提供任何新功能。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流。</li>
<li>中介者将系统中组件的沟通行为中心化。各组件只知道中介者对象，无法直接相互交流。</li>
</ul>
</li>
<li><p>中介者和观察者之间的区别往往很难记住。在大部分情况下，你可以使用其中一种模式，而有时可以同时使用。让我们来看看如何做到这一点。  </p>
<p>中介者的主要目标是消除一系列系统组件之间的相互依赖。这些组件将依赖于同一个中介者对象。观察者的目标是在对象之间建立动态的单向连接，使得部分对象可作为其他对象的附属发挥作用。  </p>
<p>有一种流行的中介者模式实现方式依赖于观察者。中介者对象担当发布者的角色，其他组件则作为订阅者，可以订阅中介者的事件或取消订阅。当中介者以这种方式实现时，它可能看上去与观察者非常相似  </p>
<p>当你感到疑惑时，记住可以采用其他方式来实现中介者。例如，你可永久性地将所有组件链接到同一个中介者对象。这种实现方式和观察者并不相同，但这仍是一种中介者模式</p>
<p>假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象，而只有一些分布式的观察者。</p>
</li>
</ul>
<h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><blockquote>
<p>快照、Snapshot、Memento</p>
</blockquote>
<p>备忘录是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态</p>
<h3 id="问题背景-4"><a href="#问题背景-4" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你正在开发一款文字编辑器应用程序。除了简单的文字编辑功能外，编辑器中还要有设置文本格式和插入内嵌图片等功能。</p>
<p>后来，你决定让用户能撤销施加在文本上的任何操作。这项功能在过去几年里变得十分普遍，因此用户期待任何程序都有这项功能。你选择采用直接的方式来实现该功能：程序在执行任何操作前会记录所有的对象状态， 并将其保存下来。当用户此后需要撤销某个操作时，程序将从历史记录中获取最近的快照，然后使用它来恢复所有对象的状态。</p>
<p><img src="/posts/23570/image-20240508182231899-1715163766878-1.png" alt="image-20240508182231899"></p>
<p>首先，到底该如何生成一个快照呢？很可能你会需要遍历对象的所有成员变量并将其数值复制保存。但只有当对象对其内容没有严格访问权限限制的情况下，你才能使用该方式。不过很遗憾，绝大部分对象会使用私有成员变量来存储重要数据，这样别人就无法轻易查看其中的内容。  </p>
<p>即使不考虑访问权限问题，通过上述方式虽然能够随时生成对象的快照，但是依然存在一些严重问题。</p>
<p>未来你可能会添加或删除一些成员变量。这听上去很简单，但需要对负责复制受影响对象状态的类进行更改  </p>
<p>此外，让我们来考虑编辑器（Editor）状态的实际“快照”， 它需要包含哪些数据？ 至少必须包含实际的文本、光标坐标和当前滚动条位置等。你需要收集这些数据并将其放入特定容器中，才能生成快照。  </p>
<p>为了让其他对象能保存或读取快照，你很可能需要将快照的成员变量设为公有。无论这些状态是否私有，其都将暴露一切编辑器状态。其他类会对快照类的每个小改动产生依赖，除非这些改动仅存在于私有成员变量或方法中，而不会影响外部类。</p>
<p>我们似乎走进了一条死胡同：要么会暴露类的所有内部细节而使其过于脆弱；要么会限制对其状态的访问权限而无法生成快照。那么，我们还有其他方式来实现“撤销”功能吗？</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>备忘录模式将创建状态快照（Snapshot）的工作委派给实际状态的拥有者原发器（Originator）对象。这样其他对象就不再需要从“外部”复制编辑器状态了，编辑器类拥有其状态的完全访问权，因此可以自行生成快照。</p>
<p>该模式建议将对象状态的副本存储在一个名为备忘录（Memento）的特殊对象中。除了创建备忘录的对象外，任何对象都不能访问备忘录的内容。其他对象必须使用受限接口与备忘录进行交互，它们可以获取快照的元数据（创建时间和操作名称等），但不能获取快照中原始对象的状态。</p>
<p><img src="/posts/23570/image-20240508183247912.png" alt="image-20240508183247912" style="zoom:33%;"></p>
<p>这种限制策略允许你将备忘录保存在通常被称为负责人（Caretakers）的对象中。由于负责人仅通过受限接口与备忘录互动，故其无法修改存储在备忘录内部的状态。同时，原发器拥有对备忘录所有成员的访问权限，从而能随时恢复其以前的状态</p>
<p>在文字编辑器的示例中， 我们可以创建一个独立的历史（History）类作为负责人。编辑器每次执行操作前，存储在负责人中的备忘录栈都会生长。你甚至可以在应用的 UI 中渲染该栈，为用户显示之前的操作历史。</p>
<p>当用户触发撤销操作时，历史类将从栈中取回最近的备忘录，并将其传递给编辑器以请求进行回滚。由于编辑器拥有对备忘录的完全访问权限，因此它可以使用从备忘录中获取的数值来替换自身的状态</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><h4 id="基于嵌套类的实现"><a href="#基于嵌套类的实现" class="headerlink" title="基于嵌套类的实现"></a>基于嵌套类的实现</h4><p><img src="/posts/23570/image-20240508184044562.png" alt="image-20240508184044562"></p>
<ol>
<li><p>原发器（Originator）类可以生成自身状态的快照，也可以在<br>需要时通过快照恢复自身状态。</p>
</li>
<li><p>备忘录 （Memento） 是原发器状态快照的值对象 （valueobject）。通常做法是将备忘录设为不可变的，并通过构造函数一次性传递数据。</p>
</li>
<li><p>负责人（Caretaker）仅知道“何时”和“为何”捕捉原发器的状态，以及何时恢复状态。</p>
<p>负责人通过保存备忘录栈来记录原发器的历史状态。当原发器需要回溯历史状态时，负责人将从栈中获取最顶部的备忘录，并将其传递给原发器的恢复（restoration）方法。  </p>
</li>
<li><p>在该实现方法中，备忘录类将被嵌套在原发器中。这样原发器就可访问备忘录的成员变量和方法，即使这些方法被声明为私有。另一方面，负责人对于备忘录的成员变量和方法的访问权限非常有限：它们只能在栈中保存备忘录，而不能修改其状态。  </p>
</li>
</ol>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>本例结合使用了命令模式与备忘录模式，可保存复杂文字编辑器的状态快照，并能在需要时从快照中恢复之前的状态。</p>
<p><img src="/posts/23570/image-20240508184338773.png" alt="image-20240508184338773"></p>
<p>命令（command）对象将作为负责人，它们会在执行与命令相关的操作前获取编辑器的备忘录。当用户试图撤销最近的命令时，编辑器可以使用保存在命令中的备忘录来将自身回滚到之前的状态。</p>
<p>备忘录类没有声明任何公有的成员变量、 获取器（getter）和设置器，因此没有对象可以修改其内容。备忘录与创建自己的编辑器相连接，这使得备忘录能够通过编辑器对象的设置器传递数据，恢复与其相连接的编辑器的状态。由于备忘录与特定的编辑器对象相连接，程序可以使用中心化的撤销栈实现对多个独立编辑器窗口的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原发器中包含了一些可能会随时间变化的重要数据。它还定义了在备忘录中保存自身状态的方法，以及从备忘录中恢复状态的方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> is</span><br><span class="line">  <span class="keyword">private</span> field text, curX, curY, selectionWidth</span><br><span class="line">  method <span class="title function_">setText</span><span class="params">(text)</span> is</span><br><span class="line">  	<span class="built_in">this</span>.text = text</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">setCursor</span><span class="params">(x, y)</span> is</span><br><span class="line">  	<span class="built_in">this</span>.curX = X</span><br><span class="line">   	<span class="built_in">this</span>.curY = y</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">setSelectionWidth</span><span class="params">(width)</span> is</span><br><span class="line">  	<span class="built_in">this</span>.selectionWidth = width</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//在备忘录中保存当前的状态。</span></span><br><span class="line">  method <span class="title function_">createSnapshot</span><span class="params">()</span>:Snapshot is</span><br><span class="line">  <span class="comment">//备忘录是不可变的对象；因此原发器会将自身状态作为参数传递给备忘录的构造函数。</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(<span class="built_in">this</span>, text, curX, curY, selectionWidth)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//备忘录类保存有编辑器的过往状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snapshot</span> is</span><br><span class="line">  <span class="keyword">private</span> field editor: Editor</span><br><span class="line">  <span class="keyword">private</span> field text, curX, curY, selectionWidth</span><br><span class="line">    </span><br><span class="line">  constructor <span class="title function_">Snapshot</span><span class="params">(editor, text, curX, curY， selectionWidth)</span> is</span><br><span class="line">  	<span class="built_in">this</span>.editor = editor</span><br><span class="line">    <span class="built_in">this</span>.text = text</span><br><span class="line">    <span class="built_in">this</span>.curX = x</span><br><span class="line">    <span class="built_in">this</span>.curY = y</span><br><span class="line">    <span class="built_in">this</span>.selectionWidth = selectionWidth</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在某一时刻，编辑器之前的状态可以使用备忘录对象来恢复。</span></span><br><span class="line">	method <span class="title function_">restore</span><span class="params">()</span> is</span><br><span class="line">    editor.setText(text)</span><br><span class="line">    editor.setCursor(curX, curY)</span><br><span class="line">    editor.setSelectionWidth(selectionWidth)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 命令对象可作为负责人。在这种情况下，命令会在修改原发器状态之前获取一个备忘录。当需要撤销时，它会从备忘录中恢复原发器的状态。</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Command</span> is</span><br><span class="line">    <span class="keyword">private</span> field backup: Snapshot</span><br><span class="line">        </span><br><span class="line">    method <span class="title function_">makeBackup</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">      <span class="variable">backup</span> <span class="operator">=</span> editor.createSnapshot()</span><br><span class="line">      </span><br><span class="line">    method <span class="title function_">undo</span><span class="params">()</span> is</span><br><span class="line">      <span class="title function_">if</span> <span class="params">(backup != <span class="literal">null</span>)</span></span><br><span class="line">        backup.restore()</span><br><span class="line"> <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>当你需要创建对象状态快照来恢复其之前的状态时，可以使用备忘录模式。</strong>  </p>
<p>备忘录模式允许你复制对象中的全部状态（包括私有成员变量），并将其独立于对象进行保存。尽管大部分人因为“撤销”这个用例才记得该模式，但其实它在处理事务（比如需要在出现错误时回滚一个操作）的过程中也必不可少。  </p>
</li>
<li><p><strong>当直接访问对象的成员变量、获取器或设置器将导致封装被突破时，可以使用该模式。</strong>  </p>
<p>备忘录让对象自行负责创建其状态的快照。任何其他对象都不能读取快照，这有效地保障了数据的安全性。</p>
</li>
</ul>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>确定担任原发器角色的类。重要的是明确程序使用的一个原发器中心对象，还是多个较小的对象。</p>
</li>
<li><p>创建备忘录类。逐一声明对应每个原发器成员变量的备忘录成员变量。  </p>
</li>
<li><p>将备忘录类设为不可变。备忘录只能通过构造函数一次性接收数据。该类中不能包含设置器。</p>
</li>
<li><p>如果你所使用的编程语言支持嵌套类，则可将备忘录嵌套在原发器中；如果不支持，那么你可从备忘录类中抽取一个空接口，然后让其他所有对象通过接口来引用备忘录。你可在该接口中添加一些元数据操作，但不能暴露原发器的状态。</p>
</li>
<li><p>在原发器中添加一个创建备忘录的方法。原发器必须通过备忘录构造函数的一个或多个实际参数来将自身状态传递给备忘录。</p>
<p>该方法返回结果的类型必须是你在上一步中抽取的接口（如果你已经抽取了）。实际上，创建备忘录的方法必须直接与备忘录类进行交互。  </p>
</li>
<li><p>在原发器类中添加一个用于恢复自身状态的方法。该方法接受备忘录对象作为参数。如果你在之前的步骤中抽取了接口，那么可将接口作为参数的类型。在这种情况下，你需要将输入对象强制转换为备忘录，因为原发器需要拥有对该对象的完全访问权限。</p>
</li>
<li><p>无论负责人是命令对象、 历史记录或其他完全不同的东西，它都必须要知道何时向原发器请求新的备忘录、如何存储备忘录以及何时使用特定备忘录来对原发器进行恢复。  </p>
</li>
<li><p>负责人与原发器之间的连接可以移动到备忘录类中。在本例中，每个备忘录都必须与创建自己的原发器相连接。恢复方法也可以移动到备忘录类中，但只有当备忘录类嵌套在原发器中，或者原发器类提供了足够多的设置器并可对其状态进行重写时，这种方式才能实现。</p>
</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以在不破坏对象封装情况的前提下创建对象状态快照</li>
<li>你可以通过让负责人维护原发器状态历史记录来简化原发器代码</li>
</ul>
<hr>
<ul>
<li>如果客户端过于频繁地创建备忘录，程序将消耗大量内存</li>
<li>负责人必须完整跟踪原发器的生命周期，这样才能销毁弃用的备忘录</li>
<li>绝大部分动态编程语言（例如 PHP、 Python 和 JavaScript）不能确保备忘录中的状态不被修改</li>
</ul>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>你可以同时使用命令和备忘录来实现“撤销”。在这种情况下，命令用于对目标对象执行各种不同的操作，备忘录用来保存一条命令执行前该对象的状态。  </li>
<li>你可以同时使用备忘录和迭代器来获取当前迭代器的状态，并且在需要的时候进行回滚。</li>
<li>有时候原型可以作为备忘录的一个简化版本，其条件是你需要在历史记录中存储的对象的状态比较简单，不需要链接其他外部资源，或者链接可以方便地重建。</li>
</ul>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><blockquote>
<p>事件订阅者、监听者、Event-Subscriber、Listener、Observer</p>
</blockquote>
<p>观察者是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。</p>
<h3 id="问题背景-5"><a href="#问题背景-5" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你有两种类型的对象： 顾客 和 商店 。顾客对某个特定品牌的产品非常感兴趣（例如最新型号的 iPhone 手机），而该产品很快将会在商店里出售。</p>
<p>顾客可以每天来商店看看产品是否到货。但如果商品尚未到货时，绝大多数来到商店的顾客都会空手而归。</p>
<p>另一方面，每次新产品到货时，商店可以向所有顾客发送邮件（可能会被视为垃圾邮件）。这样，部分顾客就无需反复前往商店了，但也可能会惹恼对新产品没有兴趣的其他顾客。</p>
<h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>拥有一些值得关注的状态的对象通常被称为目标，由于它要将自身的状态改变通知给其他对象，我们也将其称为发布者（publisher）。所有希望关注发布者状态变化的其他对象被称为订阅者（subscribers）。</p>
<p>观察者模式建议你为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。该机制包括 1）一个用于存储订阅者对象引用的列表成员变量；2）几个用于添加或删除该列表中订阅者的公有方法。  </p>
<p><img src="/posts/23570/image-20240510183836914.png" alt="image-20240510183836914"></p>
<p>现在，无论何时发生了重要的发布者事件，它都要遍历订阅者并调用其对象的特定通知方法。</p>
<p>实际应用中可能会有十几个不同的订阅者类跟踪着同一个发布者类的事件， 你不会希望发布者与所有这些类相耦合的。</p>
<p>因此，所有订阅者都必须实现同样的接口，发布者仅通过该接口与订阅者交互。接口中必须声明通知方法及其参数，这样发布者在发出通知时还能传递一些上下文数据。</p>
<p><img src="/posts/23570/image-20240510184407098.png" alt="image-20240510184407098"></p>
<p>如果你的应用中有多个不同类型的发布者，且希望订阅者可兼容所有发布者，那么你甚至可以进一步让所有订阅者遵循同样的接口。该接口仅需描述几个订阅方法即可。这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态。</p>
<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240510184511992.png" alt="image-20240510184511992"></p>
<ol>
<li>发布者（Publisher）会向其他对象发送值得关注的事件。事件会在发布者自身状态改变或执行特定行为后发生。发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li>
<li>当新事件发生时，发送者会遍历订阅列表并调用每个订阅者对象的通知方法。该方法是在订阅者接口中声明的。</li>
<li>订阅者（Subscriber）接口声明了通知接口。 在绝大多数情况下，该接口仅包含一个 update 更新 方法。该方法可以拥有多个参数，使发布者能在更新时传递事件的详细信息。</li>
<li>具体订阅者（Concrete Subscribers）可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口，因此发布者不需要与具体类相耦合。</li>
<li>订阅者通常需要一些上下文信息来正确地处理更新。 因此，发布者通常会将一些上下文数据作为通知方法的参数进行传递。发布者也可将自身作为参数进行传递，使订阅者直接获取所需的数据。</li>
<li>客户端（Client）会分别创建发布者和订阅者对象，然后为订阅者注册发布者更新。</li>
</ol>
<h3 id="伪代码-5"><a href="#伪代码-5" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中，观察者模式允许文本编辑器对象将自身的状态改变通知给其他服务对象。</p>
<p><img src="/posts/23570/image-20240510185054950.png" alt="image-20240510185054950"></p>
<p>订阅者列表是动态生成的：对象可在运行时根据程序需要开始或停止监听通知。</p>
<p>在本实现中，编辑器类自身并不维护订阅列表。它将工作委派给专门从事此工作的一个特殊帮手对象。你还可将该对象升级为中心化的事件分发器，允许任何对象成为发布者。</p>
<p>只要发布者通过同样的接口与所有订阅者进行交互，那么在程序中新增订阅者时就无需修改已有发布者类的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发布者基类包含订阅管理代码和通知方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventManager</span> is</span><br><span class="line">	<span class="keyword">private</span> field listeners: hash map of event types and listeners</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">subscribe</span><span class="params">(eventType, listener） is</span></span><br><span class="line"><span class="params">		listeners.add(eventType, listener)</span></span><br><span class="line">		</span><br><span class="line">  method <span class="title function_">unsubscribe</span><span class="params">(eventType, listener)</span> is</span><br><span class="line">  	listeners.remove(eventType, listener)</span><br><span class="line">  	</span><br><span class="line">  method <span class="title function_">notify</span><span class="params">(eventType, data)</span> is</span><br><span class="line">  	<span class="title function_">foreach</span> <span class="params">(listener in listeners.of(eventType)</span>) <span class="keyword">do</span></span><br><span class="line">  		listener.update(data)</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。</span></span><br><span class="line">                   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> is</span><br><span class="line">	<span class="keyword">public</span> field events: EventManager</span><br><span class="line">	<span class="keyword">private</span> field file:File</span><br><span class="line">	constructor <span class="title function_">Editor</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">events</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventManager</span>()</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 业务逻辑的方法可将变化通知给订阅者。</span></span><br><span class="line">  method <span class="title function_">openFile</span><span class="params">(path)</span> is</span><br><span class="line">   	<span class="built_in">this</span>.file = <span class="keyword">new</span> <span class="title class_">File</span>(path)</span><br><span class="line">   	events.notify(<span class="string">&quot;open&quot;</span>, file.name)</span><br><span class="line">   	</span><br><span class="line">  method <span class="title function_">saveFile</span><span class="params">()</span> is</span><br><span class="line">  	file.write()</span><br><span class="line">  	events.notify(<span class="string">&quot;save&quot;</span>, file.name)</span><br><span class="line">  	</span><br><span class="line"><span class="comment">// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整个订阅者的层次结构。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">EventListener</span> is</span><br><span class="line">	method <span class="title function_">update</span><span class="params">(filename)</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span> is</span><br><span class="line">	<span class="keyword">private</span> field log: File</span><br><span class="line">	<span class="keyword">private</span> field message: string</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">LoggingListener</span><span class="params">(log_filename, message)</span> is</span><br><span class="line">		<span class="built_in">this</span>. log = <span class="keyword">new</span> <span class="title class_">File</span>(log_filename)</span><br><span class="line">		<span class="built_in">this</span>.message = message</span><br><span class="line">		</span><br><span class="line">  method <span class="title function_">update</span><span class="params">(filename)</span> is</span><br><span class="line">  	log.write(replace(<span class="string">&#x27;%s&#x27;</span>,filename,message))</span><br><span class="line">  	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailAlertsListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span> is</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> field email: string</span><br><span class="line">	<span class="keyword">private</span> field message: string</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">EmailAlertsListener</span><span class="params">(email, message)</span> is</span><br><span class="line">		<span class="built_in">this</span>.email = email</span><br><span class="line">		<span class="built_in">this</span>.message = message</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">update</span><span class="params">(filename)</span> is</span><br><span class="line">  	system.email(email, replace(<span class="string">&#x27;%s&#x27;</span>,filename,message))</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line"><span class="comment">// 应用程序可在运行时配置发布者和订阅者。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">	method <span class="title function_">config</span><span class="params">(）is</span></span><br><span class="line"><span class="params">		editor = new Editor()</span></span><br><span class="line">		logger = <span class="keyword">new</span> <span class="title class_">LoggingListener</span>(</span><br><span class="line">			<span class="string">&quot;/path/to/log.txt&quot;</span>,</span><br><span class="line">			“有人打开了文件：%s<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    editor.events.subscribe(&quot;</span>open<span class="string">&quot;, logger)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    emailAlerts = new EmailAlertsListener(</span></span><br><span class="line"><span class="string">    	&quot;</span>admin<span class="meta">@example</span>.com<span class="string">&quot;&quot;</span>,</span><br><span class="line">    	“有人更改了文件：%s<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    	</span></span><br><span class="line"><span class="string">    editor.events.subscribe(&quot;</span>save<span class="string">&quot;, emailAlerts)</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时，可使用观察者模式</strong></p>
<p>当你使用图形用户界面类时通常会遇到一个问题。比如，你创建了自定义按钮类并允许客户端在按钮中注入自定义代码，这样当用户按下按钮时就会触发这些代码。  </p>
<p>观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。你可在按钮中添加订阅机制，允许客户端通过自定义订阅类注入自定义代码。  </p>
</li>
<li><p><strong>当应用中的一些对象必须观察其他对象时，可使用该模式。但仅能在有限时间内或特定情况下使用</strong></p>
<p>订阅列表是动态的，因此订阅者可随时加入或离开该列表。  </p>
</li>
</ul>
<h3 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>仔细检查你的业务逻辑，试着将其拆分为两个部分：独立于其他代码的核心功能将作为发布者；其他代码则将转化为一组订阅类。</li>
<li>声明订阅者接口。该接口至少应声明一个 update 方法。</li>
<li>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。记住发布者必须仅通过订阅者接口与它们进行交互。</li>
<li>确定存放实际订阅列表的位置并实现订阅方法。通常所有类型的发布者代码看上去都一样，因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。具体发布者会扩展该类从而继承所有的订阅行为。</li>
<li>创建具体发布者类。每次发布者发生了重要事件时都必须通知所有的订阅者。  </li>
<li>在具体订阅者类中实现通知更新的方法。绝大部分订阅者需要一些与事件相关的上下文数据。这些数据可作为通知方法的参数来传递。</li>
<li>客户端必须生成所需的全部订阅者，并在相应的发布者处完成注册工作。    </li>
</ol>
<h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>开闭原则。 你无需修改发布者代码就能引入新的订阅者类（如果是发布者接口则可轻松引入发布者类）。</li>
<li>你可以在运行时建立对象之间的联系。</li>
</ul>
<hr>
<ul>
<li>订阅者的通知顺序是随机的。  </li>
</ul>
<h3 id="与其他模式的关系-5"><a href="#与其他模式的关系-5" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p>责任链、命令、中介者和观察者用于处理请求发送者和接收者之间的不同连接方式：  </p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。  </li>
<li>中介者清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><p>中介者和观察者之间的区别往往很难记住。在大部分情况下，你可以使用其中一种模式，而有时可以同时使用。让我们来看看如何做到这一点。  </p>
<p>中介者的主要目标是消除一系列系统组件之间的相互依赖。这些组件将依赖于同一个中介者对象。观察者的目标是在对象之间建立动态的单向连接，使得部分对象可作为其他对象的附属发挥作用。</p>
<p>有一种流行的中介者模式实现方式依赖于观察者。中介者对象担当发布者的角色，其他组件则作为订阅者，可以订阅中介者的事件或取消订阅。当中介者以这种方式实现时，它可能看上去与观察者非常相似。</p>
<p>当你感到疑惑时，记住可以采用其他方式来实现中介者。例如，你可永久性地将所有组件链接到同一个中介者对象。这种实现方式和观察者并不相同，但这仍是一种中介者模式。</p>
<p>假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象，而只有一些分布式的观察者。</p>
</li>
</ul>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><blockquote>
<p>State</p>
</blockquote>
<p>状态是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。</p>
<h3 id="问题背景-6"><a href="#问题背景-6" class="headerlink" title="问题背景"></a>问题背景</h3><p><img src="/posts/23570/image-20240513101303209.png" alt="image-20240513101303209" style="zoom:33%;"></p>
<p>其主要思想是程序在任意时刻仅可处于几种有限的状态中。在任何一个特定状态中，程序的行为都不相同，且可瞬间从一个状态切换到另一个状态。不过，根据当前状态，程序可能会切换到另外一种状态，也可能会保持当前状态不变。这些数量有限且预先定义的状态切换规则被称为转移。</p>
<p>你还可将该方法应用在对象上。 假如你有一个 文档Document 类。 文档可能会处于 草稿 <code>Draft</code> 、 审阅中 <code>Moderation</code> 和 已发布 <code>Published</code> 三种状态中的一种。 文档的 publish 发布 方法在不同状态下的行为略有不同：  </p>
<ul>
<li>处于 草稿 状态时，它会将文档转移到审阅中状态</li>
<li>处于 审阅中 状态时，如果当前用户是管理员，它会公开发布文档。</li>
<li>处于 已发布 状态时，它不会进行任何操作。</li>
</ul>
<p><img src="/posts/23570/image-20240513102217206.png" alt="image-20240513102217206" style="zoom:33%;"></p>
<p>状态机通常由众多条件运算符（ if 或 switch ）实现，可根据对象的当前状态选择相应的行为。“状态”通常只是对象中的一组成员变量值。 即使你之前从未听说过有限状态机，你也很可能已经实现过状态模式。</p>
<p>当我们逐步在 文档 类中添加更多状态和依赖于状态的行为后，基于条件语句的状态机就会暴露其最大的弱点。为了能根据当前状态选择完成相应行为的方法，绝大部分方法中会包含复杂的条件语句。修改其转换逻辑可能会涉及到修改所有方法中的状态条件语句，导致代码的维护工作非常艰难。</p>
<p>这个问题会随着项目进行变得越发严重。我们很难在设计阶段预测到所有可能的状态和转换。随着时间推移，最初仅包含有限条件语句的简洁状态机可能会变成臃肿的一团乱麻。</p>
<h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><p>状态模式建议为对象的所有可能状态新建一个类，然后将所有状态的对应行为抽取到这些类中。  </p>
<p>原始对象被称为上下文（context），它并不会自行实现所有行为，而是会保存一个指向表示当前状态的状态对象的引用，且将所有与状态相关的工作委派给该对象。  </p>
<p><img src="/posts/23570/image-20240513103206910.png" alt="image-20240513103206910"></p>
<p>如需将上下文转换为另外一种状态，则需将当前活动的状态对象替换为另外一个代表新状态的对象。采用这种方式是有前提的：所有状态类都必须遵循同样的接口，而且上下文必须仅通过接口与这些对象进行交互。</p>
<p>这个结构可能看上去与策略模式相似，但有一个关键性的不同——在状态模式中， 特定状态知道其他所有状态的存在，且能触发从一个状态到另一个状态的转换；策略则几乎完全不知道其他策略的存在。 </p>
<h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240513105611909.png" alt="image-20240513105611909"></p>
<ol>
<li><p>上下文（<code>Context</code>）保存了对于一个具体状态对象的引用，并会将所有与该状态相关的工作委派给它。上下文通过状态接口与状态对象交互，且会提供一个设置器用于传递新的状态对象。</p>
</li>
<li><p>状态（<code>State</code>）接口会声明特定于状态的方法。这些方法应能被其他所有具体状态所理解，因为你不希望某些状态所拥有的方法永远不会被调用。</p>
</li>
<li><p>具体状态（<code>Concrete States</code>）会自行实现特定于状态的方法。为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。</p>
<p>状态对象可存储对于上下文对象的反向引用。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移。  </p>
</li>
<li><p>上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p>
</li>
</ol>
<h3 id="伪代码-6"><a href="#伪代码-6" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中，状态模式将根据当前回放状态，让媒体播放器中的相同控件完成不同的行为。  </p>
<p><img src="/posts/23570/image-20240513121036352.png" alt="image-20240513121036352"></p>
<p>播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象，以此改变播放器对于用户互动所作出的反应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//音频播放器（AudioPlayer）类即为上下文。它还会维护指向状态类实例的引用，该状态类则用于表示音频播放器当前的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span> is</span><br><span class="line">  field state:State</span><br><span class="line">  field uI, volume, playlist, currentsong</span><br><span class="line">    </span><br><span class="line">  constructor <span class="title function_">AudioPlayer</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">ReadyState</span>(<span class="built_in">this</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不同的方式处理输入，其结果自然将依赖于当前所处的状态。</span></span><br><span class="line">    UI = <span class="keyword">new</span> <span class="title class_">UserInterface</span>()</span><br><span class="line">    UI.lockButton.onClick(<span class="built_in">this</span>.clickLock)</span><br><span class="line">    UI.nextButton.onClick(<span class="built_in">this</span>.clickNext)</span><br><span class="line">    UI.playButton.onClick(<span class="built_in">this</span>.clickPlay) </span><br><span class="line">    UI.prevButton.onClick(<span class="built_in">this</span>.clickPrevious)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//其他对象必须能切换音频播放器当前所处的状态。</span></span><br><span class="line">  method <span class="title function_">changeState</span><span class="params">(state: State)</span> is</span><br><span class="line">    <span class="built_in">this</span>.state = state</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// UI方法会将执行工作委派给当前状态。</span></span><br><span class="line">  method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">    state.clickLock()</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">    state.clickPlay()</span><br><span class="line">                   </span><br><span class="line"> 	method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">    state.clickNext()</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">    state.clickPrevious()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//状态可调用上下文的一些服务方法。</span></span><br><span class="line">  method <span class="title function_">startPlayback</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  method <span class="title function_">stopPlayback</span><span class="params">()</span> is</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">  method <span class="title function_">nextSong</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  method <span class="title function_">previousSong</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  method <span class="title function_">fastForward</span><span class="params">(time)</span> is</span><br><span class="line">  	<span class="comment">// ...  </span></span><br><span class="line">  method <span class="title function_">rewind</span><span class="params">(time)</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//所有具体状态类都必须实现状态基类声明的方法，并提供反向引用指向与状态相关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。</span></span><br><span class="line">abstractclass State is</span><br><span class="line">  <span class="keyword">protected</span> field player: AudioPlayer</span><br><span class="line">  <span class="comment">//上下文将自身传逆给状态构造函数。这可帮助状态在需要时获取一些有用的上下文数据。</span></span><br><span class="line">  constructor <span class="title function_">State</span><span class="params">(player)</span> is</span><br><span class="line">  	<span class="built_in">this</span>.player = player</span><br><span class="line">	<span class="keyword">abstract</span> method <span class="title function_">clickLock</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">clickPlay</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">clickNext</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">clickPrevious</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//具体状态会实现与上下文状态相关的多种行为。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockedState</span> <span class="keyword">extends</span> <span class="title class_">State</span> is</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 当你解锁一个锁定的播放器时，它可能处于两种状态之一。</span></span><br><span class="line">    method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">      <span class="title function_">if</span> <span class="params">(player.playing)</span></span><br><span class="line">        player.changeState(<span class="keyword">new</span> <span class="title class_">PlayingState</span>(player))</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        player.changeState(<span class="keyword">new</span> <span class="title class_">ReadyState</span>(player))</span><br><span class="line">    method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">    	<span class="comment">// 已锁定，什么也不做。</span></span><br><span class="line">    method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">      <span class="comment">// 已锁定，什么也不做。</span></span><br><span class="line">    method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">      <span class="comment">// 已锁定，什么也不做。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//它们还可在上下文中触发状态转换。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadyState</span> <span class="keyword">extends</span> <span class="title class_">State</span> is</span><br><span class="line">  method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">  	player.changeState(<span class="keyword">new</span> <span class="title class_">Lockedstate</span>(player))</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">  	player.startPlayback()</span><br><span class="line">  	player.changeState(<span class="keyword">new</span> <span class="title class_">Playingstate</span>(player))</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">  	player.nextsong()</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">  	player.previousSong()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayingState</span> <span class="keyword">extends</span> <span class="title class_">State</span> is</span><br><span class="line">  method <span class="title function_">clickLock</span><span class="params">()</span> is</span><br><span class="line">  	player.changeState(<span class="keyword">new</span> <span class="title class_">Lockedstate</span>(player))</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">clickPlay</span><span class="params">()</span> is</span><br><span class="line">  	player.stopPlayback()</span><br><span class="line">  	player.changeState(<span class="keyword">new</span> <span class="title class_">ReadyState</span>(player))</span><br><span class="line">  </span><br><span class="line">	method <span class="title function_">clickNext</span><span class="params">()</span> is</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(event.doubleclick)</span></span><br><span class="line">      player.nextSong()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      player.fastForward(<span class="number">5</span>)</span><br><span class="line">      </span><br><span class="line">  method <span class="title function_">clickPrevious</span><span class="params">()</span> is</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(event.doubleclick)</span></span><br><span class="line">      player.previous()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      player.rewind(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>如果对象需要根据自身当前状态进行不同行为，同时状态的数量非常多且与状态相关的代码会频繁变更的话，可使用状态模式。</strong></p>
<p>模式建议你将所有特定于状态的代码抽取到一组独立的类中。这样一来，你可以在独立于其他状态的情况下添加新状态或修改已有状态，从而减少维护成本。  </p>
</li>
<li><p><strong>如果某个类需要根据成员变量的当前值改变自身行为，从而需要使用大量的条件语句时，可使用该模式。</strong>  </p>
<p>状态模式会将这些条件语句的分支抽取到相应状态类的方法中。同时，你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。  </p>
</li>
<li><p><strong>当相似状态和基于条件的状态机转换中存在许多重复代码时，可使用状态模式。</strong></p>
<p>状态模式让你能够生成状态类层次结构，通过将公用代码抽取到抽象基类中来减少重复。  </p>
</li>
</ul>
<h4 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><p>确定哪些类是上下文。它可能是包含依赖于状态的代码的已有类；如果特定于状态的代码分散在多个类中，那么它可能是一个新的类。</p>
</li>
<li><p>声明状态接口。虽然你可能会需要完全复制上下文中声明的所有方法，但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</p>
</li>
<li><p>为每个实际状态创建一个继承于状态接口的类。然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。</p>
<p>在将代码移动到状态类的过程中，你可能会发现它依赖于上下文中的一些私有成员。你可以采用以下几种变通方式：  </p>
<ul>
<li>将这些成员变量或方法设为公有。</li>
<li>将需要抽取的上下文行为更改为上下文中的公有方法，然后在状态类中调用。这种方式简陋却便捷，你可以稍后再对其进行修补。</li>
<li>将状态类嵌套在上下文类中。这种方式需要你所使用的编程语言支持嵌套类。</li>
</ul>
</li>
<li><p>在上下文类中添加一个状态接口类型的引用成员变量，以及一个用于修改该成员变量值的公有设置器。</p>
</li>
<li><p>再次检查上下文中的方法，将空的条件语句替换为相应的状态对象方法。</p>
</li>
<li><p>为切换上下文状态，你需要创建某个状态类实例并将其传递给上下文。你可以在上下文、各种状态或客户端中完成这项工作。无论在何处完成这项工作，该类都将依赖于其所实例化的具体类。</p>
</li>
</ol>
<h4 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>单一职责原则。将与特定状态相关的代码放在单独的类中。</li>
<li>开闭原则。无需修改已有状态类和上下文就能引入新状态。</li>
<li>通过消除臃肿的状态机条件语句简化上下文代码。</li>
</ul>
<hr>
<ul>
<li>如果状态机只有很少的几个状态，或者很少发生改变，那么应用该模式可能会显得小题大作。</li>
</ul>
<h3 id="与其他模式的关系-6"><a href="#与其他模式的关系-6" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>桥接、状态和策略（在某种程度上包括适配器）模式的接口非常相似。实际上，它们都基于组合模式——即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>状态可被视为策略的扩展。两者都基于组合机制：它们都通过将部分工作委派给“帮手”对象来改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><blockquote>
<p>Strategy</p>
</blockquote>
<p>策略是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。</p>
<h3 id="问题背景-7"><a href="#问题背景-7" class="headerlink" title="问题背景"></a>问题背景</h3><p>一天，你打算为游客们创建一款导游程序。该程序的核心功能是提供美观的地图，以帮助用户在任何城市中快速定位。</p>
<p>用户期待的程序新功能是自动路线规划：他们希望输入地址后就能在地图上看到前往目的地的最快路线。</p>
<p>程序的首个版本只能规划公路路线。驾车旅行的人们对此非常满意。但很显然，并非所有人都会在度假时开车。因此你在下次更新时添加了规划步行路线的功能。此后，你又添加了规划公共交通路线的功能。</p>
<p>而这只是个开始。不久后，你又要为骑行者规划路线。又过了一段时间，你又要为游览城市中的所有景点规划路线。</p>
<p>尽管从商业角度来看，这款应用非常成功，但其技术部分却让你非常头疼：每次添加新的路线规划算法后，导游应用中主要类的体积就会增加一倍。终于在某个时候，你觉得自己没法继续维护这堆代码了</p>
<p>无论是修复简单缺陷还是微调街道权重，对某个算法进行任何修改都会影响整个类，从而增加在已有正常运行代码中引入错误的风险。</p>
<p>此外，团队合作将变得低效。如果你在应用成功发布后招募了团队成员，他们会抱怨在合并冲突的工作上花费了太多时间。在实现新功能的过程中，你的团队需要修改同一个巨大的类，这样他们所编写的代码相互之间就可能会出现冲突。</p>
<h3 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h3><p>策略模式建议找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一组被称为策略的独立类中。</p>
<p>名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。上下文并不执行任务，而是将工作委派给已连接的策略对象。</p>
<p>上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。实际上，上下文并不十分了解策略，它会通过同样的通用接口与所有策略进行交互，而该接口只需暴露一个方法来触发所选策略中封装的算法即可。</p>
<p>因此，上下文可独立于具体策略。这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。</p>
<p><img src="/posts/23570/image-20240513132839728.png" alt="image-20240513132839728"></p>
<p>在导游应用中， 每个路线规划算法都可被抽取到只有一个buildRoute 生成路线 方法的独立类中。该方法接收起点和终点作为参数，并返回路线中途点的集合。</p>
<p>即使传递给每个路径规划类的参数一模一样，其所创建的路线也可能完全不同。主要导游类的主要工作是在地图上渲染一系列中途点，不会在意如何选择算法。该类中还有一个用于切换当前路径规划策略的方法，因此客户端（例如用户界面中的按钮）可用其他策略替换当前选择的路径规划行为。</p>
<h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240513133242266.png" alt="image-20240513133242266"></p>
<ol>
<li>上下文（<code>Context</code>）维护指向具体策略的引用，且仅通过策略<br>接口与该对象进行交流。</li>
<li>策略（<code>Strategy</code>）接口是所有具体策略的通用接口，它声明<br>了一个上下文用于执行策略的方法。</li>
<li>具体策略（<code>Concrete Strategies</code>）实现了上下文所用算法的各<br>种不同变体。</li>
<li>当上下文需要运行算法时，它会在其已连接的策略对象上调<br>用执行方法。上下文不清楚其所涉及的策略类型与算法的执<br>行方式。</li>
<li>客户端（<code>Client</code>）会创建一个特定策略对象并将其传递给上<br>下文。上下文则会提供一个设置器以便客户端在运行时替换<br>相关联的策略</li>
</ol>
<h3 id="伪代码-7"><a href="#伪代码-7" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中，上下文使用了多个策略来执行不同的计算操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口声明了某个算法各个不同版本间所共有的操作。上下文会使用该接口来调用有具体策略定义的算法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> is</span><br><span class="line">	method <span class="title function_">execute</span><span class="params">(a, b)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 具体策略会在遵循策略基础接口的情况下实现算法。该接口实现了它们在上下文中的互换性。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyAdd</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> is</span><br><span class="line">	method <span class="title function_">execute</span><span class="params">(a, b)</span> is</span><br><span class="line">		<span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategySubtract</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> is</span><br><span class="line">	method <span class="title function_">execute</span><span class="params">(a, b)</span> is</span><br><span class="line">		<span class="keyword">return</span> a-b</span><br><span class="line">		</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyMultiply</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> is</span><br><span class="line">	method <span class="title function_">execute</span><span class="params">(a, b)</span> is</span><br><span class="line">		<span class="keyword">return</span> a*b</span><br><span class="line">		</span><br><span class="line"><span class="comment">//上下文定义了客户端关注的接口。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> is</span><br><span class="line"><span class="comment">//上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。上下文必须通过策略接口来与所有策略进行交互。</span></span><br><span class="line">	<span class="keyword">private</span> strategy: Strategy</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 上下文通常会通过构造函数来接收策略对象，同时还提供设置器以便在运行时切换策略。</span></span><br><span class="line">	method <span class="title function_">setstrategy</span><span class="params">(Strategy strategy)</span> is</span><br><span class="line">		<span class="built_in">this</span>.strategy = strategy</span><br><span class="line">		</span><br><span class="line">  <span class="comment">//上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。</span></span><br><span class="line">  method <span class="title function_">executeStrategy</span><span class="params">(<span class="type">int</span> a，<span class="type">int</span> b）is</span></span><br><span class="line"><span class="params">  	return strategy.execute(a, b)</span></span><br><span class="line">  	</span><br><span class="line"><span class="comment">//客户端代码会选择具体策略并将其传递给上下文。客户端必须知晓策略之间的差异，才能做出正确的选择。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleApplication</span> is</span><br><span class="line">	method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">// 创建上下文对象。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取第一个数。</span></span><br><span class="line">    <span class="comment">// 读取最后一个数。</span></span><br><span class="line">    <span class="comment">// 从用户输入中读取期望进行的行为。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (action == addition) then</span><br><span class="line">      context.setstrategy(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyAdd</span>())</span><br><span class="line">    <span class="keyword">if</span> (action == subtraction) then</span><br><span class="line">    	context.setstrategy(<span class="keyword">new</span> <span class="title class_">oncretestrategySubtract</span>())</span><br><span class="line">    <span class="keyword">if</span> (action == multiplication) then</span><br><span class="line">    	context.setStrategy(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyMultiply</span>())</span><br><span class="line">    </span><br><span class="line">    result = context.executeStrategy(First number, Second number)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果。</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>当你想使用对象中各种不同的算法变体，并希望能在运行时切换算法时，可使用策略模式。</strong></p>
<p>策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象，从而以间接方式在运行时更改对象行为。</p>
</li>
<li><p><strong>当你有许多仅在执行某些行为时略有不同的相似类时，可使用策略模式。</strong></p>
<p>策略模式让你能将不同行为抽取到一个独立类层次结构中，并将原始类组合成同一个，从而减少重复代码。</p>
</li>
<li><p><strong>如果算法在上下文的逻辑中不是特别重要，使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</strong></p>
<p>策略模式让你能将各种算法的代码、内部数据和依赖关系与其他代码隔离开来。不同客户端可通过一个简单接口执行算法，并能在运行时进行切换。</p>
</li>
<li><p><strong>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时，可使用该模式。</strong></p>
<p>策略模式将所有继承自同样接口的算法抽取到独立类中，因此不再需要条件语句。 原始对象并不实现所有算法的变体，而是将执行工作委派给其中的一个独立算法对象。  </p>
</li>
</ul>
<h3 id="实现方式-7"><a href="#实现方式-7" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>从上下文类中找出修改频率较高的算法（也可能是用于在运行时选择某个算法变体的复杂条件运算符）。</li>
<li>声明该算法所有变体的通用策略接口。  </li>
<li>将算法逐一抽取到各自的类中，它们都必须实现策略接口。  </li>
<li>在上下文类中添加一个成员变量用于保存对于策略对象的引用。然后提供设置器以修改该成员变量。上下文仅可通过策略接口同策略对象进行交互，如有需要还可定义一个接口来让策略访问其数据。</li>
<li>客户端必须将上下文类与相应策略进行关联，使上下文可以预期的方式完成其主要工作。  </li>
</ol>
<h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以在运行时切换对象内的算法。</li>
<li>你可以将算法的实现和使用算法的代码隔离开来。</li>
<li>你可以使用组合来代替继承。</li>
<li>开闭原则。你无需对上下文进行修改就能够引入新的策略。</li>
</ul>
<hr>
<ul>
<li>如果你的算法极少发生改变，没有任何理由引入新的类和接口，那么使用该模式只会让程序过于复杂。</li>
<li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li>
<li>许多现代编程语言支持函数类型功能，允许你在一组匿名函数中实现不同版本的算法。这样，你使用这些函数的方式就和使用策略对象时完全相同，无需借助额外的类和接口来保持代码简洁。</li>
</ul>
<h3 id="与其他模式的关系-7"><a href="#与其他模式的关系-7" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>桥接、状态和策略（在某种程度上包括适配器）模式的接口非常相似。实际上，它们都基于组合模式——即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>命令和策略看上去很像，因为两者都能通过某些行为来参数化对象。但是，它们的意图有非常大的不同。<ul>
<li>你可以使用命令来将任何操作转换为对象。操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、将操作放入队列、保存历史命令或者向远程服务发送命令等。</li>
<li>另一方面，策略通常可用于描述完成某件事的不同方式，让你能够在同一个上下文类中切换算法。</li>
</ul>
</li>
<li>装饰可让你更改对象的外表，策略则让你能够改变其本质。</li>
<li>模板方法基于继承机制：它允许你通过扩展子类中的部分内容来改变部分算法。策略基于组合机制：你可以通过对相应行为提供不同的策略来改变对象的部分行为。模板方法在类层次上运作，因此它是静态的。策略在对象层次上运作，因此允许在运行时切换行为。</li>
<li>状态可被视为策略的扩展。两者都基于组合机制：它们都通过将部分工作委派给“帮手”对象来改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。</li>
</ul>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><blockquote>
<p>Template Method</p>
</blockquote>
<p>模板方法是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构　　的情况下重写算法的特定步骤。</p>
<h3 id="问题背景-8"><a href="#问题背景-8" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你正在开发一款分析公司文档的数据挖掘程序。用户需要向程序输入各种格式（PDF、DOC 或 CSV）的文档，程序则会试图从这些文件中抽取有意义的数据，并以统一的格式将其返回给用户。</p>
<p>该程序的首个版本仅支持 DOC 文件。 在接下来的一个版本中，程序能够支持 CSV 文件。一个月后，你“教会”了程序从 PDF 文件中抽取数据。  </p>
<p><img src="/posts/23570/image-20240513140306271.png" alt="image-20240513140306271" style="zoom:33%;"></p>
<p>一段时间后，你发现这三个类中包含许多相似代码。尽管这些类处理不同数据格式的代码完全不同，但数据处理和分析的代码却几乎完全一样。如果能在保持算法结构完整的情况下去除重复代码，这难道不是一件很棒的事情吗？</p>
<p>还有另一个与使用这些类的客户端代码相关的问题：客户端代码中包含许多条件语句，以根据不同的处理对象类型选择合适的处理过程。如果所有处理数据的类都拥有相同的接口或基类，那么你就可以去除客户端代码中的条件语句，转而使用多态机制来在处理对象上调用函数。</p>
<h3 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h3><p>模板方法模式建议将算法分解为一系列步骤，然后将这些步骤改写为方法， 最后在“模板方法”中依次调用这些方法。步骤可以是 抽象 的，也可以有一些默认的实现。为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需重写一些步骤（但这一步中不包括模板方法自身）。</p>
<p>让我们考虑如何在数据挖掘应用中实现上述方案。我们可为图中的三个解析算法创建一个基类，该类将定义调用了一系列不同文档处理步骤的模板方法。</p>
<p><img src="/posts/23570/image-20240513140526165.png" alt="image-20240513140526165" style="zoom:33%;"></p>
<p>首先，我们将所有步骤声明为 抽象 类型，强制要求子类自行实现这些方法。在我们的例子中，子类中已有所有必要的实现，因此我们只需调整这些方法的签名，使之与超类的方法匹配即可。  </p>
<p>现在，让我们看看如何去除重复代码。对于不同的数据格式，打开和关闭文件以及抽取和解析数据的代码都不同，因此无需修改这些方法。但分析原始数据和生成报告等其他步骤的实现方式非常相似，因此可将其提取到基类中，以让子类共享这些代码。  </p>
<p>正如你所看到的那样，我们有两种类型的步骤：  </p>
<ul>
<li>抽象步骤必须由各个子类来实现</li>
<li>可选步骤已有一些默认实现，但仍可在需要时进行重写</li>
</ul>
<p>还有另一种名为钩子的步骤。 <strong>钩子是内容为空的可选步骤。</strong>即使不重写钩子，模板方法也能工作。<strong>钩子通常放置在算法重要步骤的前后，为子类提供额外的算法扩展点。</strong>  </p>
<h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240513140821788.png" alt="image-20240513140821788" style="zoom:33%;"></p>
<ol>
<li>抽象类（AbstractClass） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为抽象 类型，也可以提供一些默认实现。</li>
<li>具体类（ConcreteClass）可以重写所有步骤，但不能重写模板方法自身。</li>
</ol>
<h3 id="伪代码-8"><a href="#伪代码-8" class="headerlink" title="伪代码"></a>伪代码</h3><p>本例中的模板方法模式为一款简单策略游戏中人工智能的不同分支提供“框架”  </p>
<p><img src="/posts/23570/image-20240513140912818.png" alt="image-20240513140912818" style="zoom:33%;"></p>
<p>游戏中所有的种族都有几乎同类的单位和建筑。因此你可以在不同的种族上复用相同的 AI 结构，同时还需要具备重写一些细节的能力。通过这种方式，你可以重写半兽人的 AI 使其更富攻击性，也可以让人类侧重防守，还可以禁止怪物建造建筑。在游戏中新增种族需要创建新的 AI 子类，还需要重写AI 基类中所声明的默认方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameAI</span> is</span><br><span class="line">	<span class="comment">//模板方法定义了某个算法的框架。</span></span><br><span class="line">	method <span class="title function_">turn</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">collectResources</span><span class="params">()</span></span><br><span class="line">		buildstructures()</span><br><span class="line">		buildUnits()</span><br><span class="line">		attack()</span><br><span class="line">		</span><br><span class="line">  <span class="comment">//某些步骤可在基类中直接实现。</span></span><br><span class="line">  method <span class="title function_">collectResources</span><span class="params">()</span> is</span><br><span class="line">  	<span class="title function_">foreach</span> <span class="params">(s in <span class="built_in">this</span>.builtstructures)</span> <span class="keyword">do</span></span><br><span class="line">  		s.collect()</span><br><span class="line">  <span class="comment">//某些可定义为抽象类型。</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">buildstructures</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">buildUnits</span><span class="params">()</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一个类可包含多个模板方法。</span></span><br><span class="line">  method <span class="title function_">attack</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">enemy</span> <span class="operator">=</span> closestEnemy()</span><br><span class="line">  	<span class="keyword">if</span> (enemy == <span class="literal">null</span>)</span><br><span class="line">  		sendScouts(map.center)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	sendwarriors(enemy.position)</span><br><span class="line">    	</span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">sendscouts</span><span class="params">(position)</span></span><br><span class="line">  <span class="keyword">abstract</span> method <span class="title function_">sendwarriors</span><span class="params">(position)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//具体类必须实现基类中的所有抽象操作，但是它们不能重写模板方法自身。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrcsAI</span> <span class="keyword">extends</span> <span class="title class_">GameAI</span> is</span><br><span class="line">	method <span class="title function_">buildstructures</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(there are some resources)</span> then</span><br><span class="line">			<span class="comment">//建造农场，接着是谷仓，然后是要塞。</span></span><br><span class="line">			</span><br><span class="line">    method <span class="title function_">buildunits</span><span class="params">()</span> is</span><br><span class="line">    	<span class="title function_">if</span> <span class="params">(there are plenty of resources)</span> then</span><br><span class="line">    		<span class="title function_">if</span> <span class="params">(there are no scouts)</span></span><br><span class="line">    			<span class="comment">// 建造苦工，将其加入侦查编组。</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">          <span class="comment">// 建造兽族步兵，将其加入战士编组。</span></span><br><span class="line"></span><br><span class="line">		method <span class="title function_">sendScouts</span><span class="params">(position)</span> is</span><br><span class="line">			<span class="title function_">if</span> <span class="params">(scouts.length &gt; <span class="number">0</span>)</span> then</span><br><span class="line">				<span class="comment">//将侦查编组送到指定位置。</span></span><br><span class="line">				</span><br><span class="line">    method <span class="title function_">sendwarriors</span><span class="params">(position)</span> is</span><br><span class="line">    	<span class="title function_">if</span> <span class="params">(warriors.length&gt; <span class="number">5</span>)</span> then</span><br><span class="line">    		将战斗编组送到指定位置。</span><br><span class="line">    		</span><br><span class="line"><span class="comment">// 子类可以重写部分默认的操作。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonstersAI</span> <span class="keyword">extends</span> <span class="title class_">GameAI</span> is</span><br><span class="line">	method <span class="title function_">collectResources</span><span class="params">()</span> is</span><br><span class="line">		怪物不会采集资源。</span><br><span class="line">  method <span class="title function_">buildstructures</span><span class="params">()</span> is</span><br><span class="line">  	怪物不会建造建筑。</span><br><span class="line">  method <span class="title function_">buildUnits</span><span class="params">()</span> is</span><br><span class="line">  	怪物不会建造单位。</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式。  </p>
<p>模板方法将整个算法转换为一系列独立的步骤，以便子类能对其进行扩展，同时还可让超类中所定义的结构保持完整。 </p>
</li>
<li><p>当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是，只要算法发生变化，你就可能需要修改所有的类。</p>
<p>在将算法转换为模板方法时，你可将相似的实现步骤提取到超类中以去除重复代码。子类间各不同的代码可继续保留在子类中。  </p>
</li>
</ul>
<h3 id="实现方式-8"><a href="#实现方式-8" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>分析目标算法，确定能否将其分解为多个步骤。从所有子类的角度出发，考虑哪些步骤能够通用，哪些步骤各不相同。</li>
<li>创建抽象基类并声明一个模板方法和代表算法步骤的一系列抽象方法。 在模板方法中根据算法结构依次调用相应步骤。可用 final 最终修饰模板方法以防止子类对其进行重写。  </li>
<li>虽然可将所有步骤全都设为抽象类型，但默认实现可能会给部分步骤带来好处，因为子类无需实现那些方法。</li>
<li>可考虑在算法的关键步骤之间添加钩子。</li>
<li>为每个算法变体新建一个具体子类，它必须实现所有的抽象步骤，也可以重写部分可选步骤。</li>
</ol>
<h3 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可仅允许客户端重写一个大型算法中的特定部分，使得算法其他部分修改对其所造成的影响减小。</li>
<li>你可将重复代码提取到一个超类中。</li>
</ul>
<hr>
<ul>
<li>部分客户端可能会受到算法框架的限制</li>
<li>通过子类抑制默认步骤实现可能会导致违反里氏替换原则 </li>
<li>模板方法中的步骤越多，其维护工作就可能会越困难</li>
</ul>
<h3 id="与其他模式的关系-8"><a href="#与其他模式的关系-8" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>工厂方法是模板方法的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。</li>
<li>模板方法基于继承机制：它允许你通过扩展子类中的部分内容来改变部分算法。策略基于组合机制：你可以通过对相应行为提供不同的策略来改变对象的部分行为。模板方法在类层次上运作，因此它是静态的。策略在对象层次上运作，因此允许在运行时切换行为。</li>
</ul>
<h2 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h2><blockquote>
<p>Visitor</p>
</blockquote>
<p>访问者是一种行为设计模式，它能将算法与其所作用的对象隔离开来。</p>
<h3 id="问题背景-9"><a href="#问题背景-9" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你的团队开发了一款能够使用巨型图像中地理信息的应用程序。图像中的每个节点既能代表复杂实体（例如一座城市）， 也能代表更精细的对象（例如工业区和旅游景点等）。如果节点代表的真实对象之间存在公路，那么这些节点就会相互连接。在程序内部，每个节点的类型都由其所属的类来表示，每个特定的节点则是一个对象。</p>
<p>一段时间后， 你接到了实现将图像导出到 XML 文件中的任务。这些工作最初看上去非常简单。你计划为每个节点类添加导出函数，然后递归执行图像中每个节点的导出函数。解决方案简单且优雅：使用多态机制可以让导出方法的调用代码不会和具体的节点类相耦合。  </p>
<p>但你不太走运，系统架构师拒绝批准对已有节点类进行修改。他认为这些代码已经是产品了，不想冒险对其进行修改，因为修改可能会引入潜在的缺陷。</p>
<p><img src="/posts/23570/image-20240513185628986.png" alt="image-20240513185628986"></p>
<p>此外，他还质疑在节点类中包含导出 XML 文件的代码是否有意义。这些类的主要工作是处理地理数据。导出 XML 文件的代码放在这里并不合适。</p>
<p>还有另一个原因，那就是在此项任务完成后，营销部门很有可能会要求程序提供导出其他类型文件的功能，或者提出其他奇怪的要求。这样你很可能会被迫再次修改这些重要但脆弱的类</p>
<h3 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h3><p>访问者模式建议将新行为放入一个名为访问者的独立类中，而不是试图将其整合到已有类中。现在，需要执行操作的原始对象将作为参数被传递给访问者中的方法，让方法能访问对象所包含的一切必要数据。</p>
<p>如果现在该操作能在不同类的对象上执行会怎么样呢？比如在我们的示例中，各节点类导出 XML 文件的实际实现很可能会稍有不同。因此，访问者类可以定义一组（而不是一个）方法，且每个方法可接收不同类型的参数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IExportVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> is</span><br><span class="line">	method <span class="title function_">doForCity</span><span class="params">(City c)</span>&#123;...&#125;</span><br><span class="line">	method <span class="title function_">doForIndustry</span><span class="params">(Industry f)</span>&#123;...&#125;</span><br><span class="line">	method <span class="title function_">doForSightSeeing</span><span class="params">(SightSeeing ss）&#123;...&#125;</span></span><br><span class="line"><span class="params">	// ...</span></span><br></pre></td></tr></table></figure>
<p>但我们究竟应该如何调用这些方法（尤其是在处理整个图像方面）呢？这些方法的签名各不相同，因此我们不能使用多态机制。 为了可以挑选出能够处理特定对象的访问者方法，我们需要对它的类进行检查。这是不是听上去像个噩梦呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foreach (Node node in graph)</span><br><span class="line">	<span class="keyword">if</span> (node <span class="keyword">instanceof</span> City)</span><br><span class="line">		exportVisitor.doForcity((city) node)</span><br><span class="line">  <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Industry)</span><br><span class="line">  	exportVisitor.doForIndustry((Industry) node)</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>你可能会问，我们为什么不使用方法重载呢？就是使用相同的方法名称，但它们的参数不同。不幸的是，即使我们的编程语言（例如 Java 和 C#）支持重载也不行。由于我们无法提前知晓节点对象所属的类，所以重载机制无法执行正确的方法。方法会将 节点 基类作为输入参数的默认类型。  </p>
<p>但是，访问者模式可以解决这个问题。它使用了一种名为双分派的技巧，不使用累赘的条件语句也可执行正确的方法。与其让客户端来选择调用正确版本的方法，不如将选择权委派给作为参数传递给访问者的对象。由于该对象知晓其自身的类，因此能更自然地在访问者中选出正确的方法。它们会“接收”一个访问者并告诉其应执行的访问者方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line">foreach(Node node in graph)</span><br><span class="line">  node.accept(exportVisitor)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 城市</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span> is</span><br><span class="line">  method <span class="title function_">accept</span><span class="params">(Visitor v)</span> is</span><br><span class="line">  	V.doForCity(<span class="built_in">this</span>)</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 工业区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Industry</span> is</span><br><span class="line">  method <span class="title function_">accept</span><span class="params">(Visitor v)</span> is</span><br><span class="line">  	V.doForIndustry(<span class="built_in">this</span>)</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>我承认最终还是修改了节点类，但毕竟改动很小，且使得我们能够在后续进一步添加行为时无需再次修改代码</p>
<p>现在，如果我们抽取出所有访问者的通用接口，所有已有的节点都能与我们在程序中引入的任何访问者交互。如果需要引入与节点相关的某个行为，你只需要实现一个新的访问者类即可。</p>
<h3 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/23570/image-20240513190647685.png" alt="image-20240513190647685" style="zoom:33%;"></p>
<ol>
<li>访问者（Visitor）接口声明了一系列以对象结构的具体元素为参数的访问者方法。如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。</li>
<li>具体访问者（Concrete Visitor）会为不同的具体元素类实现相同行为的几个不同版本。</li>
<li>元素（Element） 接口声明了一个方法来“接收” 访问者。该方法必须有一个参数被声明为访问者接口类型。</li>
<li>具体元素（Concrete Element）必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。请注意，即使元素基类实现了该方法，所有子类都必须对其进行重写并调用访问者对象中的合适方法。  </li>
<li>客户端（Client）通常会作为集合或其他复杂对象（例如一个组合树）的代表。 客户端通常不知晓所有的具体元素类，因为它们会通过抽象接口与集合中的对象进行交互。</li>
</ol>
<h3 id="伪代码-9"><a href="#伪代码-9" class="headerlink" title="伪代码"></a>伪代码</h3><p>在本例中，访问者模式为几何图像层次结构添加了对于 XML文件导出功能的支持。  </p>
<p><img src="/posts/23570/image-20240513190955375.png" alt="image-20240513190955375" style="zoom:33%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元素接口声明了一个accept（接收）方法，它会将访问者基础接口作为一个参数。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> is</span><br><span class="line">	method <span class="title function_">move</span><span class="params">(x, y)</span></span><br><span class="line">	method <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">accept</span><span class="params">(v: Visitor)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//每个具体元素类都必须以特定方式实现方法，使其能调用相应元素类的T访问者方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dot</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//注意我们正在调用的&#x27;visitDot（访问点）&#x27;方法与当前类的名称相匹配。这样我们能让访问者知晓与其交互的元素类。</span></span><br><span class="line">	method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">		V.visitDot(<span class="built_in">this</span>)</span><br><span class="line">		</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">		V.visitcircle(<span class="built_in">this</span>)</span><br><span class="line">		</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">	method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">		V.visitRectangle(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compoundshape</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	method <span class="title function_">accept</span><span class="params">(v: Visitor)</span> is</span><br><span class="line">		V.visitcompoundshape(<span class="built_in">this</span>)</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准确辨别出与其交互的元素所属的类。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">visitor</span> is</span><br><span class="line">	method <span class="title function_">visitDot</span><span class="params">(d: Dot)</span></span><br><span class="line">	method <span class="title function_">visitcircle</span><span class="params">(c: Circle)</span></span><br><span class="line">  method <span class="title function_">visitRectangle</span><span class="params">(r: Rectangle)</span></span><br><span class="line">	method <span class="title function_">visitCompoundshape</span><span class="params">(cs: CompoundShape)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问者方法。这可能会非常有帮助。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XMLExportVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> is</span><br><span class="line">	method <span class="title function_">visitDot</span><span class="params">(d: Dot)</span> is</span><br><span class="line">		<span class="comment">// 导出点（dot）的ID和中心坐标。</span></span><br><span class="line">	method <span class="title function_">visitcircle</span><span class="params">(c: Circle)</span> is</span><br><span class="line">		<span class="comment">// 导出圆（circle）的ID、中心坐标和半径。</span></span><br><span class="line">	method <span class="title function_">visitRectangle</span><span class="params">(r: Rectangle)</span> is</span><br><span class="line">		<span class="comment">// 导出长方形（rectangle）的ID、左上角坐标、宽和长。</span></span><br><span class="line">	method <span class="title function_">visitcompoundshape</span><span class="params">(cs: CompoundShape)</span> is</span><br><span class="line">		<span class="comment">// 导出图形（shape）的ID和其子项目的ID列表。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收&quot;操作会将调用定位到访问者对象的相应操作上。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">	field allshapes: array of shapes</span><br><span class="line">	method <span class="title function_">export</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">exportVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLExportVisitor</span>()</span><br><span class="line">		</span><br><span class="line">		foreach (shape in allshapes) <span class="keyword">do</span></span><br><span class="line">			shape.accept(exportVisitor)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>如果你需要对一个复杂对象结构（例如对象树）中的所有元素执行某些操作，可使用访问者模式</strong></p>
<p>访问者模式通过在访问者对象中为多个目标类提供相同操作的变体，让你能在属于不同类的一组对象上执行同一操作</p>
</li>
<li><p><strong>可使用访问者模式来清理辅助行为的业务逻辑</strong></p>
<p>该模式会将所有非主要的行为抽取到一组访问者类中，使得程序的主要类能更专注于主要的工作</p>
</li>
<li><p><strong>当某个行为仅在类层次结构中的一些类中有意义，而在其他类中没有意义时，可使用该模式</strong></p>
<p>你可将该行为抽取到单独的访问者类中，只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可</p>
</li>
</ul>
<h3 id="实现方式-9"><a href="#实现方式-9" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>在访问者接口中声明一组“访问”方法，分别对应程序中的每个具体元素类。</p>
</li>
<li><p>声明元素接口。如果程序中已有元素类层次接口，可在层次结构基类中添加抽象的“接收”方法。该方法必须接受访问者对象作为参数。  </p>
</li>
<li><p>在所有具体元素类中实现接收方法。这些方法必须将调用重定向到当前元素对应的访问者对象中的访问者方法上。  </p>
</li>
<li><p>元素类只能通过访问者接口与访问者进行交互。不过访问者必须知晓所有的具体元素类，因为这些类在访问者方法中都被作为参数类型引用。</p>
</li>
<li><p>为每个无法在元素层次结构中实现的行为创建一个具体访问者类并实现所有的访问者方法</p>
<p>你可能会遇到访问者需要访问元素类的部分私有成员变量的情况。在这种情况下，你要么将这些变量或方法设为公有，这将破坏元素的封装；要么将访问者类嵌入到元素类中。后一种方式只有在支持嵌套类的编程语言中才可能实现。  </p>
</li>
<li><p>客户端必须创建访问者对象并通过“接收”方法将其传递给元素。</p>
</li>
</ol>
<h3 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>开闭原则。你可以引入在不同类对象上执行的新行为，且无需对这些类做出修改。</li>
<li>单一职责原则。可将同一行为的不同版本移到同一个类中</li>
<li>访问者对象可以在与各种对象交互时收集一些有用的信息。当你想要遍历一些复杂的对象结构（例如对象树），并在结构中的每个对象上应用访问者时，这些信息可能会有所帮助。</li>
</ul>
<hr>
<ul>
<li>每次在元素层次结构中添加或移除一个类时，你都要更新所有的访问者。</li>
<li>在访问者同某个元素进行交互时，它们可能没有访问元素私有成员变量和方法的必要权限。</li>
</ul>
<h3 id="与其他模式的关系-9"><a href="#与其他模式的关系-9" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>你可以将访问者视为命令模式的加强版本，其对象可对不同类的多种对象执行操作。</li>
<li>你可以使用访问者对整个组合树执行操作</li>
<li>可以同时使用访问者和迭代器来遍历复杂数据结构，并对其中的元素执行所需操作，即使这些元素所属的类完全不同</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-SOLID原则</title>
    <url>/posts/12321.html</url>
    <content><![CDATA[<h1 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h1><p>SOLID能够让软件设计更易于理解、更加灵活和更易于维护，但是盲目遵守这些原则可能会弊大于利，在程序架构中应用这些原则可能会使其变得过于复杂，所以还是需要从实用的角度出发来考量是否需要应用这些原则。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><blockquote>
<p>Single Responsibility Principle：修改一个类的原因只能有一个  </p>
</blockquote>
<p>尽量让每个类只负责软件中的一个功能，并将该功能完全封装（你也可称之为隐藏）在该类中。</p>
<p>这条原则的主要目的是减少复杂度，应用该原则的主要原因如下：</p>
<ol>
<li>当程序规模不断扩大、变更不断增加后，真实问题才会逐渐显现出来。此时，类会变得过于庞大，以至于无法记住其细节。查找代码将变得非常缓慢，修复bug、扩展功能都会很难。</li>
<li>如果类负责的东西太多，那么当其中任何一件事发生改变时，你都必须对类进行修改。而在进行修改时，你就有可能改动类中自己并不希望改动的部分。</li>
</ol>
<p><strong>示例</strong></p>
<p><img src="/posts/12321/image-20240226184504917.png" alt="image-20240226184504917"></p>
<p>虽然打印考勤表属于雇员行为，但是雇员不应该负责打印考勤表报告，因为该类的主要功能应该是管理雇员的基本属性，且考勤表的格式可能会改变，这样就需要对类中的代码进行修改。</p>
<p><img src="/posts/12321/image-20240226184659828.png" alt="image-20240226184659828"></p>
<p>解决该问题的方法是将该行为移动到一个单独的类中，专门实现接收雇员的方法。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><blockquote>
<p>Open/closed Principle：对于扩展，类应该是“开放”的；对于修改，类则应是“封闭”的</p>
</blockquote>
<p>在实现新功能时能保持已有代码不变。开放和封闭定义如下：</p>
<ul>
<li>如果你可以对一个类进行扩展，可以创建它的子类并对其做任何事情（如新增方法或成员变量、重写基类行为等），那么它就是开放的  </li>
<li>有些编程语言允许你通过特殊关键字（例如 final ）来限制对于类的进一步扩展， 这样类就不再是“开放”的了。如果某个类已做好了充分的准备并可供其他类使用的话（即其接口已明确定义且以后不会修改），那么该类就是封闭（你可以称之为完整）的  </li>
</ul>
<p>如果一个类已经完成开发、测试和审核工作，而且属于某个框架或者可被其他类的代码直接使用的话，对其代码进行修改就是有风险的。你可以创建一个子类并重写原始类的部分内容以完成不同的行为，而不是直接对原始类的代码进行修改。</p>
<p>当然，如果该类本身就存在问题，那么只需要进行修复即可，而不是留到子类去修复。</p>
<p><strong>示例</strong></p>
<p><img src="/posts/12321/image-20240226190305820.png" alt="image-20240226190305820"></p>
<p>不同的运输方式计算方式不一样，新增运输方式时，就需要对<code>Order</code>类进行修改，破坏其封闭原则</p>
<p><img src="/posts/12321/image-20240226190723449.png" alt="image-20240226190723449"></p>
<p>通过应用策略模式，将运输方法抽取为接口，然后不同的运输方法用实现该接口的不同类实现。这样，添加新的运输方式，只需要实现<code>Shipping</code>接口，完善业务代码即可，而无需修改<code>Order</code>中的<code>getShippingCost</code>方法。</p>
<p>此外，根据单一职责原则，计算运输时间的方法也可以剥离到更为相关的类中</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><blockquote>
<p>Liskov Substitution Principle：当你扩展一个类时， 记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。  </p>
</blockquote>
<p>子类必须保持与父类行为的兼容。在重写一个方法时，你要对基类行为进行扩展，而不是将其完全替换。  </p>
<p>替代原则包含一组对子类（特别是其方法）的形式要求：</p>
<ol>
<li><p><strong>子类方法的参数类型必须与其超类的参数类型相匹配或更抽象</strong></p>
<p> 假设有一个方法<code>feed(Cat c)</code>。</p>
<p> <strong>满足要求的实现方式</strong>：<code>feed(Animal c)</code>，如果现在你将一个子类对象而非超类对象传递给客户端代码，程序仍将正常工作。该方法可用于给任何动物喂食，因此它仍然可以用于给传递给客户端的任何“猫”喂食。</p>
<p> <strong>不满足要求的实现方式</strong>：<code>feed(BengalCat c)</code>，即创建了另一个子类且限制喂食方法仅接 受 “孟 加 拉 猫 （<code>BengalCat</code>， 一 个 ‘猫’ 的 子 类）。此时，如果用它来替代链接在某个对象中的原始类，客户端中会发生什么呢？由于该方法只能对特殊种类的猫进行喂食，因此无法为传递给客户端的普通猫提供服务，从而将破坏所有相关的功能。</p>
</li>
<li><p><strong>子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配</strong></p>
<p> 假如你的一个类中有一个方法<code>buyCat(): Cat</code>。 客户端代码执行该方法后的预期返回结果是任意类型的“猫”。</p>
<p> <strong>满足要求的实现方式</strong>： <code>buyCat(): BengalCat</code>。客户端将获得一只“孟加拉猫”，自然它也是一只“猫”，因此一切正常。</p>
<p> <strong>不满足要求的实现方式</strong>：<code>buyCat(): Animal</code>。客户端代码将会出错，因为它获得的是自己未知的动物种类（短吻鳄？熊？），不适用于为一只“猫”而设计的结构。</p>
</li>
<li><p><strong>子类中的方法不应抛出基础方法预期之外的异常类型</strong></p>
<p> 异常类型必须与基础方法能抛出的异常或是其子类别相匹配。这是因为，客户端的<code>try-catch</code>代码块针对的是基础方法可能抛出的异常类型。因此，预期之外的异常可能会穿透客户端的防御代码，从而使整个应用崩溃。  </p>
<blockquote>
<p>实际上，上述规则已经内置于大部分的编程语言中</p>
</blockquote>
</li>
<li><p><strong>子类不应该加强其前置条件</strong></p>
<p> 例如，基类的方法有一个 int类型的参数。如果子类重写该方法时，要求传递给该方法的参数值必须为正数（如果该值为负则抛出异常），这就是加强了前置条件。客户端代码之前将负数传递给该方法时程序能够正常运行，但现在使用子类的对象时会使程序出错。</p>
</li>
<li><p><strong>子类不应该削弱其后置条件</strong></p>
<p> 假如你的某个类中有个方法需要使用数据库，该方法应该在接收到返回值后关闭所有活跃的数据库连接。</p>
<p> 你创建了一个子类并对其进行了修改，使得数据库保持连接以便重用。但客户端可能对你的意图一无所知。由于它认为该方法会关闭所有的连接，因此可能会在调用该方法后就马上关闭程序，使得无用的数据库连接对系统造成“污染”  。</p>
</li>
<li><p><strong>超类的不变量必须保留</strong></p>
<p> 因此，扩展一个类的最安全做法是引入新的成员变量和方法，而不要去招惹超类中已有的成员。</p>
</li>
<li><p><strong>子类不能修改超类中私有成员变量的值</strong></p>
<p> 因为包括java在内的编程语言，可以通过反射机制实现上述操作。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<p><img src="/posts/12321/image-20240226192828494.png" alt="image-20240226192828494"></p>
<p>只读文件<code>ReadOnlyDocuments</code>子类中的<code>save</code>保存方法会在被调用时抛出一个异常。基础方法则没有这个限制。这意味着如果我们没有在保存前检查文档类型，客户端代码将会出错。  </p>
<p>代码也将违反开闭原则，因为客户端代码将依赖于具体的文档类。如果你引入了新的文档子类，则需要修改客户端代码才能对其进行支持。</p>
<p><img src="/posts/12321/image-20240226193046853.png" alt="image-20240226193046853"></p>
<p><code>ReadOnlyDocument→Document</code>：一个子类必须扩展其超类的行为，因此只读文档变成了层次结构中的基类。可写文件现在变成了子类，对基类进行扩展并添加了保存行为。  </p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><blockquote>
<p>Interface Segregation Principle：客户端不应被强迫依赖于其不使用的方法</p>
</blockquote>
<p>尽量缩小接口的范围，使得客户端的类不必实现其不需要的行为。根据接口隔离原则，你必须将“臃肿”的方法拆分为多个颗粒度更小的具体方法。客户端必须仅实现其实际需要的方法。否则，对于“臃肿”接口的修改可能会导致程序出错，即使客户端根本没有使用修改后的方法  </p>
<p><strong>示例</strong></p>
<p>假如你创建了一个程序库，它能让程序方便地与多种云计算供应商进行整合。尽管最初版本仅支持阿里云服务，但它也覆盖了一套完整的云服务和功能。  </p>
<p>假设所有云服务供应商都与阿里云一样提供相同种类的功能。但当你着手为其他供应商提供支持时，程序库中绝大部分的接口会显得过于宽泛。其他云服务供应商没有提供部分方法所描述的功能。  </p>
<p><img src="/posts/12321/image-20240226193535876.png" alt="image-20240226193535876"></p>
<p>尽管你仍然可以去实现这些方法并放入一些桩代码，但这绝不是优良的解决方案。更好的方法是将接口拆分为多个部分。能够实现原始接口的类现在只需改为实现多个精细的接口即可。其他类则可仅实现对自己有意义的接口。</p>
<p><img src="/posts/12321/image-20240226193624769.png" alt="image-20240226193624769"></p>
<p>但是，创建的接口越多，代码就越复杂，因此要保持平衡。  </p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><blockquote>
<p>Dependency Inversion Principle：高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。</p>
</blockquote>
<p>不同层次的类：</p>
<ul>
<li>低层次的类实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）</li>
<li>高层次类包含复杂业务逻辑以指导低层次类执行特定操作</li>
</ul>
<p>这是非常容易违反的原则：由于低层次的东西还没有实现或不确定，你甚至无法确定高层次类能实现哪些功能，所以有时我们会先设计低层次的类， 然后才会开发高层次的类。如果采用这种方式，业务逻辑类可能会更依赖于低层原语类。</p>
<p>依赖倒置原则则建议改变这种依赖方向：</p>
<ol>
<li>作为初学者， 你最好使用业务术语来对高层次类依赖的低层次操作接口进行描述。例如， 业务逻辑应该调用名为<code>openReport(file)</code>的方法， 而不是<code>openFile(x)</code>、<code>readBytes(n)</code>和<code>closeFile(x)</code>等一系列方法</li>
<li>现在你可基于这些接口创建高层次类，而不是基于低层次的具体类</li>
<li>一旦低层次的类实现了这些接口，它们将依赖于业务逻辑层，从而倒置了原始的依赖关系</li>
</ol>
<p><strong>示例</strong></p>
<p>高层次的预算报告类（<code>BudgetReport</code>）使用低层次的数据库类（<code>MySQLDatabase</code>）来读取和保存其数据。这意味着低层次类中的任何改变（例如当数据库服务器发布新版本时）都可能会影响到高层次的类，但高层次的类不应关注数据存储的细节。</p>
<p><img src="/posts/12321/image-20240226194200993.png" alt="image-20240226194200993"></p>
<p>可以创建一个描述读写操作的高层接口，并让报告类使用该接口代替低层次的类。然后你可以修改或扩展低层次的原始类来实现业务逻辑声明的读写接口  </p>
<p><img src="/posts/12321/image-20240226194246267.png" alt="image-20240226194246267"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-简介</title>
    <url>/posts/8883.html</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="模式是什么"><a href="#模式是什么" class="headerlink" title="模式是什么"></a>模式是什么</h3><p>设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。  </p>
<h4 id="模式-vs-库"><a href="#模式-vs-库" class="headerlink" title="模式 vs 库"></a>模式 vs 库</h4><p>库中的方法可以直接调用，但是很难直接在自己的程序中套用某个设计模式。模式并不是一段特定的代码，而是解决特定问题的一般性概念。你可以根据模式来实现符合自己程序实际所需的解决方案  </p>
<h4 id="模式-vs-算法"><a href="#模式-vs-算法" class="headerlink" title="模式 vs 算法"></a>模式 vs 算法</h4><p>算法总是明确定义达成特定目标所需的一系列步骤，而模式则是对解决方案的更高层次描述。  </p>
<p>算法更像是菜谱：提供达成目标的明确步骤。而模式更像是蓝图：你可以看到最终的结果和模式的功能，但需要自己确定实现步骤  </p>
<h3 id="模式如何描述"><a href="#模式如何描述" class="headerlink" title="模式如何描述"></a>模式如何描述</h3><p>模式的描述通常会包括以下部分：</p>
<ol>
<li><strong>意图部分</strong>简要地描述问题和解决方案  </li>
<li><strong>动机部分</strong>进一步解释问题并说明模式会如何提供解决方案。</li>
<li><strong>结构部分</strong>展示模式的各个部分和它们之间的关系。</li>
<li><strong>在不同语言中的实现</strong>提供流行编程语言的代码，让读者更好地理解模式背后的思想</li>
</ol>
<h3 id="模式的分类"><a href="#模式的分类" class="headerlink" title="模式的分类"></a>模式的分类</h3><p>不同设计模式在其复杂程度、细节层次以及在整个系统中的应用范围等方面各不相同。我喜欢将其比作道路的建造：如果你希望让十字路口更加安全，那么可以安装一些交通信号灯，或者修建有行人地下通道的多层互通式立交桥。  </p>
<ul>
<li>最基础的、底层的模式通常被称为<strong>惯用技巧</strong>。这类模式一般只能在一种编程语言中使用。</li>
<li>最通用的、高层的模式是<strong>架构模式</strong>。开发者可以在任何编程语言中使用这类模式。与其他模式不同，它们可用于整个应用程序的架构设计。</li>
</ul>
<p>此外，可以根据意图或目的来分类：</p>
<ul>
<li><strong>创建型模式</strong>。提供创建对象的机制，增加已有代码的灵活性和可复用性。</li>
<li><strong>结构型模式</strong>。介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。</li>
<li><strong>行为模式</strong>。负责对象间的高效沟通和职责委派。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-设计原则</title>
    <url>/posts/18543.html</url>
    <content><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h2><p>无论是开发何种软件产品，成本和时间都是最重要的两个维度。较短的开发时间意味着可比竞争对手更早进入市场；较低的开发成本意味着能够留出更多营销资金，因此能更广泛地覆盖潜在客户。</p>
<p><strong>代码复用</strong>是减少开发成本时最常用的方式之一。其意图非常明显：与其反复从头开发，不如在新对象中重用已有代码。但实际上要让已有代码在全新的上下文中工作，通常还是需要付出额外努力的。<strong>组件间紧密的耦合</strong>、<strong>对具体类而非接口的依赖</strong>和<strong>硬编码的行为</strong>都会降低代码的灵活性，使得复用这些代码变得更加困难。<strong>使用设计模式是增加软件组件灵活性并使其易于复用的方式之一</strong>。但是有时，这也会让组件变得更加复杂。</p>
<p>复用可以认为有三个层次，而设计模式通常扮演中间层：</p>
<ol>
<li><p>复用的最底层是类：类库、容器、迭代器等</p>
</li>
<li><p>复用的最高层是框架：能帮助你精简自己的设计，可以用于明确解决问题所需的抽象概念，然后用类来表示这些概念并定义其关系。框架通常比单个类的颗粒度要大。 你可以通过在某处构建子类来与框架建立联系。 这些子类信奉“别给我们打电话，我们会给你打电话的。”   框架让你可以自定义行为， 并会在需要完成工作时告知你。 这和 JUnit 一样，对吧？当它希望执行测试时就会告诉你，但其他的一切都仅会在框架中发生。  </p>
<p> <code>JUnit</code>是一个小型框架， 也是框架的“Hello, world”， 其中定义了<code>Test</code> 、<code>TestCase</code> 和<code>TestSuite</code>这几个类及其关系。  </p>
</li>
<li><p>复用的中间层次就是设计模式。设计模式比框架更小且更抽象。 它们实际上是对一组类的关系及其互动方式的描述。当你从类转向模式，并最终到达框架的过程中，复用程度会不断增加。</p>
<p> 中间层次的优点在于模式提供的复用方式要比框架的风险小。创建框架是一项投入重大且风险很高的工作。 模式则让你能独立于具体代码来复用设计思想和理念。  </p>
</li>
</ol>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>程序经常变化：平台迁移、UI变化、功能拓展等，优秀的设计模式能够支撑程序较好的扩展性</p>
<h2 id="封装变化的内容"><a href="#封装变化的内容" class="headerlink" title="封装变化的内容"></a>封装变化的内容</h2><blockquote>
<p>找到程序中的变化内容并将其与不变的内容区分开，这样能够将变更造成的影响最小化</p>
</blockquote>
<h3 id="方法层面的封装"><a href="#方法层面的封装" class="headerlink" title="方法层面的封装"></a>方法层面的封装</h3><p>假如开发一个电子商务网站。 代码中某处有一个<code>getOrderTotal</code> 获取订单总额的方法， 用于计算订单的总价（包括税金在内）。预计在未来可能会修改与税金相关的代码。税率会根据客户居住的国家/地区、州/省甚至城市而有所不同；而且一段时间后，实际的计算公式可能会由于新的法律或规定而修改，这就导致将需要经常性地修改<code>getOrderTotal</code>方法，因此可以选择将税相关的代码剥离出去。</p>
<p><strong>修改前</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method <span class="title function_">getOrderTotal</span><span class="params">(order)</span> <span class="type">is</span></span><br><span class="line">	<span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">	foreach item in order.lineItems</span><br><span class="line">		total += item.price * item.quantity</span><br><span class="line">	<span class="title function_">if</span> <span class="params">(order.country == <span class="string">&quot;US&quot;</span>)</span></span><br><span class="line">		total += total * <span class="number">0.07</span> <span class="comment">// 美国营业税</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (order.country == <span class="string">&quot;EU&quot;</span>):</span><br><span class="line">		total += total * <span class="number">0.20</span> <span class="comment">// 欧洲增值税</span></span><br><span class="line">	<span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<p><strong>修改后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method <span class="title function_">getOrderTotal</span><span class="params">(order)</span> <span class="type">is</span></span><br><span class="line">	<span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">	foreach item in order.lineItems</span><br><span class="line">		total += item.price * item.quantity</span><br><span class="line">	total += total * getTaxRate(order.country)</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">	</span><br><span class="line">method <span class="title function_">getTaxRate</span><span class="params">(country)</span> is</span><br><span class="line">	<span class="title function_">if</span> <span class="params">(country == <span class="string">&quot;US&quot;</span>)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.07</span> <span class="comment">// 美国营业税</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (country == <span class="string">&quot;EU&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.20</span> <span class="comment">// 欧洲增值税</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="类层面的封装"><a href="#类层面的封装" class="headerlink" title="类层面的封装"></a>类层面的封装</h3><p>一段时间后，你可能会在一个以前完成简单工作的方法中添加越来越多的职责。新增行为通常还会带来助手成员变量和方法，最终使得包含接纳它们的类的主要职责变得模糊。将所有这些内容抽取到一个新类中会让程序更加清晰和简洁。  </p>
<p><img src="/posts/18543/image-20240225143448249.png" alt="image-20240225143448249"></p>
<p>修改前，在订单中计算税金</p>
<p><img src="/posts/18543/image-20240225143517925.png" alt="image-20240225143517925"></p>
<p>修改后，将订单类中所有与税金相关的工作委派给一个专门负责的特殊对象。  </p>
<h2 id="面向接口进行开发，而不是面向实现"><a href="#面向接口进行开发，而不是面向实现" class="headerlink" title="面向接口进行开发，而不是面向实现"></a>面向接口进行开发，而不是面向实现</h2><blockquote>
<p>面向接口进行开发，而不是面向实现；依赖于抽象类型，而不是具体类。</p>
</blockquote>
<p>如果无需修改已有代码就能轻松对类进行扩展，那就可以说这样的设计是灵活的  </p>
<p>当你需要两个类进行合作时，可以让其中一个类依赖于另一个类，但是可以用如下更为灵活的方式：</p>
<ol>
<li>确定一个对象对另一对象的确切需求：它需执行哪些方法？</li>
<li>在一个新的接口或抽象类中描述这些方法。</li>
<li>让被依赖的类实现该接口。</li>
<li>现在让有需求的类依赖于这个接口， 而不依赖于具体的类。你仍可与原始类中的对象进行互动，但现在其连接将会灵活得多。  </li>
</ol>
<p><img src="/posts/18543/image-20240225144305488.png" alt="image-20240225144305488"></p>
<p>类似：一只可以吃任何食物的猫<code>Cat</code>要比只吃香肠的猫更加灵活  </p>
<p><strong>这样设计的优势？</strong></p>
<p><img src="/posts/18543/image-20240225144657457.png" alt="image-20240225144657457"></p>
<p>首先，可以归纳出几个与工作相关的方法，并将其提取未所有员工的通用接口，并运用多态机制，实现不同员工做不同处理</p>
<p><img src="/posts/18543/image-20240225144811303.png" alt="image-20240225144811303"></p>
<p>但是，公司的其他部分仍然依赖于具体的雇员类，这样如果引入包含其他类型雇员的公司类型的话，<strong>我们就需要重写绝大部分的公司类了，不能复用其代码</strong>。  为此，我们可以声明一个抽象方法来获取雇员，每个具体公司都将以不同的方式实现该方法，从而创建自己公司的雇员。</p>
<p><img src="/posts/18543/image-20240225145020407.png" alt="image-20240225145020407"></p>
<p>修改后的 公司 类将独立于各种雇员类。现在你可以对该类进行扩展，并在复用部分公司基类的情况下引入新的公司和雇员类型。对公司基类进行扩展时无需修改任何依赖于基类的已有代码。[<strong>工厂模式</strong>]</p>
<h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>继承可能是类之间最明显、最简便的代码复用方式。如果你有两个代码相同的类， 就可以为它们创建一个通用的基类，然后将相似的代码移动到其中。但是，继承存在如下问题：</p>
<ol>
<li><strong>子类不能减少超类的接口。</strong>你必须实现父类中所有的抽象方法，即使它们没什么用。</li>
<li><strong>在重写方法时，你需要确保新行为与其基类中的版本兼容。</strong>因为子类的所有对象都可能被传递给以超类对象为参数的任何代码。</li>
<li><strong>继承打破了超类的封装，</strong>因为子类拥有访问父类内部详细内容的权限。此外还可能会有相反的情况出现，那就是程序员为了进一步扩展的方便而让超类知晓子类的内部详细内容。  </li>
<li><strong>子类与超类紧密耦合。</strong>超类中的任何修改都可能会破坏子类的功能。  </li>
<li><strong>通过继承复用代码可能导致平行继承体系的产生。</strong>继承通常仅发生在一个维度中。只要出现了两个以上的维度，你就必须创建数量巨大的类组合，从而使类层次结构膨胀到不可思议的程度。  </li>
</ol>
<p>组合/聚合是代替继承的一种方法。继承代表类之间的“是”关系（汽车是交通工具），而组合则代表“有”关系（汽车有一个引擎），聚合则是更为弱的组合，拥有该对象，但是不负责管理其生命周期。</p>
<p><strong>示例[策略模式]</strong></p>
<p>假如你需要为汽车制造商创建一个目录程序。 该公司同时生产汽车<code>Car</code>和卡车<code>Truck</code>， 车辆可能是电动车<code>Electric</code>或 汽油车 <code>Combustion</code>； 所 有 车 型 都 配 备 了手动控制<code>manual control</code> 或 自动驾驶 <code>Autopilot</code> 功能。  </p>
<p><img src="/posts/18543/image-20240225150233917.png" alt="image-20240225150233917"></p>
<p>每个额外参数都将使子类数量倍增。子类中将有大量的重复代码，因为子类不能同时继承两个类。</p>
<p>可以使用组合来解决这个问题。汽车对象可将行为委派给其他对象，而不是自行实现。  </p>
<p>还有一个好处是你可以在运行时对行为进行替换。例如，你可以通过重新为汽车对象分配一个不同的引擎对象来替换已连接至汽车的引擎。  </p>
<p><img src="/posts/18543/image-20240225150332506.png" alt="image-20240225150332506"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型模式</title>
    <url>/posts/16062.html</url>
    <content><![CDATA[<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式包括以下几种具体模式：</p>
<ol>
<li>工厂方法（<code>Factory Method</code>）：在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型</li>
<li>抽象工厂（<code>Abstract Factory</code>）：让你能创建一系列相关的对象，而无需指定其具体类</li>
<li>生成器（<code>Builder</code>）：使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象</li>
<li>原型（<code>Prototype</code>）：让你能够复制已有对象，而又无需使代码依赖它们所属的类  </li>
<li>单例（<code>Singleton</code>）：让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点</li>
</ol>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>虚拟构造函数、Virtual Constructor、Factory Method</p>
<p>工厂方法是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你正在开发一款物流管理应用。最初版本只能处理卡车运输，因此大部分代码都在位于名为卡车的类中。一段时间后，这款应用变得极受欢迎。你每天都能收到十几次来自海运公司的请求，希望应用能够支持海上物流功能。</p>
<p>目前，大部分代码都与卡车类相关。因此，在程序中添加轮船类需要修改全部代码。更糟糕的是，如果你以后需要在程序中支持另外一种运输方式，很可能需要再次对这些代码进行大幅修改  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>工厂方法模式建议使用特殊的工厂方法代替对对象构造函数的直接调用（使用<code>new</code>运算符）。不用担心，对象仍将通过<code>new</code>运算符创建，只是该运算符改在工厂方法中调用罢了。工厂方法返回的对象通常被称作“产品”。</p>
<p><img src="/posts/16062/image-20240227191801052.png" alt="image-20240227191801052"></p>
<p>虽然只是改变了程序中调用构造函数的位置而已。但是，现在可以在子类中重写工厂方法，从而改变其创建产品的类型。需要注意的是，仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应将其返回类型声明为这一共有接口  </p>
<p><img src="/posts/16062/image-20240227192127884.png" alt="image-20240227192127884"></p>
<p>卡车<code>Truck</code>和 轮船<code>Ship</code>类都必须实现运输<code>Transport</code>接口， 该接口声明了一个名为<code>deliver</code>交 付 的 方 法。 每 个 类 都 将 以 不 同 的 方 式 实 现 该 方法： 卡 车 走 陆 路 交 付 货 物， 轮 船 走 海 路 交 付 货 物。陆路运输 <code>RoadLogistics</code> 类中的工厂方法返回卡车对象，而海路运输<code>SeaLogistics</code>类则返回轮船对象。</p>
<p><img src="/posts/16062/image-20240227192215616.png" alt="image-20240227192215616"></p>
<p>调用工厂方法的代码（通常被称为客户端代码）无需了解不同子类返回实际对象之间的差别。客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付 方法，但是并不关心其具体实现方式  </p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240227192253764.png" alt="image-20240227192253764"></p>
<ol>
<li><p><strong>产品</strong>（<code>Product</code>）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的</p>
</li>
<li><p><strong>具体产品</strong>（<code>Concrete Products</code>）是产品接口的不同实现</p>
</li>
<li><p><strong>创建者</strong>（<code>Creator</code>）类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配</p>
<p> 你可以将工厂方法声明为抽象方法，强制要求每个子类以不同方式实现该方法。或者，你也可以在基础工厂方法中返回默认产品类型。</p>
<p> 特别需要注意的是：尽管名字是创建者，但它最主要的职责并不是创建产品。一般来说，创建者类会包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。</p>
</li>
<li><p><strong>具体创建者</strong>（<code>Concrete Creators</code>） 将会重写基础工厂方法，使其返回不同类型的产品</p>
<p> 并不一定每次调用工厂方法都会创建新的实例，也可以返回缓存、对象池或其他来源的已有对象。</p>
</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>跨平台对话框示例  </p>
<p><img src="/posts/16062/image-20240306185940396.png" alt="image-20240306185940396"></p>
<p>基础对话框类使用不同的UI组件渲染窗口，上述只是其中一种组件，即按钮。在不同的操作系统下，这些组件外观或许略有不同，但其功能保持一致。</p>
<p>如果使用工厂方法，就不需要为每种操作系统重写对话框逻辑。如果我们声明了一个在基本对话框类中生成按钮的工厂方法，那么我们就可以创建一个对话框子类，并使其通过工厂方法返回Windows样式按钮。子类将继承对话框基础类的大部分代码，同时在屏幕上根据Windows样式渲染按钮。每向对话框中添加一个新的工厂方法，你就离抽象工厂模式更近一步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供该方法的实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> is</span><br><span class="line">	<span class="comment">// 创建者还可提供一些工厂方法的默认实现。</span></span><br><span class="line">	<span class="keyword">abstract</span> method <span class="title function_">createButton</span><span class="params">()</span>:Button</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建者的主要职责并非是创建产品，而是会包含一些核心业务</span></span><br><span class="line">  <span class="comment">// 这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方</span></span><br><span class="line">  <span class="comment">// 法并使其返回不同类型的产品来间接修改业务逻辑。</span></span><br><span class="line">  method <span class="title function_">render</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">// 调用工厂方法创建一个产品对象。</span></span><br><span class="line">    <span class="type">Button</span> <span class="variable">okButton</span> <span class="operator">=</span> createButton()</span><br><span class="line">    <span class="comment">// 现在使用产品。</span></span><br><span class="line">    okButton.onClick(closeDialog)</span><br><span class="line">    okButton.render()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体创建者将重写工厂方法以改变其所返回的产品类型。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HTMLButton</span>()</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 产品接口中将声明所有具体产品都必须实现的操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">	method <span class="title function_">render</span><span class="params">()</span> <span class="comment">// 渲染</span></span><br><span class="line">	method <span class="title function_">onClick</span><span class="params">(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品需提供产品接口的各种实现。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line"> method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">	<span class="comment">// 根据 Windows 样式渲染按钮。</span></span><br><span class="line"> method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">	<span class="comment">// 绑定本地操作系统点击事件。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">HTMLButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">render</span><span class="params">(a, b)</span> is</span><br><span class="line">  <span class="comment">// 返回一个按钮的 HTML 表述。</span></span><br><span class="line">  method <span class="title function_">onClick</span><span class="params">(f)</span> is</span><br><span class="line">  <span class="comment">// 绑定网络浏览器的点击事件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line"> field dialog: Dialog</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 程序根据当前配置或环境设定选择创建者的类型。</span></span><br><span class="line"> method <span class="title function_">initialize</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line"> 	<span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">if</span> (config.OS == <span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line"> 		<span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowsDialog</span>() <span class="comment">// 就是创建了一个dialog</span></span><br><span class="line"> 	<span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Web&quot;</span>) <span class="type">then</span></span><br><span class="line">		<span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDialog</span>()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"> 		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;错误！未知的操作系统。&quot;</span>)</span><br><span class="line">    <span class="comment">//当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子类传递给客户端。</span></span><br><span class="line">    </span><br><span class="line">	method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">		<span class="built_in">this</span>.initialize()</span><br><span class="line">		dialog.render()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p><strong>无法预知对象确切类别及其依赖关系时</strong></p>
<p> 工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码</p>
<blockquote>
<p>如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可  </p>
</blockquote>
</li>
<li><p><strong>需要用户能扩展你软件库或框架的内部组件</strong></p>
<p> 继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨识出该子类 </p>
<p> 解决方案是将各框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写</p>
<blockquote>
<p>假设你使用开源 UI 框架编写自己的应用。你希望在应用中使用圆形按钮，但是原框架仅支持矩形按钮。你可以使用圆形按钮<code>RoundButton</code>子类来继承标准的按钮<code>Button</code> 类。但是，你需要告诉UI框架<code>UIFramework</code>类使用新的子类按钮代替默认按钮</p>
<p>为了实现这个功能， 你可以根据基础框架类开发子类圆形按钮UI <code>UIWithRoundButtons</code>，并且重写其<code>createButton</code>创建按钮方法。基类中的该方法返回按钮对象，而你开发的子类返回圆形按钮 对象。现在，你就可以使用圆形按钮UI类代替UI框架类。</p>
</blockquote>
</li>
<li><p><strong>需要复用现有对象来节省系统资源，而不是每次都重新创建对象</strong></p>
<p> 复用现有对象需要（1）创建存储空间来存放所有已经创建的对象（2）当他人请求一个对象时，程序将在对象池中搜索可用对象，然后将其返回给客户端代码（3）如果没有可用对象，程序则创建一个新对象（并将其添加到对象池中）</p>
<p> 上述代码应该位于构造函数中，但是构造函数本身的定义应该始终返回新对象，因此就需要再抽象出一层既能够创建新对象，又可以重用现有对象的普通方法，其实就是工厂方法</p>
</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>让所有产品都遵循同一接口。该接口必须声明对所有产品都有意义的方法。</p>
</li>
<li><p>在创建类中添加一个空的工厂方法。该方法的返回类型必须遵循通用的产品接口。</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</p>
</li>
<li><p>为工厂方法中的每种产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。</p>
</li>
<li><p>如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。</p>
<blockquote>
<p>设想你有以下一些层次结构的类。基类 邮件 及其子类 航空邮件 和 陆路邮件 ； 运输 及其子类 飞机 , 卡车和 火车 。 航空邮件 仅使用 飞机 对象，而 陆路邮件 则会同时使用 卡车 和 火车 对象。你可以编写一个新的子类（例如 火车邮件 ）来处理这两种情况，但是还有其他可选的方案。客户端代码可以给 陆路邮件 类传递一个参数，用于控制其希望获得的产品。</p>
</blockquote>
</li>
<li><p>如果代码经过上述移动后，基础工厂方法中已经没有任何代码，你可以将其转变为抽象类。如果基础工厂方法中还有其他语句，你可以将其设置为该方法的默认行为。</p>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>可以<strong>避免</strong>创建者和具体产品之间的<strong>紧密耦合</strong></li>
<li><strong>单一职责原则</strong>。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护</li>
<li><strong>开闭原则</strong>。无需更改现有客户端代码，你就可以在程序中引入新的产品类型</li>
</ul>
<hr>
<ul>
<li>应用工厂方法模式需要引入许多新的子类，代码可能会因此变得<strong>更复杂</strong>。最好的情况是将该模式引入创建者类的现有层次结构中</li>
</ul>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用<a href="# 抽象工厂">抽象工厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>
<li>你可以同时使用工厂方法和迭代器来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。</li>
<li>原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承，但是它不需要初始化步骤。</li>
<li>工厂方法是<a href="# 模板">模板</a>方法的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。</li>
</ul>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>Abstract Factory</p>
<p>抽象工厂是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类</p>
<h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你正在开发一款家具商店模拟器，包括一些类，用于抽象：</p>
<ol>
<li>一系列相关产品， 例如椅子<code>Chair</code>、沙发<code>Sofa</code>和咖啡桌CoffeeTable</li>
<li>系列产品的不同变体。 例如， 你可以使用现代<code>Modern</code>、维多利亚 <code>Victorian</code>、装饰风艺术<code>ArtDeco</code>等风格生成椅子、沙发和咖啡桌 </li>
</ol>
<p><img src="/posts/16062/image-20240228181453632.png" alt="image-20240228181453632"></p>
<p>你需要设法单独生成每件家具对象，这样才能确保其风格一致。如果顾客收到的家具风格不一样，他们可不会开心。  </p>
<p>此外， 你也不希望在添加新产品或新风格时修改已有代码。家具供应商对于产品目录的更新非常频繁，你不会想在每次更新时都去修改核心代码的。  </p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先，抽象工厂模式建议为系列中的每件产品明确声明接口（例如椅子、沙发或咖啡桌）。然后，确保所有产品变体都继承这些接口。例如，所有风格的椅子都实现椅子接口；所有风格的咖啡桌都实现咖啡桌接口，以此类推</p>
<p><img src="/posts/16062/image-20240228182311775.png" alt="image-20240228182311775"></p>
<p>接下来，我们需要声明抽象工厂——包含系列中所有产品构造方法的接口。例如 <code>createChair</code> 创建椅子 、 <code>createSofa</code>创建沙发 和 <code>createCoffeeTable</code> 创建咖啡桌 。 这些方法必须返回抽象产品类型，即我们之前抽取的那些接口：椅子，沙发和咖啡桌等等  </p>
<p><img src="/posts/16062/image-20240228182424624.png" alt="image-20240228182424624"></p>
<p>那么该如何处理产品变体呢？对于系列产品的每个变体,我们都将基于抽象工厂接口创建不同的工厂类。每个工厂类都只能返回特定类别的产品，例如，现代家具工厂<code>ModernFurnitureFactory</code>只能创建现代椅子<code>ModernChair</code>，现代沙发<code>ModernSofa</code>和现代咖啡桌<code>ModernCoffeeTable</code>对象。</p>
<p>客户端代码可以通过相应的抽象接口调用工厂和产品类。你无需修改实际客户端代码，就能更改传递给客户端的工厂类，也能更改客户端代码接收的产品变体。  </p>
<p>假设客户端想要工厂创建一把椅子。客户端无需了解工厂类，也不用管工厂类创建出的椅子类型。无论是现代风格，还是维多利亚风格的椅子，对于客户端来说没有分别，它只需调用抽象椅子接口就可以了。这样一来，客户端只需知道椅子以某种方式实现了<code>sitOn</code>坐下方法就足够了。此外，无论工厂返回的是何种椅子变体，它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。  </p>
<p>最后一点说明：如果客户端仅接触抽象接口，那么谁来创建实际的工厂对象呢？一般情况下，应用程序会在初始化阶段创建具体工厂对象。而在此之前，应用程序必须根据配置文件或环境设定选择工厂类别。  </p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240228182719053.png" alt="image-20240228182719053"></p>
<ol>
<li><strong>抽象产品</strong>（<code>Abstract Product</code>）为构成系列产品的一组不同但相关的产品声明接口</li>
<li><strong>具体产品</strong>（<code>Concrete Product</code>）是抽象产品的多种不同类型实现。所有变体 (维多利亚/现代)都必须实现相应的抽象产品(椅子/沙发)</li>
<li><strong>抽象工厂</strong>（<code>Abstract Factory</code>）接口声明了一组创建各种抽象产品的方法</li>
<li><strong>具体工厂</strong>（<code>Concrete Factory</code>）实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体</li>
<li>尽管具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的抽象产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。客户端（Client）只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂/产品变体交互</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>跨平台 UI 类示例</p>
<p><img src="/posts/16062/image-20240228183848178.png" alt="image-20240228183848178"></p>
<p>应用程序启动后检测当前操作系统。根据该信息，应用程序通过与该操作系统对应的类创建工厂对象。其余代码使用该工厂对象创建UI元素。这样可以避免生成错误类型的元素。  </p>
<p>使用这种方法，客户端代码只需调用抽象接口，而无需了解具体工厂类和 UI元素。此外，客户端代码还支持未来添加新的工厂或UI元素 ，即每次在应用程序中添加新的UI元素变体时，你都无需修改客户端代码。你只需创建一个能够生成这些UI元素的工厂类，然后稍微修改应用程序的初始代码，使其能够选择合适的工厂类即可。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">	method <span class="title function_">createButton</span><span class="params">()</span> :Button</span><br><span class="line">	method <span class="title function_">createCheckbox</span><span class="params">()</span> :Checkbox</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进行实例化。</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span>:Button is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinButton</span>()</span><br><span class="line">  method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WinCheckbox</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> is</span><br><span class="line">  method <span class="title function_">createButton</span><span class="params">()</span> :Button is</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>()</span><br><span class="line">  method <span class="title function_">createCheckbox</span><span class="params">()</span>:Checkbox is</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品由相应的具体工厂创建。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">// 根据windows样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">//根据macoS样式渲染按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产品之间才能够正确地进行交互。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">//根据Windows样式渲染复选框。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> is</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">  <span class="comment">//根据macoS样式渲染复选框。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//客户端代码仅通过抽象类型（GUIFactory、Button 和Checkbox）使用工厂和产品，实现无需修改任何工厂或产品子类就能将其传递给客户端代码。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  <span class="keyword">private</span> field factory: GUIFactory</span><br><span class="line">  <span class="keyword">private</span> field button: Button</span><br><span class="line">  constructor <span class="title function_">Application</span><span class="params">(factory: GUIFactory)</span> is</span><br><span class="line">    <span class="built_in">this</span>.factory = factory</span><br><span class="line">  method <span class="title function_">createUI</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.button = factory.createButton()</span><br><span class="line">  method <span class="title function_">paint</span><span class="params">()</span> is</span><br><span class="line">    button.paint()  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初始化阶段）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">  method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">    <span class="variable">config</span> <span class="operator">=</span> readApplicationConfigFile()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(config.OS ==<span class="string">&quot;Windows&quot;</span>) <span class="type">then</span></span><br><span class="line">      <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WinFactory</span>()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (config.OS == <span class="string">&quot;Mac&quot;</span>) <span class="type">then</span></span><br><span class="line">      <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacFactory</span>()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>（<span class="string">&quot;错误！未知的操作系统&quot;</span>）</span><br><span class="line">    </span><br><span class="line">    <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Application</span>(factory)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p>如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂</p>
<blockquote>
<p>抽象工厂为你提供了一个接口，可用于创建每个系列产品的对象。只要代码通过该接口创建对象，那么你就不会生成与应用程序已生成的产品类型不一致的产品  </p>
</blockquote>
</li>
<li><p>如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式</p>
<blockquote>
<p>在设计良好的程序中，每个类仅负责一件事。如果一个类与多种类型产品交互，就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中 </p>
</blockquote>
</li>
</ol>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>以不同的产品类型与产品变体为维度绘制矩阵</li>
<li>为所有产品声明抽象产品接口。然后让所有具体产品类实现这些接口</li>
<li>声明抽象工厂接口，并且在接口中为所有抽象产品提供一组构建方法</li>
<li>为每种产品变体实现一个具体工厂类</li>
<li>在应用程序中开发初始化代码。该代码根据应用程序配置或当前环境，对特定具体工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类</li>
<li>找出代码中所有对产品构造函数的直接调用，将其替换为对工厂对象中相应构建方法的调用</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以确保同一工厂生成的产品相互匹配</li>
<li>你可以避免客户端和具体产品代码的耦合</li>
<li>单一职责原则。你可以将产品生成代码抽取到同一位置，使得代码易于维护</li>
<li>开闭原则。向应用程序中引I入新产品变体时，你无需修改客户端代码</li>
</ul>
<hr>
<ul>
<li>由于采用该模式需要向应用中引入众多接口和类，代码可能会比之前更加复杂</li>
</ul>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且可以更方便地通过子类进行定制)，随后演化为使用<a href="# 抽象工厂">抽象工厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>(更灵活但更加复杂)。</li>
<li>生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。</li>
<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽象工厂来代替外观</li>
<li>你可以将抽象工厂和<a href="# 桥接">桥接</a>搭配使用。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性</li>
<li>抽象工厂、生成器和原型都可以用<a href="# 单例">单例</a>来实现  </li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote>
<p>建造者模式、Builder</p>
</blockquote>
<p><strong>生成器</strong>是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<h3 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设有这样一个复杂对象，在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中。甚至还有更糟糕的情况，那就是这些代码散落在客户端代码的多个位置。</p>
<p><img src="/posts/16062/image-20240306184615376.png" alt="image-20240306184615376"></p>
<p>例如，我们来思考如何创建一个 房屋<code>House</code>对象。建造一栋简单的房屋，首先你需要建造四面墙和地板，安装房门和一套窗户，然后再建造一个屋顶。但是如果你想要一栋更宽敞更明亮的房屋，还要有院子和其他设施（例如暖气、排水和供电设备），有如下两种简单的方法： </p>
<ol>
<li>最简单的方法是扩展 房屋 基类，然后<strong>创建一系列涵盖所有参数组合的子类</strong>。但最终你将面对相当数量的子类。任何新增的参数（例如门廊类型）都会让这个层次结构更加复杂。  </li>
<li>可以在 房屋 基类中创建一个包括所有可能参数的<strong>超级构造函数</strong>，并用它来控制房屋对象。这种方法确实可以避免生成子类，但它却会造成另外一个问题。  </li>
</ol>
<p><img src="/posts/16062/image-20240306184805162.png" alt="image-20240306184805162"></p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>生成器模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。  </p>
<p><img src="/posts/16062/image-20240306184900394.png" alt="image-20240306184900394"></p>
<p>该模式会将对象构造过程划分为一组步骤，比如<code>buildWalls</code>创建墙壁和 <code>buildDoor</code>创建房门等。每次创建对象时，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。 </p>
<p>当你需要创建不同形式的产品时，其中的一些构造步骤可能需要不同的实现。例如，木屋的房门可能需要使用木头制造，而城堡的房门则必须使用石头制造。</p>
<p>在这种情况下，你可以创建多个不同的生成器，用不同方式实现一组相同的创建步骤。然后你就可以在创建过程中使用这些生成器（例如按顺序调用多个构造步骤）来生成不同类型的对象。  </p>
<p><strong>主管</strong></p>
<p>进一步可以将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。主管类可定义创建步骤的执行顺序，而生成器则提供这些步骤的实现。  </p>
<p>实际上，客户端代码可以直接以特定顺序调用创建步骤，但是主管的优势在于复用，即例行构造流程不需要每次都写一遍。并且，主管能够隐藏构造顺序。</p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240306185309368.png" alt="image-20240306185309368"></p>
<ol>
<li><strong>生成器</strong>（Builder）接口声明在所有类型生成器中通用的产品构造步骤</li>
<li><strong>具体生成器</strong>（Concrete Builders）提供构造过程的不同实现。<br> 具体生成器也可以构造不遵循通用接口的产品</li>
<li><strong>产品</strong>（Products）是最终生成的对象。由不同生成器构造的<br> 产品无需属于同一类层次结构或接口</li>
<li><strong>主管</strong>（Director）类定义调用构造步骤的顺序，这样你就可以<br> 创建和复用特定的产品配置</li>
<li><strong>客户端</strong>（Client）必须将某个生成器对象与主管类关联。一<br> 般情况下，你只需通过主管类构造函数的参数进行一次性关<br> 联即可。此后主管类就能使用生成器对象完成后续所有的构<br> 造任务。但在客户端将生成器对象传递给主管类制造方法时<br> 还有另一种方式。在这种情况下，你在使用主管类生产产品<br> 时每次都可以使用不同的生成器</li>
</ol>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>分步骤制造汽车并制作对应型号用户使用手册的示例</p>
<p><img src="/posts/16062/image-20240306185840793.png" alt="image-20240306185840793"></p>
<p>汽车是一个复杂对象，有数百种不同的制造方法。我们没有在 汽车 类中塞入一个巨型构造函数，而是将汽车组装代码抽取到单独的汽车生成器类中。该类中有一组方法可用来配置汽车的各种部件  </p>
<p>如果客户端代码需要组装一辆与众不同、 精心调教的汽车，它可以直接调用生成器。或者，客户端可以将组装工作委托给主管类，因为主管类知道如何使用生成器制造最受欢迎的几种型号汽车。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有当产品较为复杂且需要详细配置时，使用生成器模式才有意义。下面的两个产品尽管没有同样的接口，但却相互关联。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> is</span><br><span class="line"><span class="comment">// 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车运动型轿车、SUV和敞篷车）可能会安装或启用不同的功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> is</span><br><span class="line">  <span class="comment">// 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 生成器接口声明了创建产品对象不同部件的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> is</span><br><span class="line">	method <span class="title function_">reset</span><span class="params">()</span></span><br><span class="line">  method <span class="title function_">setSeats</span><span class="params">(...)</span></span><br><span class="line">  method <span class="title function_">setEngine</span><span class="params">(...)</span></span><br><span class="line">  method <span class="title function_">setTripComputer</span><span class="params">(...)</span></span><br><span class="line">  method <span class="title function_">setGPS</span><span class="params">(...)</span></span><br><span class="line"><span class="comment">// 具体生成器类将遵循生成器接口并提供生成步骤的具体实现。你的程序中可能会有多个以不同方式实现的生成器变体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">  <span class="keyword">private</span> field car:Car</span><br><span class="line">  <span class="comment">// 一个新的生成器实例必须包含一个在后续组装过程中使用的空对象</span></span><br><span class="line">  constructor <span class="title function_">CarBuilder</span><span class="params">()</span> is</span><br><span class="line">  	<span class="built_in">this</span>.reset()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// reset（重置）方法可清除正在生成的对象。</span></span><br><span class="line">  method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.car = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 所有生成步骤都会与同一个产品实例进行交互。</span></span><br><span class="line">  method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 设置汽车座位的数量</span></span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 安装指定的引擎</span></span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 安装行车电脑</span></span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 安装GPS</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 具体生成器需要自行提供获取结果的方法。这是因为不同类型的生成器可能会创建不遵循相同接口的、完全不同的产品。所以也就无法在生成器接口中声明这些方法（至少在静态类型的编程语言中是这样的）。</span></span><br><span class="line">  <span class="comment">// 通常在生成器实例将结果返回给客户端后，它们应该做好生成另一个产品的准备。因此生成器实例通常会在 `getProduct（获取产品）`方法主体末尾调用重置方法。但是该行为并不是必需的，你也可让生成器等待客户端明确调用重置方法后再去处理之前的结果。</span></span><br><span class="line">  method <span class="title function_">getProduct</span><span class="params">()</span>:Car <span class="type">is</span></span><br><span class="line">    <span class="variable">product</span> <span class="operator">=</span> <span class="built_in">this</span>.car</span><br><span class="line">    <span class="built_in">this</span>.reset()</span><br><span class="line">    <span class="keyword">return</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> is</span><br><span class="line">  <span class="keyword">private</span> field manual:Manual</span><br><span class="line">  constructor <span class="title function_">CarManualBuilder</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.reset()</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">reset</span><span class="params">()</span> is</span><br><span class="line">    <span class="built_in">this</span>.manual = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setSeats</span><span class="params">(...)</span> is</span><br><span class="line">    <span class="comment">// 添加关于汽车座椅功能的文档。</span></span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setEngine</span><span class="params">(...)</span> is</span><br><span class="line">		<span class="comment">// 添加关于引擎的介绍。</span></span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">setTripComputer</span><span class="params">(...)</span> is</span><br><span class="line">		<span class="comment">// 添加关于行车电脑的介绍。</span></span><br><span class="line"></span><br><span class="line">	method <span class="title function_">setGPS</span><span class="params">(...)</span> is</span><br><span class="line">		<span class="comment">// 添加关于 GPS 的介绍。</span></span><br><span class="line"></span><br><span class="line">	method <span class="title function_">getProduct</span><span class="params">()</span>:Manual is</span><br><span class="line">		<span class="comment">// 返回使用手册并重置生成器。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时会很有帮助。由于客户端可以直接控制生成器，所以严格意义上来说，主管类并不是必需的。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> is</span><br><span class="line">  <span class="keyword">private</span> field builder:Builder</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通过这种方式改变最新组装完毕的产品的最终类型。</span></span><br><span class="line">  method <span class="title function_">setBuilder</span><span class="params">(builder:Builder)</span></span><br><span class="line">    <span class="built_in">this</span>.builder = builder</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主管可使用同样的生成步骤创建多个产品变体</span></span><br><span class="line">  method <span class="title function_">constructSportsCar</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">    builder.reset()</span><br><span class="line">    builder.setSeats(<span class="number">2</span>)</span><br><span class="line">		builder.setEngine(<span class="keyword">new</span> <span class="title class_">SportEngine</span>())</span><br><span class="line">		builder.setTripComputer(<span class="literal">true</span>)</span><br><span class="line">    builder.setGPS(<span class="literal">true</span>)</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">constructSUV</span><span class="params">(builder: Builder)</span> is</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果将需要从生成器对象中获取。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">makeCar</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line">  	<span class="type">CarBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">  	director.constructSportsCar(builder)</span><br><span class="line">  	<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> builder.getProduct()</span><br><span class="line">  	<span class="type">CarManualBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">  	director.constructSportsCar(builder)</span><br><span class="line">  	<span class="comment">// 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和产品的存在，也不会对其产生依赖。</span></span><br><span class="line">  	<span class="type">Manual</span> <span class="variable">manual</span> <span class="operator">=</span> builder.getProduct()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>使用生成器模式可避免重叠构造函数</strong></p>
<p>  假设你的构造函数中有十个可选参数，那么调用该函数会非常不方便；因此，你需要重载这个构造函数，新建几个只有较少参数的简化版。 但这些构造函数仍需调用主构造函数，传递一些默认数值来替代省略掉的参数。</p>
<p>  生成器模式让你可以分步骤生成对象，而且允许你仅使用必须的步骤。应用该模式后，你再也不需要将几十个参数塞进构造函数里了。</p>
</li>
<li><p><strong>使用代码创建不同形式的产品（例如石头或木头房</strong><br>  <strong>屋）时，可使用生成器模式</strong></p>
<p>  如果你需要创建的各种形式的产品，它们的制造过程相似且仅有细节上的差异，此时可使用生成器模式</p>
<p>  基本生成器接口中定义了所有可能的制造步骤，具体生成器将实现这些步骤来制造特定形式的产品。同时，主管类将负责管理制造步骤的顺序。</p>
</li>
<li><p><strong>使用生成器构造组合树或其他复杂对象</strong></p>
<p>  生成器模式让你能分步骤构造产品。你可以延迟执行某些步骤而不会影响最终产品。你甚至可以递归调用这些步骤，这在创建对象树时非常方便。</p>
<p>  生成器在执行制造步骤时，不能对外发布未完成的产品。这可以避免客户端代码获取到不完整结果对象的情况。</p>
</li>
</ul>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>清晰地定义通用步骤， 确保它们可以制造所有形式的产品。否则你将无法进一步实施该模式。</p>
</li>
<li><p>在基本生成器接口中声明这些步骤。</p>
</li>
<li><p>为每个形式的产品创建具体生成器类，并实现其构造步骤。</p>
<p> 不要忘记实现获取构造结果对象的方法。你不能在生成器接口中声明该方法，因为不同生成器构造的产品可能没有公共接口，因此你就不知道该方法返回的对象类型。但是，如果所有产品都位于单一类层次中，你就可以安全地在基本接口中添加获取生成对象的方法。  </p>
</li>
<li><p>考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。 </p>
</li>
<li><p>客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需调用主管类构造函数一次即可。主管类使用生成器对象完成后续所有制造任务。还有另一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。</p>
</li>
<li><p>只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则，客户端应当通过生成器获取构造结果。</p>
</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时，你可以复用相同的制造代码。</li>
<li>单一职责原则。你可以将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<hr>
<ul>
<li>由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。</li>
</ul>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且<br>  可以更方便地通过子类进行定制），随后演化为使用<a href="# 抽象工厂">抽象工<br>  厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>（更灵活但更加复杂）。</li>
<li>生成器重点关注如何分步生成复杂对象。抽象工厂专门用于生产一系列相关对象。抽象工厂会马上返回产品，生成器则允许你在获取产品前执行一些额外构造步骤。</li>
<li>你可以在创建复杂<a href="# 组合">组合树</a>时使用生成器，因为这可使其构造步骤以递归的方式运行。</li>
<li>你可以结合使用生成器和<a href="# 桥接">桥接</a>模式： 主管类负责抽象工作，各种不同的生成器负责实现工作。  </li>
<li>抽象工厂、生成器和原型都可以用<a href="# 单例">单例</a>来实现。</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><blockquote>
<p>克隆、Clone、Prototype  </p>
</blockquote>
<p>原型是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类</p>
<h3 id="问题背景-3"><a href="#问题背景-3" class="headerlink" title="问题背景"></a>问题背景</h3><p>如果你有一个对象，并希望生成与其完全相同的一个复制品，你该如何实现呢？首先，你必须新建一个属于相同类的对象。然后，你必须遍历原始对象的所有成员变量，并将成员变量值复制到新对象中。但是并非所有对象都能通过这种方式进行复制，因为有些对象可能拥有私有成员变量，它们在对象本身以外是不可见的。</p>
<p>此外，直接复制还有另外一个问题。因为你必须知道对象所属的类才能创建复制品，所以代码必须依赖该类。即使你可以接受额外的依赖性，那还有另外一个问题：有时你只知道对象所实现的接口，而不知道其所属的具体类，比如<strong>可向方法的某个参数传入实现了某个接口的任何对象（你只知道接口而不知道类）</strong>。  </p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个 克隆 方法。</p>
<p>所有的类对 克隆 方法的实现都非常相似。该方法会创建一个当前类的对象，然后将原始对象所有的成员变量值复制到新建的类中。你甚至可以复制私有成员变量，因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。  </p>
<p>支持克隆的对象即为原型。当你的对象有几十个成员变量和几百种类型时，对其进行克隆甚至可以代替子类的构造。  </p>
<p>其运作方式如下：创建一系列不同类型的对象并不同的方式对其进行配置。如果所需对象与预先配置的对象相同，那么你只需克隆原型即可，无需新建一个对象。  </p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><strong>基本实现</strong></p>
<p><img src="/posts/16062/image-20240311192308784.png" alt="image-20240311192308784" style="zoom:50%;"></p>
<ol>
<li><strong>原型</strong>（Prototype）接口将对克隆方法进行声明。在绝大多数情况下，其中只会有一个名为<code>clone</code>的方法</li>
<li><strong>具体原型</strong>（Concrete Prototype）类将实现克隆方法。除了将原始对象的数据复制到克隆体中之外，该方法有时还需处理克隆过程中的极端情况，例如克隆关联对象和梳理递归依赖等等。  </li>
<li><strong>客户端</strong>（Client）可以复制实现了原型接口的任何对象。  </li>
</ol>
<p><strong>原型注册表实现</strong></p>
<p><img src="/posts/16062/image-20240311193232360.png" alt="image-20240311193232360" style="zoom:50%;"></p>
<ol>
<li><strong>原型注册表</strong>（Prototype Registry）提供了一种访问常用原型的简单方法，其中存储了一系列可供随时复制的预生成对象。最简单的注册表原型是一个 名称 → 原型 的哈希表。 但如果需要使用名称以外的条件进行搜索，你可以创建更加完善的注册表版本。  </li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>原型模式能让你生成完全相同的几何对象副本，同时无需代码与对象所属类耦合</p>
<p><img src="/posts/16062/image-20240311193454637.png" alt="image-20240311193454637" style="zoom:50%;"></p>
<p>所有形状类都遵循同一个提供克隆方法的接口。在复制自身成员变量值到结果对象前，子类可调用其父类的克隆方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础原型。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> is</span><br><span class="line">	field X: <span class="type">int</span></span><br><span class="line">	field Y: <span class="type">int</span></span><br><span class="line">	field color: string</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规构造函数。</span></span><br><span class="line">constructor <span class="title function_">Shape</span><span class="params">()</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 原型构造函数。使用已有对象的数值来初始化一个新对象。</span></span><br><span class="line">constructor <span class="title function_">Shape</span><span class="params">(source: Shape)</span> is</span><br><span class="line">  <span class="title function_">this</span><span class="params">()</span></span><br><span class="line">  <span class="built_in">this</span>.X = source.X</span><br><span class="line">  <span class="built_in">this</span>.Y = source.Y</span><br><span class="line">  <span class="built_in">this</span>.color = source.color</span><br><span class="line">  </span><br><span class="line"><span class="comment">// clone（克隆）操作会返回一个形状子类。</span></span><br><span class="line"><span class="keyword">abstract</span> method <span class="title function_">clone</span><span class="params">()</span>:Shape</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span><br><span class="line">  <span class="comment">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span><br><span class="line">  <span class="comment">// 成的克隆对象。这可以保持克隆结果的一致。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">  field width: <span class="type">int</span></span><br><span class="line">  field height: <span class="type">int</span></span><br><span class="line">  	</span><br><span class="line">  constructor <span class="title function_">Rectangle</span><span class="params">(source: Rectangle)</span> is</span><br><span class="line">    <span class="comment">// 需要调用父构造函数来复制父类中定义的私有成员变量。</span></span><br><span class="line">    <span class="built_in">super</span>(source)</span><br><span class="line">    <span class="built_in">this</span>.width = source.width</span><br><span class="line">    <span class="built_in">this</span>.height = source.height</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="built_in">this</span>)</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> is</span><br><span class="line">	field radius: <span class="type">int</span></span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Circle</span><span class="params">(source: Circle)</span> is</span><br><span class="line">		<span class="title function_">super</span><span class="params">(source)</span></span><br><span class="line">		<span class="built_in">this</span>.radius = source.radius</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">clone</span><span class="params">()</span>:Shape is</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码中的某个位置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">	field shapes: array of Shape</span><br><span class="line">	constructor <span class="title function_">Application</span><span class="params">()</span> is</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>()</span><br><span class="line">		circle.X = <span class="number">10</span></span><br><span class="line">		circle.Y = <span class="number">10</span></span><br><span class="line">		circle.radius = <span class="number">20</span></span><br><span class="line">		shapes.add(circle)</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">anotherCircle</span> <span class="operator">=</span> circle.clone()</span><br><span class="line">		shapes.add(anotherCircle)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内容完全一样。</span></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>()</span><br><span class="line">    rectangle.width = <span class="number">10</span></span><br><span class="line">    rectangle.height = <span class="number">20</span></span><br><span class="line">    shapes.add(rectangle)</span><br><span class="line">    </span><br><span class="line">method <span class="title function_">businessLogic</span><span class="params">()</span> is</span><br><span class="line">	<span class="comment">// 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与其完全相同的复制品。</span></span><br><span class="line">	<span class="type">Array</span> <span class="variable">shapesCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span> of Shapes.</span><br><span class="line">  <span class="comment">// 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，我们将获得一个正确的复制品，而不是一组简单的形状对象。</span></span><br><span class="line">  foreach (s in shapes) <span class="keyword">do</span></span><br><span class="line">  	shapesCopy.add(s.clone())</span><br><span class="line">  <span class="comment">// `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有子元素的复制品。</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式</p>
<p>  这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。即使不考虑代码耦合的情况，你的代码也不能依赖这些对象所属的具体类，因为你不知道它们的具体信息</p>
<p>  原型模式为客户端代码提供一个通用接口，客户端代码可通过这一接口与所有实现了克隆的对象进行交互，它也使得客户端代码与其所克隆的对象具体类独立开来。    </p>
</li>
<li><p>如果子类的区别仅在于其对象的初始化方式，那么你可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象</p>
<p>  在原型模式中，你可以使用一系列预生成的、各种类型的对象作为原型</p>
<p>  客户端不必根据需求对子类进行实例化，只需找到合适的原型并对其进行克隆即可</p>
</li>
</ul>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>创建原型接口，并在其中声明 克隆 方法。如果你已有类层次结构，则只需在其所有类中添加该方法即可</p>
</li>
<li><p>原型类必须另行定义一个以该类对象为参数的构造函数。构造函数必须复制参数对象中的所有成员变量值到新建实体中。如果你需要修改子类，则必须调用父类构造函数，让父类复制其私有成员变量值。</p>
<p> 如果编程语言不支持方法重载，那么你可能需要定义一个特殊方法来复制对象数据。在构造函数中进行此类处理比较方便，因为它在调用 <code>new</code> 运算符后会马上返回结果对象  </p>
</li>
<li><p>克隆方法通常只有一行代码：使用 <code>new</code> 运算符调用原型版本的构造函数。注意，每个类都必须显式重写克隆方法并使用自身类名调用 <code>new</code> 运算符。否则，克隆方法可能会生成父类的对象</p>
</li>
<li><p>你还可以创建一个中心化原型注册表，用于存储常用原型</p>
<p> 你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法。该方法必须能够根据客户端代码设定的条件进行搜索。搜索条件可以是简单的字符串，或者是一组复杂的搜索参数。找到合适的原型后，注册表应对原型进行克隆，并将复制生成的对象返回给客户端。</p>
<p> 最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</p>
</li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以克隆对象，而无需与它们所属的具体类相耦合</li>
<li>你可以克隆预生成原型，避免反复运行初始化代码</li>
<li>你可以更方便地生成复杂对象</li>
<li>你可以用继承以外的方式来处理复杂对象的不同配置</li>
</ul>
<hr>
<ul>
<li>克隆包含循环引用的复杂对象可能会非常麻烦</li>
</ul>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<a href="# 工厂方法">工厂方法</a>（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用<a href="￥ 抽象工厂">抽象工厂</a>、<a href="# 原型">原型</a>或<a href="# 生成器">生成器</a>（更灵活但更加复杂）。</li>
<li>抽象工厂模式通常基于一组工厂方法，但你也可以使用原型模式来生成这些类的方法。</li>
<li>原型可用于保存命令的历史记录。</li>
<li>大量使用组合和装饰的设计通常可从对于原型的使用中获益。</li>
<li>你可以通过该模式来复制复杂结构，而非从零开始重新构造。</li>
<li>原型并不基于继承，因此没有继承的缺点。另一方面，原型需要对被复制对象进行复杂的初始化。工厂方法基于继承，但是它不需要初始化步骤。</li>
<li>有时候原型可以作为<a href="# 备忘录">备忘录</a>的一个简化版本，其条件是你需要在历史记录中存储的对象的状态比较简单，不需要链接其他外部资源，或者链接可以方便地重建。抽象工厂、生成器和原型都可以用单例来实现。</li>
</ul>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><blockquote>
<p>单件模式、Singleton</p>
</blockquote>
<p>单例是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<h3 id="问题背景-4"><a href="#问题背景-4" class="headerlink" title="问题背景"></a>问题背景</h3><ol>
<li><p><strong>保证一个类只有一个实例。</strong>为什么会有人想要控制一个类所<br> 拥有的实例数量？最常见的原因是控制某些共享资源（例如<br> 数据库或文件）的访问权限</p>
</li>
<li><p><strong>为该实例提供一个全局访问节点。</strong>还记得那些存储重要对象的全局变量吗？它们在使用上十分方便，但同时也非常不安全，因为任何代码都有可能覆盖掉那些变量的内容，从而引发程序崩溃</p>
<p> 和全局变量一样，单例模式也允许在程序的任何地方访问特定对象。但是它可以保护该实例不被其他代码覆盖。</p>
</li>
</ol>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>所有单例的实现都包含以下两个相同的步骤：  </p>
<ol>
<li>将默认构造函数设为私有， 防止其他对象使用单例类的 <code>new</code> 运算符。</li>
<li>新建一个静态构建方法作为构造函数。该函数会调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ol>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/16062/image-20240312180931884.png" alt="image-20240312180931884"></p>
<ol>
<li><p><strong>单例</strong>（Singleton）类声明了一个名为 <code>getInstance</code> 获取实<br> 例 的静态方法来返回其所属类的一个相同实例。</p>
<p> 单例的构造函数必须对客户端（Client） 代码隐藏。 调用<br> 获取实例 方法必须是获取单例对象的唯一方式</p>
</li>
</ol>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>数据库连接类即是一个单例，该类不提供公有构造函数，因此获取该对象的唯一方式是调用 获取实例 方法。该方法将缓存首次生成的对象，并为所有后续调用返回该对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处都能访问相同的数据库连接实例。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">  <span class="comment">// 保存单例实例的成员变量必须被声明为静态类型。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line">  <span class="comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构造方法。</span></span><br><span class="line">  <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">   <span class="comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于控制对单例实例的访问权限的静态方法。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">			<span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line"> 				<span class="comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span></span><br><span class="line"> 				<span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line"> 					Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line"> 		<span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span></span><br><span class="line">   <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">   <span class="comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以在这里添加限流或缓冲逻辑。</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">    <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">    foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">    bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">    <span class="comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</p>
<p>  单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。该方法可以创建一个新对象，但如果该对象已经被创建，则返回已有的对象</p>
</li>
<li><p>如果你需要更加严格地控制全局变量，可以使用单例模式</p>
<p>  单例模式与全局变量不同，它保证类只存在一个实例。除了单例类自己以外，无法通过任何方式替换缓存的实例</p>
<p>  请注意， 你可以随时调整限制并设定生成单例实例的数量，只需修改 获取实例 方法， 即 <code>getInstance</code> 中的代码即可实现</p>
</li>
</ul>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>在类中添加一个私有静态成员变量用于保存单例实例。</li>
<li>声明一个公有静态构建方法用于获取单例实例。</li>
<li>在静态方法中实现”延迟初始化”。该方法会在首次被调用时创建一个新对象，并将其存储在静态成员变量中。此后该方法每次被调用时都返回该实例。</li>
<li>将类的构造函数设为私有。类的静态方法仍能调用构造函数，但是其他对象不能调用。</li>
<li>检查客户端代码，将对单例的构造函数的调用替换为对其静态构建方法的调用。</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以保证一个类只有一个实例</li>
<li>你获得了一个指向该实例的全局访问节点</li>
<li>仅在首次请求单例对象时对其进行初始化</li>
</ul>
<hr>
<ul>
<li>违反了单一职责原则。该模式同时解决了两个问题（实例唯一、全局访问）。</li>
<li>单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。</li>
<li>该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。</li>
<li><strong>单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不编写测试代码，或者不使用单例模式。</strong></li>
</ul>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 外观">外观</a>类通常可以转换为<a href="# 单例">单例</a>类，因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个<a href="# 享元">享元</a>对象，那么享元就和单例类似了。但这两个模式有两个根本性的不同。<ul>
<li>只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。享元对象是不可变的。</li>
</ul>
</li>
<li><a href="# 抽象工厂">抽象工厂</a>、<a href="# 生成器">生成器</a>和<a href="# 原型">原型</a>都可以用单例来实现。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-结构型模式</title>
    <url>/posts/18127.html</url>
    <content><![CDATA[<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>结构型模式包括以下几种具体模式：</p>
<ol>
<li>适配器（<code>Adapter</code>）：让接口不兼容的对象能够相互合作</li>
<li>桥接（<code>Bridge</code>）：可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用</li>
<li>组合（<code>Composite</code>）：使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们（比如遍历）</li>
<li>装饰（<code>Decorator</code>）：允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为</li>
<li>外观（<code>Facade</code>）：能为程序库、框架或其他复杂类提供一个简单的接口</li>
<li>享元（<code>Flyweight</code>）：摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象</li>
<li>代理（<code>Proxy</code>）：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理</li>
</ol>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><blockquote>
<p>封装器模式、Wrapper、Adapter</p>
</blockquote>
<p>适配器是一种结构型设计模式，它能使接口不兼容的对象能够相互合作</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如你正在开发一款股票市场监测程序，它会从不同来源下载XML格式的股票数据，然后向用户呈现出美观的图表。</p>
<p>在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容JSON格式的数据。</p>
<p><img src="/posts/18127/image-20240313182958332.png" alt="image-20240313182958332"></p>
<p>你可以修改程序库来支持 XML。但是，这可能需要修改部分依赖该程序库的现有代码。甚至还有更糟糕的情况，你可能根本没有程序库的源代码，从而无法对其进行修改。  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>创建一个适配器，适配器是一个特殊的对象，能够转换对象接口，使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。被封装的对象甚至察觉不到适配器的存在。例如，你可以使用一个将所有数据转换为英制单位（如英尺和英里）的适配器封装运行于米和千米单位制中的对象  </p>
<p>适配器不仅可以转换不同格式的数据，还有助于采用不同接口的对象之间的合作。它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口</li>
<li>现有对象可以使用该接口安全地调用适配器方法</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象</li>
</ol>
<p>有时你甚至可以创建一个双向适配器来实现双向转换调用  </p>
<p><img src="/posts/18127/image-20240313183849810.png" alt="image-20240313183849810"></p>
<p>为了解决数据格式不兼容的问题，你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器，然后让客户端仅通过这些适配器来与函数库进行交流。当某个适配器被调用时，它会将传入的 XML 数据转换为 JSON 结构，并将其传递给被封装分析对象的相应方法。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>对象适配器</strong></p>
<p>实现时使用了构成原则：适配器实现了其中一个对象的接口，并对另一个对象进行封装。</p>
<p><img src="/posts/18127/image-20240313184112960.png" alt="image-20240313184112960"></p>
<ol>
<li>客户端（<code>Client</code>）是包含当前程序业务逻辑的类。</li>
<li>客户端接口（<code>Client Interface</code>）描述了其他类与客户端代码合作时必须遵循的协议。</li>
<li>服务（<code>Service</code>）中有一些功能类（通常来自第三方或遗留系统)。客户端与其接口不兼容，因此无法直接调用其功能</li>
<li><strong>适配器</strong>（<code>Adapter</code>）是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用</li>
<li>客户端代码只需通过接口与适配器交互即可，无需与具体的适配器类耦合。因此，你可以向程序中添加新类型的适配器而无需修改已有代码。这在服务类的接口被更改或替换时很有用：你无需修改客户端代码就可以创建新的适配器类  </li>
</ol>
<p><strong>类适配器</strong></p>
<p>这一实现使用了继承机制：适配器同时继承两个对象的接口。请注意， 这种方式仅能在支持多重继承的编程语言中实现，例如 C++  </p>
<p><img src="/posts/18127/image-20240313184304644.png" alt="image-20240313184304644"></p>
<ol>
<li>类适配器不需要封装任何对象，因为它同时继承了客户端和<br> 服务的行为。适配功能在重写的方法中完成。最后生成的适<br> 配器可替代已有的客户端类进行使用</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>方钉与圆孔</p>
<p><img src="/posts/18127/image-20240313184632609.png" alt="image-20240313184632609"></p>
<p>适配器假扮成一个圆钉（RoundPeg），其半径等于方钉（SquarePeg）横截面对角线的一半（即能够容纳方钉的最小外接圆的半径）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设你有两个接口相互兼容的类：圆孔（RoundHole）和圆钉（RoundPeg）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundHole</span> is</span><br><span class="line">	constructor <span class="title function_">RoundHole</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> 	method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line"> 	<span class="comment">// 返回孔的半径。</span></span><br><span class="line"></span><br><span class="line"> 	method <span class="title function_">fits</span><span class="params">(peg: RoundPeg)</span> is</span><br><span class="line"> 		<span class="keyword">return</span> <span class="built_in">this</span>.getRadius() &gt;= peg.getRadius()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">  constructor <span class="title function_">RoundPeg</span><span class="params">(radius)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line"> <span class="comment">// 返回钉子的半径。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 但还有一个不兼容的类：方钉（SquarePeg）。</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SquarePeg</span> is</span><br><span class="line"> 	constructor <span class="title function_">SquarePeg</span><span class="params">(width)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"> 	method <span class="title function_">getWidth</span><span class="params">()</span> is</span><br><span class="line"> 	<span class="comment">// 返回方钉的宽度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适配器对象作为圆钉。</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SquarePegAdapter</span> <span class="keyword">extends</span> <span class="title class_">RoundPeg</span> is</span><br><span class="line">   <span class="comment">// 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。</span></span><br><span class="line">   <span class="keyword">private</span> field peg: SquarePeg</span><br><span class="line">   constructor <span class="title function_">SquarePegAdapter</span><span class="params">(peg: SquarePeg)</span> is</span><br><span class="line">   	<span class="built_in">this</span>.peg = peg</span><br><span class="line"></span><br><span class="line"> method <span class="title function_">getRadius</span><span class="params">()</span> is</span><br><span class="line">   <span class="comment">// 适配器会假扮为一个圆钉，</span></span><br><span class="line">   <span class="comment">// 其半径刚好能与适配器实际封装的方钉搭配起来。</span></span><br><span class="line">   <span class="keyword">return</span> peg.getWidth() * Math.sqrt(<span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 客户端代码中的某个位置。</span></span><br><span class="line">  hole = <span class="keyword">new</span> <span class="title class_">RoundHole</span>(<span class="number">5</span>)</span><br><span class="line">  rpeg = <span class="keyword">new</span> <span class="title class_">RoundPeg</span>(<span class="number">5</span>)</span><br><span class="line">  hole.fits(rpeg) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	small_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">5</span>)</span><br><span class="line">  large_sqpeg = <span class="keyword">new</span> <span class="title class_">SquarePeg</span>(<span class="number">10</span>)</span><br><span class="line">  hole.fits(small_sqpeg) <span class="comment">// 此处无法编译（类型不一致）。</span></span><br><span class="line"></span><br><span class="line">  small_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(small_sqpeg)</span><br><span class="line">  large_sqpeg_adapter = <span class="keyword">new</span> <span class="title class_">SquarePegAdapter</span>(large_sqpeg)</span><br><span class="line">  hole.fits(small_sqpeg_adapter) <span class="comment">// true</span></span><br><span class="line">  hole.fits(large_sqpeg_adapter) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类</p>
<p>  适配器模式允许你创建一个中间层类，其可作为代码与遗留类、第三方类或提供怪异接口的类之间的转换器  </p>
</li>
<li><p>如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性</p>
<p>  你可以扩展每个子类，将缺少的功能添加到新的子类中。但是，你必须在所有新子类中重复添加这些代码，这样会使得代码有坏味道</p>
<p>  将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。然后你可以将缺少功能的对象封装在适配器中，从而动态地获取所需功能。如要这一点正常运作，目标类必须要有通用接口，适配器的成员变量应当遵循该通用接口。这种方式同装饰模式非常相似  </p>
</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保至少有两个类的接口不兼容：<ol>
<li>一个无法修改（通常是第三方、遗留系统或者存在众多已<br> 有依赖的类）的功能性服务类</li>
<li>一个或多个将受益于使用服务类的客户端类</li>
</ol>
</li>
<li>声明客户端接口，描述客户端如何与服务交互</li>
<li>创建遵循客户端接口的适配器类。所有方法暂时都为空</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化，但有时在调用其方法时将该变量传递给适配器会更方便</li>
<li>依次实现适配器类客户端接口的所有方法。适配器会将实际工作委派给服务对象，自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。这样一来，你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>单一职责原则 你可以将接口或数据转换代码从程序主要业务逻辑中分离</li>
<li>开闭原则 只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器</li>
</ul>
<hr>
<ul>
<li>代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单</li>
</ul>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 桥接">桥接</a>通常会于开发前期进行设计，使你能够将程序的各个部分独立开来以便开发。另一方面，<a href="# 适配器">适配器</a>通常在已有程序中使用，让相互不兼容的类能很好地合作</li>
<li>适配器可以对已有对象的接口进行修改，<a href="# 装饰">装饰</a>则能在不改变对象接口的前提下强化对象功能。此外，装饰还支持递归组合，适配器则无法实现</li>
<li>适配器能为被封装对象提供不同的接口，<a href="# 代理">代理</a>能为对象提供相同的接口，装饰则能为对象提供加强的接口</li>
<li><a href="# 外观">外观</a>为现有对象定义了一个新接口，适配器则会试图运用已有的接口。适配器通常只封装一个对象，外观通常会作用于整个对象子系统上</li>
<li>桥接、<a href="# 状态">状态</a>和<a href="# 策略">策略</a>（在某种程度上包括适配器）模式的接口非常相似。实际上，它们都基于组合模式——即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题</li>
</ul>
<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><blockquote>
<p>Bridge</p>
</blockquote>
<p>桥接是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p>
<h3 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h3><p>假如有一个几何形状<code>Shape</code>类，从它能扩展出两个子类：圆形<code>Circle</code>和方形<code>Square</code>。你希望对这样的类层次结构进行扩展以使其包含颜色，所以你打算创建名为红色<code>Red</code>和蓝色<code>Blue</code>的形状子类。但是，由于你已有两个子类，所以总共需要创建四个类才能覆盖所有组合，例如蓝色圆形<code>BlueCircle</code>和红色方形<code>RedSquare</code>。</p>
<p><img src="/posts/18127/image-20240325180839879.png" alt="image-20240325180839879"></p>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。例如添加三角形状，你需要新增两个子类，也就是每种颜色一个；此后新增一种新颜色需要新增三个子类，即每种形状一个。如此以往，情况会越来越糟糕。  </p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题的根本原因是我们试图在两个独立的维度（形状与颜色）上扩展形状类。这在处理类继承时是很常见的问题。</p>
<p>桥接模式通过将继承改为组合的方式来解决这个问题。具体来说，就是抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象，从而使得一个类不必拥有所有的状态和行为。</p>
<p><img src="/posts/18127/image-20240325181312494.png" alt="image-20240325181312494"></p>
<p>根据该方法，我们可以将颜色相关的代码抽取到拥有红色和蓝色两个子类的颜色类中，然后在形状类中添加一个指向某一颜色对象的引用成员变量。现在，形状类可以将所有与颜色相关的工作委派给连入的颜色对象。这样的引用就成为了形状和颜色之间的桥梁。此后，新增颜色将不再需要修改形状的类层次，反之亦然。</p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240325182144916.png" alt="image-20240325182144916"></p>
<ol>
<li><p><strong>抽象部分</strong>（Abstraction）提供高层控制逻辑，依赖于完成底层实际工作的实现对象</p>
</li>
<li><p><strong>实现部分</strong>（Implementation）为所有具体实现声明通用接口。抽象部分仅能通过在这里声明的方法与实现对象交互</p>
<p> 抽象部分可以列出和实现部分一样的方法，但是抽象部分通常声明一些复杂行为，这些行为依赖于多种由实现部分声明的原语操作  </p>
</li>
<li><p><strong>具体实现</strong>（Concrete Implementations）中包括特定于平台的<br> 代码</p>
</li>
<li><p><strong>精确抽象</strong>（Refined Abstraction）提供控制逻辑的变体。与其<br> 父类一样，它们通过通用实现接口与不同的实现进行交互</p>
</li>
<li><p><strong>客户端</strong>（Client）一般仅关心如何与抽象部分合作。但是，客户端需要将抽象对象与一个实现对象连接起来</p>
</li>
</ol>
<h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><p>示例演示了桥接模式如何拆分程序中同时管理设备及其遥控器的庞杂代码。 设备<code>Device</code>类作为实现部分， 而遥控器<code>Remote</code>类则作为抽象部分</p>
<p><img src="/posts/18127/image-20240325182421310.png" alt="image-20240325182421310"></p>
<p>最初类层次结构被拆分为两个部分：设备和遥控器  </p>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。所有遥控器通过通用设备接口与设备进行交互，使得同一个遥控器可以支持不同类型的设备  </p>
<p>你可以开发独立于设备类的遥控器类，只需新建一个遥控器子类即可。例如，基础遥控器可能只有两个按钮，但你可在其基础上扩展新功能，比如额外的一节电池或一块触摸屏</p>
<p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">	<span class="keyword">protected</span> field device: Device</span><br><span class="line">	constructor <span class="title function_">RemoteControl</span><span class="params">(device: Device)</span> is</span><br><span class="line">		<span class="built_in">this</span>.device = device</span><br><span class="line">	method <span class="title function_">togglePower</span><span class="params">()</span> is</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(device.isEnabled()</span>) then</span><br><span class="line">			device.disable()</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			device.enable()</span><br><span class="line">			</span><br><span class="line">	method <span class="title function_">volumeDown</span><span class="params">()</span> is</span><br><span class="line">		device.setVolume(device.getVolume() - <span class="number">10</span>)</span><br><span class="line">		</span><br><span class="line">	method <span class="title function_">volumeUp</span><span class="params">()</span> is</span><br><span class="line">		device.setVolume(device.getVolume() + <span class="number">10</span>)</span><br><span class="line">		</span><br><span class="line">	method <span class="title function_">channelDown</span><span class="params">()</span> is</span><br><span class="line">		device.setChannel(device.getChannel() - <span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">	method <span class="title function_">channelUp</span><span class="params">()</span> is</span><br><span class="line">		device.setChannel(device.getChannel() + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdvancedRemoteControl</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> is</span><br><span class="line">  method <span class="title function_">mute</span><span class="params">()</span> is</span><br><span class="line">    device.setVolume(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而抽象接口则会基于这些操作定义较高层次的操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Device</span> is</span><br><span class="line">	method <span class="title function_">isEnabled</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">enable</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">disable</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">getVolume</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">setVolume</span><span class="params">(percent)</span></span><br><span class="line">	method <span class="title function_">getchannel</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">setchannel</span><span class="params">(channel)</span><span class="comment">//所有设备都遵循相同的接口。</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tv</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Radio</span> <span class="keyword">implements</span> <span class="title class_">Device</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码中的某个位置。</span></span><br><span class="line"></span><br><span class="line">tv = <span class="keyword">new</span> <span class="title class_">Tv</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> <span class="title class_">Radio</span>()</span><br><span class="line">remote = <span class="keyword">new</span> <span class="title class_">AdvancedRemoteControl</span>(radio)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式</p>
<p>  类的代码行数越多，弄清其运作方式就越困难，对其进行修改所花费的时间就越长。一个功能上的变化可能需要在整个类范围内进行修改，而且常常会产生错误，甚至还会有一些严重的副作用、</p>
<p>  桥接模式可以将庞杂类拆分为几个类层次结构。此后，你可以修改任意一个类层次结构而不会影响到其他类层次结构。这种方法可以简化代码的维护工作，并将修改已有代码的风险降到最低</p>
</li>
<li><p>如果你希望在几个独立维度上扩展一个类，可使用该模式</p>
<p>  桥接建议将每个维度抽取为独立的类层次。初始类将相关工作委派给属于对应类层次的对象，无需自己完成所有工作</p>
</li>
<li><p>如果你需要在运行时切换不同实现方法，可使用桥接模式</p>
<p>  当然并不是说一定要实现这一点，桥接模式可替换抽象部分中的实现对象，具体操作就和给成员变量赋新值一样简单</p>
<p>  顺便提一句，最后一点是很多人混淆桥接模式和策略模式的主要原因。记住，设计模式并不仅是一种对类进行组织的方式，它还能用于沟通意图和解决问题  </p>
</li>
</ul>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>明确类中独立的维度。独立的概念可能是：抽象/平台，域/基础设施，前端/后端或接口/实现。</li>
<li>了解客户端的业务需求，并在抽象基类中定义它们。</li>
<li>确定在所有平台上都可执行的业务，并在通用实现接口中声明抽象部分所需的业务。</li>
<li>为你域内的所有平台创建实现类，但需确保它们遵循实现部分的接口。</li>
<li>在抽象类中添加指向实现类型的引I用成员变量。抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</li>
<li>如果你的高层逻辑有多个变体，则可通过扩展抽象基类为每个变体创建一个精确抽象。</li>
<li>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。此后，客户端只需与抽象对象进行交互，无需和实现对象打交道。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。</li>
<li>开闭原则。你可以新增抽象部分和实现部分，且它们之间不会相互影响。</li>
<li>单一职责原则。抽象部分专注于处理高层逻辑，实现部分处理平台细节。</li>
</ul>
<hr>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h3 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 桥接">桥接</a>通常会于开发前期进行设计，使你能够将程序的各个部分独立开来以便开发。另一方面，<a href="# 适配器">适配器</a>通常在已有程序中使用，让相互不兼容的类能很好地合作。</li>
<li>桥接、<a href="# 状态">状态</a>和<a href="# 策略">策略</a>（在某种程度上包括适配器）模式的接口非常相似。实际上，它们都基于<a href="# 组合">组合</a>模式—即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>你可以将<a href="# 抽象工厂">抽象工厂</a>和桥接搭配使用。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，抽象工厂可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。</li>
<li>你可以结合使用<a href="# 生成器">生成器</a>和桥接模式：主管类负责抽象工作，各种不同的生成器负责实现工作。</li>
</ul>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote>
<p>对象树、Object Tree、Composite</p>
</blockquote>
<p>组合是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们</p>
<h3 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h3><p>例如，你有两类对象：产品和盒子。一个盒子中可以包含多个产品或者几个较小的盒子。这些小盒子中同样可以包含一些产品或更小的盒子，以此类推。<br>假设你希望在这些类的基础上开发一个定购系统。订单中可以包含无包装的简单产品，也可以包含装满产品的盒子以及其他盒子。此时你会如何计算每张订单的总价格呢？</p>
<p><img src="/posts/18127/image-20240326184154308.png" alt="image-20240326184154308"></p>
<p>现实世界可以打开所有盒子，找到每件产品，然后计算总价，但在程序中并不能简单地使用循环语句来完成该工作。因为必须事先知道所有产品和盒子的类别，所有盒子的嵌套层数以及其他繁杂的细节信息。因此，直接计算极不方便，甚至完全不可行。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>组合模式建议使用一个通用接口来与产品和盒子进行交互，并且在该接口中声明一个计算总价的方法：</p>
<ul>
<li>对于一个产品，该方法直接返回其价格</li>
<li>对于一个盒子，该方法遍历盒子中的所有项目，询问每个项目的价格，然后返回该盒子的总价格。</li>
</ul>
<p>如果其中某个项目是小一号的盒子，那么当前盒子也会遍历其中的所有项目，以此类推，直到计算出所有内部组成部分的价格。</p>
<p><img src="/posts/18127/image-20240326184505398.png" alt="image-20240326184505398"></p>
<h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240326184516104.png" alt="image-20240326184516104"></p>
<ol>
<li><strong>组件</strong>（Component）接口描述了树中简单项目和复杂项目所共有的操作</li>
<li><strong>叶节点</strong>（Leaf）是树的基本结构，它不包含子项目</li>
<li><strong>容器</strong>（Container）—又名”组合（Composite）”—是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用的组件接口与其子项目交互。</li>
<li><strong>客户端</strong>（Client）通过组件接口与所有项目交互。因此，客<br>户端能以相同方式与树状结构中的简单或复杂项目交互</li>
</ol>
<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>借助组合模式帮助你在图形编辑器中实现一系列的几何图形。组合图形 <code>CompoundGraphic</code> 是一个容器，它可以由多个包括容器在内的子图形构成。组合图形与简单图形拥有相同的方法。但是，组合图形自身并不完成具体工作，而是将请求递归地传递给自己的子项目，然后“汇总”结果。<br>通过所有图形类所共有的接口，客户端代码可以与所有图形互动。因此，客户端不知道与其交互的是简单图形还是组合图形。客户端可以与非常复杂的对象结构进行交互，而无需与组成该结构的实体类紧密耦合。</p>
<p><img src="/posts/18127/image-20240326184753654.png" alt="image-20240326184753654" style="zoom:50%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件接口会声明组合中简单和复杂对象的通用操作。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Graphic</span> is</span><br><span class="line">  </span><br><span class="line">	method <span class="title function_">move</span><span class="params">(x， y)</span></span><br><span class="line">  </span><br><span class="line">	method <span class="title function_">draw</span><span class="params">()</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象E通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。class Dot implements Graphic is</span></span><br><span class="line">	field x, y</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Dot</span><span class="params">(x, y）&#123;...&#125;</span></span><br><span class="line"><span class="params">	</span></span><br><span class="line"><span class="params">	method move(x, y)</span> is</span><br><span class="line">		<span class="built_in">this</span>.x += x</span><br><span class="line">		<span class="built_in">this</span>.y += y</span><br><span class="line">	method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">		<span class="comment">//在坐标位置(X,Y)处绘制一个点。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//所有组件类都可以扩展其他组件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Dot</span> is</span><br><span class="line">  field radius</span><br><span class="line"></span><br><span class="line">  constructor <span class="title function_">Circle</span><span class="params">(x, y, radius)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">//在坐标位置（X，Y）处绘制一个半径为R的圆。</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项目，然后”汇总”结果。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompoundGraphic</span> <span class="keyword">implements</span> <span class="title class_">Graphic</span> is</span><br><span class="line">	field children: array of Graphic</span><br><span class="line">  <span class="comment">//组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。</span></span><br><span class="line">  method <span class="title function_">add</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">  	<span class="comment">//在子项目数组中添加一个子项目。</span></span><br><span class="line">  method <span class="title function_">remove</span><span class="params">(child: Graphic)</span> is</span><br><span class="line">    <span class="comment">//从子项目数组中移除一个子项目。</span></span><br><span class="line">  method <span class="title function_">move</span><span class="params">(x, y)</span> is</span><br><span class="line">    <span class="title function_">foreach</span> <span class="params">(child in children)</span> <span class="keyword">do</span> </span><br><span class="line">  		child.move(x, y)</span><br><span class="line"><span class="comment">//组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，最后组合将会完成整个对象树的遍历工作。</span></span><br><span class="line">  method <span class="title function_">draw</span><span class="params">()</span> is</span><br><span class="line">    <span class="comment">//1. 对于每个子部件：</span></span><br><span class="line">    <span class="comment">//  1.1 绘制该部件。</span></span><br><span class="line">    <span class="comment">//  2.2 更新边框坐标。</span></span><br><span class="line">    <span class="comment">//2. 根据边框坐标绘制一个虚线长方形</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同时支持简单叶节点组件和复杂组件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageEditor</span> is</span><br><span class="line">  field all: CompoundGraphic</span><br><span class="line">  method <span class="title function_">load</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">    <span class="variable">all</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">    all.add（<span class="keyword">new</span> <span class="title class_">Dot</span>（<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">		all.add（<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>,<span class="number">3</span>, <span class="number">10</span>）)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将所需组件组合为复杂的组合组件。</span></span><br><span class="line">	method <span class="title function_">groupSelected</span><span class="params">(components: array of Graphic)</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompoundGraphic</span>()</span><br><span class="line">  	foreach (component in components) <span class="keyword">do</span></span><br><span class="line">				group.add(component)</span><br><span class="line">  			all.remove(component)</span><br><span class="line">    all.add(group)</span><br><span class="line">  	<span class="comment">//所有组件都将被绘制</span></span><br><span class="line">		all.draw()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你需要实现树状对象结构，可以使用组合模式\</p>
<p>组合模式为你提供了两种共享公共接口的基本元素类型：简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。这使得你可以构建树状嵌套递归对象结构</p>
</li>
<li><p>如果你希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式</p>
<p>组合模式中定义的所有元素共用同一个接口。在这一接口的帮助下，客户端不必在意其所使用的对象的具体类</p>
</li>
</ul>
<h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><p>确保应用的核心模型能够以树状结构表示。尝试将其分解为简单元素和容器。记住，容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li><p>声明组件接口及其一系列方法，这些方法对简单和复杂元素都有意义。</p>
</li>
<li><p>创建一个叶节点类表示简单元素。程序中可以有多个不同的叶节点类。</p>
</li>
<li><p>创建一个容器类表示复杂元素。在该类中，创建一个数组成员变量来存储对于其子元素的引用。该数组必须能够同时保存叶节点和容器，因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时，记住容器应该将大部分工作交给其子元素来完成。</p>
</li>
<li><p>最后，在容器中定义添加和删除子元素的方法。</p>
<p>记住，这些操作可在组件接口中声明。这将会违反_接口隔离原则_，因为叶节点类中的这些方法为空。但是，这可以让客户端无差别地访问所有元素，即使是组成树状结构的元素。  </p>
</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以利用多态和递归机制更方便地使用复杂树结构</li>
<li>开闭原则。无需更改现有代码，你就可以在应用中添加新元素，使其成为对象树的一部分</li>
</ul>
<hr>
<ul>
<li>对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解</li>
</ul>
<h3 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p><a href="# 桥接">桥接</a>、<a href="# 状态">状态</a>和<a href="# 策略">策略</a>（在某种程度上包括<a href="# 适配器">适配器</a>）模式的接口非常相似。实际上，它们都基于<a href="# 组合">组合</a>模式一即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li><p>你可以在创建复杂组合树时使用<a href="# 生成器">生成器</a>，因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li><p><a href="# 责任链">责任链</a>通常和组合模式结合使用。在这种情况下，叶组件接收到请求后，可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li><p>你可以使用<a href="# 迭代器">选代器</a>来遍历组合树。</p>
</li>
<li><p>你可以使用<a href="# 访问者">访问者</a>对整个组合树执行操作。</p>
</li>
<li><p>你可以使用<a href="# 享元">享元</a>实现组合树的共享叶节点以节省内存。</p>
</li>
<li><p>组合和<a href="# 装饰">装饰</a>的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合，但其只有一个子组件。此外还有一个明显不同：装饰为被封装对象添加了额外的职责，组合仅对其子节点的结果进行了“求和”。</p>
<p>但是，模式也可以相互合作：你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于原型的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。</p>
</li>
</ul>
<h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><blockquote>
<p>装饰器模式、Wrapper、Decorator</p>
</blockquote>
<p>装饰是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<h3 id="问题背景-3"><a href="#问题背景-3" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你正在开发一个提供通知功能的库，其他程序可使用它向用户发送关于重要事件的通知。</p>
<p>库的最初版本基于通知器<code>Notifier</code>类，其中只有很少的几个成员变量，一个构造函数和一个<code>send</code>发送方法。该方法可以接收来自客户端的消息参数，并将该消息发送给一系列的邮箱，邮箱列表则是通过构造函数传递给通知器的。作为客户端的第三方程序仅会创建和配置通知器对象一次，然后在有重要事件发生时对其进行调用。</p>
<p><img src="/posts/18127/image-20240327185356259.png" alt="image-20240327185356259"></p>
<p>此后某个时刻，你会发现库的用户希望使用除邮件通知之外的功能。许多用户会希望接收关于紧急事件的手机短信，还有些用户希望在微信上接收消息，而公司用户则希望在QQ上接收消息。</p>
<p><img src="/posts/18127/image-20240327185429537.png" alt="image-20240327185429537"></p>
<p>首先扩展通知器类，然后在新的子类中加入额外的通知方法。现在客户端要对所需通知形式的对应类进行初始化，然后使用该类发送后续所有的通知消息</p>
<p>但是很快有人会问：“为什么不同时使用多种通知形式呢？如果房子着火了，你大概会想在所有渠道中都收到相同的消息吧。</p>
<p>你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。但这种方式会使得代码量迅速膨胀，不仅仅是程序库代码，客户端代码也会如此</p>
<p><img src="/posts/18127/image-20240327185717738.png" alt="image-20240327185717738"></p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>当你需要更改一个对象的行为时，第一个跳入脑海的想法就是扩展它所属的类。但是，你不能忽视继承可能引发的几个严重问题。</p>
<ol>
<li>继承是静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来替代当前的整个对象。</li>
<li>子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为</li>
</ol>
<p>另一种方法是组合或者聚合。两者的工作方式几乎一模一样：一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象；继承中的对象则继承了父类的行为，它们自己能够完成这些工作。 </p>
<p>可以使用这个新方法来轻松替换各种连接的“小帮手”对象，从而能在运行时改变容器的行为。一个对象可以使用多个类的行为，包含多个指向其他对象的引用，并将各种工作委派给引用对象。  </p>
<p>聚合（或组合）是许多设计模式背后的关键原则（包括装饰在内）。</p>
<p><img src="/posts/18127/image-20240327190304920.png" alt="image-20240327190304920"></p>
<p>封装器是装饰模式的别称，这个称谓明确地表达了该模式的主要思想。“封装器”是一个能与其他“目标”对象连接的对象。封装器包含与目标对象相同的一系列方法，它会将所有接收到的请求委派给目标对象。但是，封装器可以在将请求委派给目标前后对其进行处理，所以可能会改变最终结果。</p>
<p>封装器实现了与其封装对象相同的接口。因此从客户端的角度来看，这些对象是完全一样的。封装器中的引用成员变量可以是遵循相同接口的任意对象。这使得你可以将一个对象放入多个封装器中，并在对象中添加所有这些封装器的组合行为。</p>
<p>比如在消息通知示例中，我们可以将简单邮件通知行为放在基类 通知器 中，但将所有其他通知方法放入装饰中。  </p>
<p><img src="/posts/18127/image-20240327190814916.png" alt="image-20240327190814916"></p>
<h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240327190938690.png" alt="image-20240327190938690"></p>
<ol>
<li>部件（Component）声明封装器和被封装对象的公用接口。  </li>
<li>具体部件（Concrete Component）类是被封装对象所属的类。它定义了基础行为，但装饰类可以改变这些行为。</li>
<li>基础装饰（Base Decorator）类拥有一个指向被封装对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象。</li>
<li>具体装饰类（Concrete Decorators）定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为</li>
<li>客户端（Client）可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象互动即可。</li>
</ol>
<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>装饰模式能够对敏感数据进行压缩和加密，从而将数据从使用数据的代码中独立出来  </p>
<p><img src="/posts/18127/image-20240327191428466.png" alt="image-20240327191428466"></p>
<p>程序使用一对装饰来封装数据源对象。这两个封装器都改变了从磁盘读写数据的方式：</p>
<ul>
<li>当数据即将被写入磁盘前，装饰对数据进行加密和压缩。在原始类对改变毫无察觉的情况下，将加密后的受保护数据写入文件。</li>
<li>当数据刚从磁盘读出后，同样通过装饰对数据进行解压和解密。装饰和数据源类实现同一接口，从而能在客户端代码中相互替换  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰可以改变组件接口所定义的操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataSource</span> is</span><br><span class="line">	method <span class="title function_">writeData</span><span class="params">(data)</span></span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">  constructor <span class="title function_">FileDataSource</span><span class="params">(filename)</span> &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">    <span class="comment">// 将数据写入文件。</span></span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">    <span class="comment">// 从文件读取数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并且负责对其进行初始化。</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSourceDecorator</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> is</span><br><span class="line">	<span class="keyword">protected</span> field wrappee: DataSource</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">DataSourceDecorator</span><span class="params">(source: DataSource)</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">wrappee</span> <span class="operator">=</span> source</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些额外的行为。</span></span><br><span class="line">	method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">		wrappee.writeData(data)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 具体装饰可可简化装饰类的扩展工作。调用其父类的操作实现，而不是直接调用被封装对象。这种方式可简化装饰类的扩展工作。</span></span><br><span class="line">	method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">    <span class="keyword">return</span> wrappee.readData()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。装饰必须在调用封装对象之前或之后执行额外的行为。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncryptionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">  method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">    <span class="comment">// 1. 对传递数据进行加密。</span></span><br><span class="line">    <span class="comment">// 2. 将加密后数据传递给被封装对象 writeData（写入数据）方法</span></span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">  	<span class="comment">// 1. 通过被封装对象的 readData（读取数据）方法获取数据</span></span><br><span class="line">  	<span class="comment">// 2. 如果数据被加密就尝试解密</span></span><br><span class="line">  	<span class="comment">// 3. 返回结果。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 你可以将对象封装在多层装饰中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompressionDecorator</span> <span class="keyword">extends</span> <span class="title class_">DataSourceDecorator</span> is</span><br><span class="line">  method <span class="title function_">writeData</span><span class="params">(data)</span> is</span><br><span class="line">  	<span class="comment">// 1. 压缩传递数据。</span></span><br><span class="line">  	<span class="comment">// 2. 将压缩后数据传递给被封装对象 writeData（写入数据）方法。</span></span><br><span class="line">  method <span class="title function_">readData</span><span class="params">()</span>:data is</span><br><span class="line">  	<span class="comment">// 1. 通过被封装对象的 readData（读取数据）方法获取数据</span></span><br><span class="line">  	<span class="comment">// 2. 如果数据被压缩就尝试解压</span></span><br><span class="line">  	<span class="comment">// 3. 返回结果。</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 选项 1：装饰组件的简单示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">dumbUsageExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;somefile.dat&quot;</span>)</span><br><span class="line">  	source.writeData(salaryRecords)</span><br><span class="line">  	<span class="comment">// 将明码数据写入目标文件</span></span><br><span class="line">  </span><br><span class="line">  	source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line">  	source.writeData(salaryRecords)</span><br><span class="line">  	<span class="comment">// 将压缩数据写入目标文件</span></span><br><span class="line">  </span><br><span class="line">  	source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">  	<span class="comment">// 源变量中现在包含：</span></span><br><span class="line">  	<span class="comment">// Encryption &gt; Compression &gt; FileDataSource</span></span><br><span class="line">  	<span class="comment">// 已将压缩且加密的数据写入目标文件</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 选项 2：客户端使用外部数据源。SalaryManager（工资管理器）对象并不关心数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配置器获取的。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalaryManager</span> is</span><br><span class="line">  field source: DataSource</span><br><span class="line">  constructor <span class="title function_">SalaryManager</span><span class="params">(source: DataSource)</span> &#123; ... &#125;</span><br><span class="line">	method <span class="title function_">load</span><span class="params">()</span> is</span><br><span class="line">    <span class="keyword">return</span> source.readData()</span><br><span class="line">	method <span class="title function_">save</span><span class="params">()</span> is</span><br><span class="line">    source.writeData(salaryRecords)</span><br><span class="line">  <span class="comment">// ...其他有用的方法..</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 程序可在运行时根据配置或环境组装不同的装饰堆桟。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationConfigurator</span> is</span><br><span class="line">  method <span class="title function_">configurationExample</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;salary.dat&quot;</span>)</span><br><span class="line">  	<span class="keyword">if</span> (enabledEncryption)</span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">EncryptionDecorator</span>(source)</span><br><span class="line">    <span class="keyword">if</span> (enabledCompression)</span><br><span class="line">      source = <span class="keyword">new</span> <span class="title class_">CompressionDecorator</span>(source)</span><br><span class="line">    logger = <span class="keyword">new</span> <span class="title class_">SalaryManager</span>(source)</span><br><span class="line">    salary = logger.load()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式</p>
<p>装饰能将业务逻辑组织为层次结构，你可为各层创建一个装饰，在运行时将各种不同逻辑组合成对象。由于这些对象都遵循通用接口，客户端代码能以相同的方式使用这些对象  </p>
</li>
<li><p>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式  </p>
<p>许多编程语言使用 final 最终 关键字来限制对某个类的进一步扩展。复用最终类已有行为的唯一方法是使用装饰模式：用封装器对其进行封装  </p>
</li>
</ul>
<h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</li>
<li>找出基本组件和可选层次的通用方法。创建一个组件接口并在其中声明这些方法。</li>
<li>创建一个具体组件类，并定义其基础行为。</li>
<li>创建装饰基类，使用一个成员变量存储指向被封装对象的引用。该成员变量必须被声明为组件接口类型，从而能在运行时连接具体组件和装饰。装饰基类必须将所有工作委派给被封装的对象。</li>
<li>确保所有类实现组件接口。</li>
<li>将装饰基类扩展为具体装饰。具体装饰必须在调用父类方法（总是委派给被封装对象）之前或之后执行自身的行为。  </li>
<li>客户端代码负责创建装饰并将其组合成客户端所需的形式  </li>
</ol>
<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你无需创建新子类即可扩展对象的行为。</li>
<li>你可以在运行时添加或删除对象的功能。</li>
<li>你可以用多个装饰封装对象来组合几种行为。</li>
<li>单一职责原则。你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</li>
</ul>
<hr>
<ul>
<li>在封装器栈中删除特定封装器比较困难。</li>
<li>实现行为不受装饰栈顺序影响的装饰比较困难。</li>
<li>各层的初始化配置代码看上去可能会很糟糕。</li>
</ul>
<h3 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><p><a href="# 适配器">适配器</a>可以对已有对象的接口进行修改，<a href="# 装饰">装饰</a>则能在不改变对象接口的前提下强化对象功能。此外，装饰还支持递归组合，适配器则无法实现</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口，<a href="# 代理">代理</a>能为对象提供相同的接口，装饰则能为对象提供加强的接口。  </p>
</li>
<li><p><a href="# 责任链">责任链</a>和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。</p>
<p>责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外，装饰无法中断请求的传递。</p>
</li>
<li><p>组合和装饰的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。装饰类似于组合，但其只有一个子组件。此外还有一个明显不同：装饰为被封装对象添加了额外的职责，组合仅对其子节点的结果进行了“求和”。</p>
<p>但是，模式也可以相互合作：你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于<a href="# 原型">原型</a>的使用中获益。你可以通过该模式来复制复杂结构，而非从零开始重新构造。</p>
</li>
<li>装饰可让你更改对象的外表，策略则让你能够改变其本质。</li>
<li>装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。</li>
</ul>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><blockquote>
<p>门面模式、Facade</p>
</blockquote>
<p>外观是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p>
<h3 id="问题背景-4"><a href="#问题背景-4" class="headerlink" title="问题背景"></a>问题背景</h3><p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。正常情况下，你需要负责所有对象的初始化工作、管理其依赖关系并按正确的顺序执行方法等。</p>
<p>最终，程序中类的业务逻辑将与第三方类的实现细节紧密耦合，使得理解和维护代码的工作很难进行。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观提供的功能可能比较有限，但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合，但只需使用其中非常少的功能，那么使用外观模式会非常方便，例如，上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库，但它只需使用一个包含encode(filename,format)方法（以文件名与文件格式为参数进行编码的方法）的类即可。在创建这个类并将其连接到视频转换库后，你就拥有了自己的第一个外观。</p>
<h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240401183018070.png" alt="image-20240401183018070"></p>
<ol>
<li>外观（<code>Facade</code>）提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求，知晓如何操作一切活动部件。</li>
<li>创建附加外观（<code>Additional Facade</code>）类可以避免多种不相关的功能污染单一外观，使其变成又一个复杂结构。客户端和其他外观都可使用附加外观。</li>
<li>复杂子系统（<code>Complex Subsystem</code>）由数十个不同对象构成。如果要用这些对象完成有意义的工作，你必须深入了解子系统的实现细节，比如按照正确顺序初始化对象和为其提供正确格式的数据。</li>
<li>客户端（<code>Client</code>）使用外观代替对子系统对象的直接调用。  </li>
</ol>
<h3 id="伪代码-4"><a href="#伪代码-4" class="headerlink" title="伪代码"></a>伪代码</h3><p>外观模式简化了客户端与复杂视频转换框架之间的交互</p>
<p><img src="/posts/18127/image-20240401183412101.png" alt="image-20240401183412101"></p>
<p>创建一个封装所需功能并隐藏其他代码的外观类，从而无需使全部代码直接与数十个框架类进行交互。该结构还能将未来框架升级或更换所造成的影响最小化，因为你只需修改程序中外观方法的实现即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法对其进行简化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoFile</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OggCompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MPEG4CompressionCodec</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodecFactory</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitrateReader</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioMixer</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在功能性和简洁性之间做出的权衡。</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoConverter</span> is</span><br><span class="line">  method <span class="title function_">convert</span><span class="params">(filename, format)</span>:File <span class="type">is</span></span><br><span class="line">  	<span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoFile</span>(filename)</span><br><span class="line">  	sourceCodec = <span class="keyword">new</span> <span class="title class_">CodecFactory</span>.extract(file)</span><br><span class="line">  	<span class="keyword">if</span> (format == <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">    	destinationCodec = <span class="keyword">new</span> <span class="title class_">MPEG4CompressionCodec</span>()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      destinationCodec = <span class="keyword">new</span> <span class="title class_">OggCompressionCodec</span>()</span><br><span class="line">    buffer = BitrateReader.read(filename, sourceCodec)</span><br><span class="line">    result = BitrateReader.convert(buffer, destinationCodec)</span><br><span class="line">    result = (<span class="keyword">new</span> <span class="title class_">AudioMixer</span>()).fix(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(result)</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，那只需重写外观类即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">main</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">convertor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoConverter</span>()</span><br><span class="line">  	mp4 = convertor.convert(<span class="string">&quot;funny-cats-video.ogg&quot;</span>, <span class="string">&quot;mp4&quot;</span>)</span><br><span class="line">  	mp4.save()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式</strong></p>
<p>子系统通常会随着时间的推进变得越来越复杂。即便是应用了设计模式，通常你也会创建更多的类。尽管在多种情形中子系统可能是更灵活或易于复用的，但其所需的配置和样板代码数量将会增长得更快。为了解决这个问题，外观将会提供指向子系统中最常用功能的快捷方式，能够满足客户端的大部分需求。</p>
</li>
<li><p><strong>如果需要将子系统组织为多层结构，可以使用外观</strong></p>
<p>创建外观来定义子系统中各层次的入口。你可以要求子系统仅使用外观来进行交互，以减少子系统之间的耦合</p>
<p>视频转换框架可以拆分为两个层次：音频相关和视频相关。可以为每个层次创建一个外观，然后要求各层的类必须通过这些外观进行交互。这种方式看上去与中介者模式非常相似</p>
</li>
</ul>
<h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类，那么你的方向就是正确的  </li>
<li>在一个新的外观类中声明并实现该接口。外观应将客户端代码的调用重定向到子系统中的相应对象处。如果客户端代码没有对子系统进行初始化，也没有对其后续生命周期进行管理，那么外观必须完成此类工作</li>
<li>如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观来与子系统进行交互。此后客户端代码将不会受到任何由子系统代码修改而造成的影响，比如子系统升级后，你只需修改外观中的代码即可</li>
<li>如果外观变得过于臃肿，你可以考虑将其部分行为抽取为一个新的专用外观类</li>
</ol>
<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以让自己的代码独立于复杂子系统</li>
</ul>
<hr>
<ul>
<li>外观可能成为与程序中所有类都耦合的上帝对象  </li>
</ul>
<h3 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li><a href="# 外观">外观</a>为现有对象定义了一个新接口，<a href="# 适配器">适配器</a>则会试图运用已有的接口。适配器通常只封装一个对象，外观通常会作用于整个对象子系统上</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时，你可以使用抽<a href="# 抽象工厂">象工厂</a>来代替外观</li>
<li><a href="# 享元">享元</a>展示了如何生成大量的小型对象，<a href="# 外观">外观</a>则展示了如何用一个对象来代表整个子系统</li>
<li>外观和<a href="# 中介者">中介者</a>的职责类似：它们都尝试在大量紧密耦合的类中组织起合作<ul>
<li>外观为子系统中的所有对象定义了一个简单接口，但是它不提供任何新功能。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流</li>
<li>中介者将系统中组件的沟通行为中心化。各组件只知道中介者对象，无法直接相互交流</li>
</ul>
</li>
<li>外观类通常可以转换为单例类，因为在大部分情况下一个外观对象就足够了</li>
<li>外观与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同</li>
</ul>
<h2 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h2><blockquote>
<p>缓存、Cache、Flyweight</p>
</blockquote>
<p>享元是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中　　载入更多对象。</p>
<h3 id="问题背景-5"><a href="#问题背景-5" class="headerlink" title="问题背景"></a>问题背景</h3><p>需要开发一款简单的游戏：玩家们在地图上移动并相互射击。你决定实现一个真实的粒子系统，并将其作为游戏的特色。大量的子弹、导弹和爆炸弹片会在整个地图上穿行，为玩家提供紧张刺激的游戏体验。</p>
<p>开发完成后，你推送提交了最新版本的程序，并在编译游戏后将其发送给了一个朋友进行测试。尽管该游戏在你的电脑上完美运行，但是你的朋友却无法长时间进行游戏：游戏总是会在他的电脑上运行几分钟后崩溃。在研究了几个小时的调试消息记录后，你发现导致游戏崩溃的原因是内存容量不足。朋友的设备性能远比不上你的电脑，因此游戏运行在他的电脑上时很快就会出现问题。</p>
<p>真正的问题与粒子系统有关。每个粒子（一颗子弹、一枚导弹或一块弹片）都由包含完整数据的独立对象来表示。当玩家在游戏中鏖战进入高潮后的某一时刻，游戏将无法在剩余内存中载入新建粒子，于是程序就崩溃了。</p>
<p><img src="/posts/18127/image-20240408185701020.png" alt="image-20240408185701020"></p>
<h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>仔细观察粒子<code>Particle</code>类，你可能会注意到颜色（<code>color</code>）和贴图（<code>sprite</code>）这两个成员变量所消耗的内存要比其他变量多得多。更糟糕的是，对于所有的粒子来说，这两个成员变量所存储的数据几乎完全一样（比如所有子弹的颜色和贴图都一样）。</p>
<p><img src="/posts/18127/image-20240408185844014.png" alt="image-20240408185844014"></p>
<p>每个粒子的另一些状态（坐标、移动矢量和速度）则是不同的。因为这些成员变量的数值会不断变化。这些数据代表粒子在存续期间不断变化的情景，但每个粒子的颜色和贴图则会保持不变。  </p>
<p>每个粒子的另一些状态（坐标、移动矢量和速度）则是不同的。因为这些成员变量的数值会不断变化。这些数据代表粒子在存续期间不断变化的情景，但每个粒子的颜色和贴图则会保持不变。  </p>
<p>对象的常量数据通常被称为内在状态，其位于对象中，其他对象只能读取但不能修改其数值。而对象的其他状态常常能被其他对象“从外部”改变，因此被称为外在状态。  </p>
<p>享元模式建议不在对象中存储外在状态，而是将其传递给依赖于它的一个特殊方法。程序只在对象中保存内在状态，以方便在不同情景下重用。这些对象的区别仅在于其内在状态（与外在状态相比，内在状态的变体要少很多），因此你所需的对象数量会大大削减。  </p>
<p><img src="/posts/18127/image-20240408190141222.png" alt="image-20240408190141222"></p>
<p>假如能从粒子类中抽出外在状态，那么我们只需三个不同的对象（子弹、导弹和弹片）就能表示游戏中的所有粒子。你现在很可能已经猜到了，我们将这样一个仅存储内在状态的对象称为享元</p>
<h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240408190633588.png" alt="image-20240408190633588"></p>
<ol>
<li>享元模式只是一种优化。在应用该模式之前，你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题，并且确保该问题无法使用其他更好的方式来解决</li>
<li>享元（Flyweight）类包含原始对象中部分能在多个对象中共享的状态。同一享元对象可在许多不同情景中使用。享元中存储的状态被称为“内在状态”。传递给享元方法的状态被称为“外在状态” </li>
<li>情景（Context）类包含原始对象中各不相同的外在状态。情景与享元对象组合在一起就能表示原始对象的全部状态</li>
<li>通常情况下，原始对象的行为会保留在享元类中。因此调用享元方法必须提供部分外在状态作为参数。但你也可将行为移动到情景类中，然后将连入的享元作为单纯的数据对象</li>
<li>客户端（Client）负责计算或存储享元的外在状态。在客户端看来，享元是一种可在运行时进行配置的模板对象，具体的配置方式为向其方法中传入一些情景数据参数</li>
<li>享元工厂（Flyweight Factory）会对已有享元的缓存池进行管理。有了工厂后，客户端就无需直接创建享元，它们只需调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参数在之前已创建的享元中进行查找，如果找到满足条件的享元就将其返回；如果没有找到就根据参数新建享元</li>
</ol>
<h3 id="伪代码-5"><a href="#伪代码-5" class="headerlink" title="伪代码"></a>伪代码</h3><p>享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存</p>
<p><img src="/posts/18127/image-20240408190958009.png" alt="image-20240408190958009"></p>
<p>该模式从主要的 树 <code>Tree</code> 类中抽取内在状态，并将其移动到享元类 树种类 <code>TreeType</code> 之中</p>
<p>最初程序需要在多个对象中存储相同数据，而现在仅需在几个享元对象中保存数据，然后在作为情景的 树 对象中连入享元即可。客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为，并能在需要时复用对象  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象中，然后让众多的单个树对象去引用它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeType</span> is</span><br><span class="line">	field name</span><br><span class="line">	field color</span><br><span class="line">	field texture</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">TreeType</span><span class="params">(name, color, texture） 							&#123;...&#125;</span></span><br><span class="line"><span class="params">	method draw(canvas, x, y)</span> is</span><br><span class="line">		<span class="comment">//1.创建特定类型、颜色和纹理的位图。</span></span><br><span class="line">		<span class="comment">//2．在画布坐标（X,Y）处绘制位图。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">// 享元工厂决定是否复用已有享元或者创建一个新的对象。class TreeFactory is</span></span><br><span class="line">	<span class="keyword">static</span> field treeTypes: collection of tree types</span><br><span class="line">	<span class="keyword">static</span> method <span class="title function_">getTreeType</span><span class="params">(name, color, texture)</span> <span class="type">is</span></span><br><span class="line">		<span class="variable">type</span> <span class="operator">=</span> treeTypes.find(name, color, texture)</span><br><span class="line">		<span class="keyword">if</span> (type == <span class="literal">null</span>)</span><br><span class="line">			type = <span class="keyword">new</span> <span class="title class_">TreeType</span>(name, color, texture)</span><br><span class="line">			treeTypes.add(type)</span><br><span class="line">		<span class="keyword">return</span> type</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们体积很小：仅有两个整型坐标和一个引用成员变量。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> is </span><br><span class="line">	field x,y</span><br><span class="line">	field type: TreeType</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">Tree</span><span class="params">(x, y， type)</span>&#123;...&#125;</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">draw</span><span class="params">(canvas)</span> is</span><br><span class="line">		type.draw(canvas, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树（Tree）和森林（Forest）类是享元的客户端。如果不打算继续对树类进行开发，你可以将它们合并。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Forest</span> is</span><br><span class="line">	field trees: collection of Trees</span><br><span class="line">	</span><br><span class="line">	method <span class="title function_">plantTree</span><span class="params">(x,y,name,color,texture)</span><span class="type">is</span></span><br><span class="line">		<span class="variable">type</span> <span class="operator">=</span> TreeFactory.getTreeType(name, color, texture)</span><br><span class="line">		tree = <span class="keyword">new</span> <span class="title class_">Tree</span>(x, y, type)</span><br><span class="line">		trees.add(tree)</span><br><span class="line">		</span><br><span class="line">  method <span class="title function_">draw</span><span class="params">(canvas)</span> is</span><br><span class="line">  	<span class="title function_">foreach</span> <span class="params">(tree in trees)</span> </span><br><span class="line">  		dotree.draw(canvas)</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式</li>
<li>应用该模式所获的收益大小取决于使用它的方式和情景。它在下列情况中最有效 :<ul>
<li>程序需要生成数量巨大的相似对象</li>
<li>这将耗尽目标设备的所有内存</li>
<li>对象中包含可抽取且能在多个对象间共享的重复状态。</li>
</ul>
</li>
</ul>
<h3 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>将需要改写为享元的类成员变量拆分为两个部分:<ul>
<li>内在状态：包含不变的、可在许多对象中重复使用的数据的成员变量。</li>
<li>外在状态：包含每个对象各自不同的情景数据的成员变量</li>
</ul>
</li>
<li>保留类中表示内在状态的成员变量，并将其属性设置为不可修改。这些变量仅可在构造函数中获得初始数值。</li>
<li>找到所有使用外在状态成员变量的方法，为在方法中所用的每个成员变量新建一个参数，并使用该参数代替成员变量。</li>
<li>你可以有选择地创建工厂类来管理享元缓存池，它负责在新建享元时检查已有的享元。如果选择使用工厂，客户端就只能通过工厂来请求享元，它们需要将享元的内在状态作为参数传递给工厂。</li>
<li>客户端必须存储和计算外在状态（情景）的数值，因为只有这样才能调用享元对象的方法。为了使用方便，外在状态和引用享元的成员变量可以移动到单独的情景类中</li>
</ol>
<h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>如果程序中有很多相似对象，那么你将可以节省大量内存</li>
</ul>
<hr>
<ul>
<li>你可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分情景数据</li>
<li>代码会变得更加复杂。团队中的新成员总是会问：“为什么要像这样拆分一个实体的状态？”  </li>
</ul>
<h3 id="与其他模式的关系-5"><a href="#与其他模式的关系-5" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>你可以使用享元实现组合树的共享叶节点以节省内存  </li>
<li>享元展示了如何生成大量的小型对象，外观则展示了如何用一个对象来代表整个子系统</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象，那么享元就和单例类似了。但这两个模式有两个根本性的不同<ul>
<li>只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同</li>
<li>单例对象可以是可变的。享元对象是不可变的  </li>
</ul>
</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><blockquote>
<p>Proxy</p>
</blockquote>
<p>代理是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p>
<h3 id="问题背景-6"><a href="#问题背景-6" class="headerlink" title="问题背景"></a>问题背景</h3><p>有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它，并非总是需要</p>
<p><img src="/posts/18127/image-20240409184246134.png" alt="image-20240409184246134"></p>
<p>你可以实现延迟初始化：在实际有需要时再创建该对象。对象的所有客户端都要执行延迟初始代码。不幸的是，这很可能会带来很多重复代码。</p>
<p>在理想情况下，我们希望将代码直接放入对象的类中，但这并非总是能实现：比如类可能是第三方封闭库的一部分  </p>
<h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><p>代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端。代理类接收到客户端请求后会创建实际的服务对象，并将所有工作委派给它</p>
<p><img src="/posts/18127/image-20240409184550672.png" alt="image-20240409184550672"></p>
<p>代理将自己伪装成数据库对象，可在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作</p>
<p>如果需要在类的主要业务逻辑前后执行一些工作，你无需修改类就能完成这项工作。由于代理实现的接口与原类相同，因此你可将其传递给任何一个使用实际服务对象的客户端</p>
<h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><p><img src="/posts/18127/image-20240409184932147.png" alt="image-20240409184932147"></p>
<ol>
<li>服务接口（<code>Service Interface</code>）声明了服务接口。代理必须遵循该接口才能伪装成服务对象</li>
<li>服务（<code>Service</code>）类提供了一些实用的业务逻辑</li>
<li>代理（<code>Proxy</code>）类包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象。通常情况下，代理会对其服务对象的整个生命周期进行管理</li>
<li>客户端（<code>Client</code>） 能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理</li>
</ol>
<h3 id="伪代码-6"><a href="#伪代码-6" class="headerlink" title="伪代码"></a>伪代码</h3><p>使用代理模式在第三方腾讯视频（<code>TencentVideo</code>，代码示例中记为TV）程序库中添加延迟初始化和缓存。<br><img src="/posts/18127/image-20240409185609538.png" alt="image-20240409185609538" style="zoom:80%;"></p>
<p>程序库提供了视频下载类。但是该类的效率非常低。如果客户端程序多次请求同一视频，程序库会反复下载该视频，而不会将首次下载的文件缓存下来复用。</p>
<p>代理类实现和原下载器相同的接口，并将所有工作委派给原下载器。不过，代理类会保存所有的文件下载记录，如果程序多次请求同一文件，它会返回缓存的文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">field needReset</span><br><span class="line"><span class="comment">// 远程服务接口。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThirdPartyTVLib</span> is</span><br><span class="line">	method <span class="title function_">listVideos</span><span class="params">()</span></span><br><span class="line">	method <span class="title function_">getVideoInfo</span><span class="params">(id)</span></span><br><span class="line">	method <span class="title function_">downloadvideo</span><span class="params">(id)</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息一模一样，程序的速度依然会减慢。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdPartyTvclass</span> <span class="keyword">implements</span> <span class="title class_">ThirdPartyTVLib</span> is</span><br><span class="line">	method <span class="title function_">listVideos</span><span class="params">()</span> is</span><br><span class="line">		<span class="comment">//向腾讯视频发送一个API请求。</span></span><br><span class="line">  method <span class="title function_">getVideoInfo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="comment">//获取某个视频的元数据。</span></span><br><span class="line">  method <span class="title function_">downloadVideo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="comment">//从腾讯视频下载一个视频文件。</span></span><br><span class="line">  	</span><br><span class="line"><span class="comment">//为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签名是final（最终）。因此我们会在一个实现了服务类接口的新代理类中放入缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CachedTVClass</span> <span class="keyword">implements</span> <span class="title class_">ThirdPartyTVLib</span> is</span><br><span class="line">	<span class="keyword">private</span> field service: ThirdPartyTVLib</span><br><span class="line">	<span class="keyword">private</span> field listcache, videoCache</span><br><span class="line">	field needReset</span><br><span class="line">	</span><br><span class="line">	constructor <span class="title function_">CachedTVClass</span><span class="params">(service: ThirdPartyTVLib)</span> is</span><br><span class="line">		<span class="built_in">this</span>.service = service</span><br><span class="line">  </span><br><span class="line">  method <span class="title function_">listVideos</span><span class="params">()</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(listCache == <span class="literal">null</span> || needReset)</span></span><br><span class="line">  		listCache = service.listVideos()</span><br><span class="line">  	<span class="keyword">return</span> listCache</span><br><span class="line">  	</span><br><span class="line">  method <span class="title function_">getVideoInfo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(videoCache == <span class="literal">null</span> || needReset)</span></span><br><span class="line">  		videoCache = service.getVideoInfo(id)</span><br><span class="line">    <span class="keyword">return</span> videoCache</span><br><span class="line">    </span><br><span class="line">  method <span class="title function_">downloadVideo</span><span class="params">(id)</span> is</span><br><span class="line">  	<span class="title function_">if</span> <span class="params">(!downloadExists(id)</span> || needReset)</span><br><span class="line">  		service.downloadVideo(id)</span><br><span class="line">  		</span><br><span class="line"><span class="comment">// 之前直接与服务对象交互的GUI类不需要改变，前提是它仅通过接口与服务对象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实现了相同的接口。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TVManager</span> is</span><br><span class="line">  	<span class="keyword">protected</span> field service: ThirdPartyTVLib</span><br><span class="line">     </span><br><span class="line">    constructor <span class="title function_">TVManager</span><span class="params">(service: ThirdPartyTVLib)</span> is</span><br><span class="line">    	<span class="built_in">this</span>.service = service</span><br><span class="line">      </span><br><span class="line">    method <span class="title function_">renderVideoPage</span><span class="params">(id)</span> <span class="type">is</span></span><br><span class="line">      <span class="variable">info</span> <span class="operator">=</span> service.getVideoInfo(id)</span><br><span class="line">      <span class="comment">// 渲染视频页面</span></span><br><span class="line">    </span><br><span class="line">    method <span class="title function_">renderListPanel</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">      <span class="variable">list</span> <span class="operator">=</span> service.listVideos()</span><br><span class="line">      <span class="comment">//渲染视频缩略图列表。</span></span><br><span class="line">      </span><br><span class="line">    method <span class="title function_">reactOnUserInput</span><span class="params">()</span> is</span><br><span class="line">      <span class="title function_">renderVideoPage</span><span class="params">()</span></span><br><span class="line">      renderListPanel()</span><br><span class="line">      </span><br><span class="line"><span class="comment">//程序可在运行时对代理进行配置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">  method <span class="title function_">init</span><span class="params">()</span> <span class="type">is</span></span><br><span class="line">  	<span class="variable">aTVService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyTVClass</span>()</span><br><span class="line">  	aTVProxy = <span class="keyword">new</span> <span class="title class_">CachedTVClass</span>(aTVService)</span><br><span class="line">  	manager = <span class="keyword">new</span> <span class="title class_">TVManager</span>(aTVProxy)</span><br><span class="line">    manager.reactOnUserInput()</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象，可将对象的初始化延迟到真正有需要的时候</p>
</li>
<li><p>访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可使用代理模式</p>
<p>代理可仅在客户端凭据满足要求时将请求传递给服务对象</p>
</li>
<li><p>本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形</p>
<p>在这种情形中，代理通过网络传递客户端请求，负责处理所有与网络相关的复杂细节</p>
</li>
<li><p>记录日志请求（日志记录代理）。适用于当你需要保存对于服务对象的请求历史记录时。代理可以在向服务传递请求前进行记录</p>
<p>缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时</p>
<p>代理可对重复请求所需的相同结果进行缓存，还可使用请求参数作为索引缓存的键值</p>
</li>
<li><p>智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象</p>
<p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。代理会时不时地遍历各个客户端，检查它们是否仍在运行。如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源</p>
<p>代理还可以记录客户端是否修改了服务对象。其他客户端还可以复用未修改的对象</p>
</li>
</ul>
<h3 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li>如果没有现成的服务接口，你就需要创建一个接口来实现代理和服务对象的可交换性。从服务类中抽取接口并非总是可行的，因为你需要对服务的所有客户端进行修改，让它们使用接口。备选计划是将代理作为服务类的子类，这样代理就能继承服务的所有接口了。</li>
<li>创建代理类，其中必须包含一个存储指向服务的引用的成员变量。通常情况下，代理负责创建服务并对其整个生命周期进行管理。在一些特殊情况下，客户端会通过构造函数将服务传递给代理。</li>
<li>根据需求实现代理方法。在大部分情况下，代理在完成一些任务后应将工作委派给服务对象。</li>
<li>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法，也可以创建一个完整的工厂方法。 </li>
<li>可以考虑为服务对象实现延迟初始化。</li>
</ol>
<h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>你可以在客户端毫无察觉的情况下控制服务对象</li>
<li>如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理</li>
<li>即使服务对象还未准备好或不存在，代理也可以正常工作</li>
<li>开闭原则。你可以在不对服务或客户端做出修改的情况下创建新代理  </li>
</ul>
<hr>
<ul>
<li>代码可能会变得复杂，因为需要新建许多类</li>
<li>服务响应可能会延迟</li>
</ul>
<h3 id="与其他模式的关系-6"><a href="#与其他模式的关系-6" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>适配器能为被封装对象提供不同的接口，代理能为对象提供相同的接口，装饰则能为对象提供加强的接口。</li>
<li>外观与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同。</li>
<li>装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-面向对象程序设计</title>
    <url>/posts/22370.html</url>
    <content><![CDATA[<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><p>面向对象程序设计（Object-Oriented Programming， OOP）是一种范式，其基本理念是将数据块及与数据相关的行为封装成为特殊的、名为对象的实体，同时对象实体的生成工作则是基于程序员给出的一系列“蓝图”，这些“蓝图”就是类。  </p>
<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p><img src="/posts/22370/image-20240220160635635.png" alt="image-20240220160635635"></p>
<p>每只猫<code>Cat</code>都有许多基本属性：名字、年龄、体重、毛色等，这些就叫类的<strong>成员变量</strong>；所有猫都有相似的行为：呼吸、吃饭、跑步等，这些就叫<strong>类的方法</strong>。上述变量和方法都可以统称为类的成员，存储在对象成员变量中的数据通常也可称为状态，而类的所有方法则定义了其行为。</p>
<p>一只具体的猫（共享猫这个类的属性，但是区别在于属性值可能不同），就是猫这个类的一个实例。因此，类就像是定义对象结构的蓝图，而对象则是类的具体体现。</p>
<h2 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h2><p>程序通常包括多个类，这些类就会组织形成类层次结构。</p>
<p>比如，现在除了猫还有狗，而狗和猫共享很多属性，比如名字、年龄、体重等，而且也有很多行为是一样的，包括呼吸、吃饭和睡觉。因此，我们可以定义一个动物类<code>Animal</code>来列出狗和猫的共同属性和行为，这里的动物其实就是<strong>父类</strong>或者叫<strong>超类</strong>，而狗和猫就是其<strong>子类</strong>，子类会继承父类的状态和行为，因此只需要定义不同于父类的属性和方法，比如猫的喵喵叫和狗的汪汪叫。此外，子类也可以对从父类继承来的行为进行重写，包括完全替换或者进行加强。</p>
<p><img src="/posts/22370/image-20240220161538620.png" alt="image-20240220161538620"></p>
<p>随着业务拓展，有可能需要进一步抽象出新的父类，比如动物、植物的父类是生物</p>
<p><img src="/posts/22370/image-20240220161652580.png" alt="image-20240220161652580"></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>面向对象程序设计包括抽象、封装、继承、多态四个特性</p>
<ul>
<li><p><strong>抽象</strong>：抽象是一种反映真实世界对象或现象中特定内容的模型，它能高精度地反映所有与特定内容相关的详细信息，同时忽略其他内容。当使用面向对象程序设计的理念开发一款程序时，你会将大部分时间用于根据真实世界对象来设计程序中的对象。但是，程序中的对象并不需要能够百分之百准确地反映其原型（极少情况下才需要做到这一点）。实际上，你的对象只需模拟真实对象的特定属性和行为即可，其他内容可以忽略。  </p>
<p>  飞行模拟器和航班预订程序中都可能会包含一个飞机 <code>Airplane</code> 类。但是前者需包含与实际飞行相关的详细信息，而后者则只关心座位图和哪些座位可供预订。  </p>
<p>  <img src="/posts/22370/image-20240220162014748.png" alt="image-20240220162014748"></p>
</li>
<li><p><strong>封装</strong>：指一个对象对其他对象隐藏其部分状态和行为，而仅向程序其他部分暴露有限的接口的能力。</p>
<p>  如果想要启动一辆车的发动机，你只需转动钥匙或按下按钮即可，无需打开引擎盖手动接线、转动曲轴和气缸并启动发动机的动力循环。这些细节都隐藏在引擎盖下，你只会看到一些简单的接口：启动开关、方向盘和一些踏板。  </p>
<p>  这里的接口表示的是类的公共属性和方法，但是Java等编程语言中又有接口<code>interface</code>这一类型，所以需要进行区分</p>
<p>  <img src="/posts/22370/image-20240220162841400.png" alt="image-20240220162841400"></p>
<p>  假 如 你 的 航空运输 <code>FlyingTransport</code> 接 口 中 有 一 个<code>fly(origin, destination, passengers)</code> 方法 （即以起点、 终点以及乘客为参数的飞行方法）。 在设计航空运输模拟器时， 你可以对 机场 <code>Airport</code> 类做出限制， 使其仅与<strong>实现</strong>了 <strong>航空运输接口</strong>的对象进行交互。 此后， 你可以确保传递给机场对象的任何对象——无论是飞机 <code>Airplane</code>、 直升机<code>Helicopter</code> 还是可怕的 家养狮鹫 <code>DomesticatedGryphon</code>都能到达或离开这种类型的机场。</p>
</li>
<li><p><strong>继承</strong>：根据已有类创建新类的能力，主要目的就是代码复用。如果你想要创建的类与已有的类差异不大，那也没必要重复编写相同的代码。你只需扩展已有的类并将额外功能放入生成的子类（它会继承父类的成员变量和方法）中即可。  </p>
<p>  <img src="/posts/22370/image-20240220163409462.png" alt="image-20240220163409462"></p>
</li>
<li><p><strong>多态</strong>  ：程序能够检测对象所属的实际类，并在当前上下文不知道其真实类型的情况下调用其实现的能力。  </p>
<p>  <img src="/posts/22370/image-20240220163356708.png" alt="image-20240220163356708"></p>
<p>  因为几乎所有动物都会发出声音，因此所有子类都需要重写该方法，故可以将该方法定义为抽象方法，这样就可以忽略父类中该方法的所有实现，而强制要求子类必须实现该方法。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bag = [<span class="keyword">new</span> <span class="title class_">Cat</span>(), <span class="keyword">new</span> <span class="title class_">Dog</span>()];</span><br><span class="line"></span><br><span class="line">foreach (Animal a : bag)</span><br><span class="line">	a.makeSound()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 喵喵！</span></span><br><span class="line"><span class="comment">// 汪汪</span></span><br></pre></td></tr></table></figure>
<p>  我们往包里放猫和狗，但是取出来时闭上了眼，并不知道取出来的是啥，多态机制就是让程序可以追踪到对象的子类并调用其方法，从而执行恰当的行为（猫叫还是狗叫）</p>
</li>
</ul>
<h2 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h2><p>前文已经介绍了继承和实现两者关系，此外还有依赖、关联、聚合、组合等关系</p>
<ul>
<li><p><strong>依赖</strong>：类之间最基础的、也是最微弱的关系类型。如果修改一个类的定义可能会造成另一个类的变化，那么这两个类之间就存在依赖关系。当你在代码中使用具体类的名称时，通常意味着存在依赖关系。例如在指定方法签名类型时，或是通过调用构造函数对对象进行初始化时等。通过让代码依赖接口或抽象类（而不是具体类），你可以降低其依赖程度。  </p>
<p>  <img src="/posts/22370/image-20240220164241424.png" alt="image-20240220164241424"></p>
</li>
<li><p><strong>关联</strong>：一个对象使用另一对象或与另一对象进行交互的关系。关联可视为一种特殊类型的依赖，即一个对象总是拥有访问与其交互的对象的权限，而简单的依赖关系并不会在对象间建立永久性的联系。类似于类成员变量的关系，但是并不仅仅通过类成员变量来实现。比如通过订单获取对应顾客，既可以通过订单类包含顾客成员变量实现，也可以通过定义一个能够返回顾客的方法来实现。</p>
<p>  <img src="/posts/22370/image-20240220164304152.png" alt="image-20240220164304152"></p>
<blockquote>
<p><strong>依赖 vs 关联</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Professor</span> is</span><br><span class="line">	field Student student</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	method <span class="title function_">teach</span><span class="params">(Course c)</span> is</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="built_in">this</span>.student.remember(c.getKnowledge())</span><br></pre></td></tr></table></figure>
<p>教授知识<code>teach</code>方法中接收课程<code>Course</code>参数，同时调用了课程的<code>getKnowledge</code>方法，如果修改了该方法，比如修改方法名或者添加形参，那么<code>teach</code>方法就会失败，这就是依赖</p>
<p>学生<code>student</code>作为其成员变量，肯定是依赖，因为<code>remember</code>方法如果被修改，教授<code>Professor</code>也会失败。进一步，由于教授所有方法都能访问<code>student</code>成员变量，所以也是关联关系</p>
</blockquote>
</li>
<li><p><strong>聚合</strong>：一种特殊类型的关联，用于表示多个对象之间的“一对多”、“多对多”或“整体对部分”的关系。通常在聚合关系中，一个对象“拥有”一组其他对象，并扮演着容器或集合的角色。组件可以独立于容器存在，也可以同时连接多个容器。  </p>
<p>  <img src="/posts/22370/image-20240220165109520.png" alt="image-20240220165109520"></p>
</li>
<li><p><strong>组合</strong>：一种特殊类型的聚合，其中一个对象由一个或多个其他对象实例构成。组合与其他关系的区别在于组件仅能作为容器的一部分存在。</p>
<p>  <img src="/posts/22370/image-20240220165229900.png" alt="image-20240220165229900"></p>
<p>  院系只有在大学里才有意义。</p>
</li>
</ul>
<p><strong>具体示例</strong></p>
<p><img src="/posts/22370/image-20240220165431087.png" alt="image-20240220165431087"></p>
<ul>
<li>依赖：对类 B 进行修改会影响到类 A </li>
<li>关联：对象 A 知道对象 B。类 A 依赖于类 B</li>
<li>聚合：对象 A 知道对象 B 且由 B 构成。类 A 依赖于类 B。</li>
<li>组合：对象 A 知道对象 B、由 B 构成而且管理着 B 的生命周期。类 A 依赖于类 B。</li>
<li>实现：类 A 定义的方法由接口 B 声明。对象 A 可被视为对象B。类 A 依赖于类 B。  </li>
<li>继承：类 A 继承类 B 的接口和实现， 但是可以对其进行扩展。对象 A 可被视为对象 B。类 A 依赖于类 B。  </li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发进阶知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven-安装与配置</title>
    <url>/posts/64597.html</url>
    <content><![CDATA[<h2 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h2><h3 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h3><ol>
<li><p>首先要保证java环境已经正确配置</p>
<p><img src="/posts/64597/image-20240520191013229.png" alt="image-20240520191013229"></p>
</li>
<li><p>下载Maven安装包并进行解压：一般下载编译版本</p>
<p><img src="/posts/64597/image-20240520191140472.png" alt="image-20240520191140472" style="zoom: 50%;"></p>
<p><img src="/posts/64597/image-20240520191202559.png" alt="image-20240520191202559" style="zoom:50%;"></p>
<p><img src="/posts/64597/image-20240520191547061.png" alt="image-20240520191547061"></p>
</li>
<li><p>修改配置</p>
<ol>
<li><p>修改conf/settings.xml文件内的默认配置</p>
<ol>
<li><p>修改本地仓库，默认仓库${user.home}/.m2/repository</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;!--本地仓库配置：存储那些jar包用的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:\repmvn<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改镜像地址，远程下载jar包的地址，默认是Maven的官方地址（国内比较难访问）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror0f</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirror0f</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>huaweicloud<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror0f</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirror0f</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.huaweicloud.com/repository/maven/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置多项地址的意义在于Maven会自上向下找存储该jar包的远程仓库，一直找不到则会报错</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>配置环境变量</p>
<ol>
<li><p>MAVEN_HOME</p>
<p><img src="/posts/64597/image-20240520192720080.png" alt="image-20240520192720080"></p>
</li>
<li><p>Path</p>
<p><img src="/posts/64597/image-20240520192736155.png" alt="image-20240520192736155"></p>
</li>
<li><p>验证系统变量</p>
<p><img src="/posts/64597/image-20240520193219098.png" alt="image-20240520193219098"></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven-工程构建</title>
    <url>/posts/29056.html</url>
    <content><![CDATA[<h3 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h3><p><img src="/posts/29056/image-20240521184159434.png" alt="image-20240521184159434" style="zoom:50%;"></p>
<h3 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h3><ol>
<li><p>命令行创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate </span><br></pre></td></tr></table></figure>
<p>输入一个groupId（暂时理解为包名）<br>输入一个artifactId：项目名<br>输入一个package：默认就是groupId</p>
<p><img src="/posts/29056/image-20240521185139911.png" alt="image-20240521185139911"></p>
<p>能够规定项目结构的Maven项目</p>
<p><img src="/posts/29056/image-20240521185326403.png" alt="image-20240521185326403"></p>
</li>
<li><p>IDEA创建</p>
<p><img src="/posts/29056/image-20240521185701037.png" alt="image-20240521185701037" style="zoom: 50%;"></p>
<p><img src="/posts/29056/image-20240521185713909.png" alt="image-20240521185713909" style="zoom:50%;"></p>
</li>
</ol>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>Maven为我们创建了一个脚手架，可以简单理解为房子的地基，是一种约定的目录结构，这样才能保证构建过程能够自动化完成</p>
<p>例如，Maven执行编译操作，必须先去Java源程序目录读取Java源代码，然后执行编译，最后把编译结果存放在target目录</p>
<p><img src="/posts/29056/image-20240521192853071.png" alt="image-20240521192853071"></p>
<ul>
<li>pom.xml能够标志该项目是一个Maven项目，其实是一个配置文件，主要就是学习如何编辑这个文件的内容</li>
<li>main存放项目源文件及资源文件，java存放java类，resources存放除.java文件外的文件（配置文件、静态资源文件、模板页面），通常放的比较多的.xml配置文件、.properties属性文件、.yml配置文件、.html、.css、.jpg等</li>
<li>com.xzp是通过groupId生成的包</li>
<li>test存放项目单元测试文件Junit（@Test），如果需要引入测试才会用到的配置，就可以在这里加一个resources文件夹</li>
<li>还有一个target目录存放构建操作输出的结果</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven-简介</title>
    <url>/posts/48828.html</url>
    <content><![CDATA[<h2 id="Maven-简介"><a href="#Maven-简介" class="headerlink" title="Maven-简介"></a>Maven-简介</h2><p>Maven是一个Java项目管理和构建工具，它可以定义<strong>项目结构</strong>、<strong>项目依赖</strong>，并使用统一的方式进行<strong>自动化构建</strong>，是Java项目不可缺少的工具。</p>
<blockquote>
<p>为什么要学习Maven？</p>
</blockquote>
<ol>
<li><p><strong>项目管理</strong></p>
<ul>
<li><strong>问题</strong>：不同的开发工具所创建的项目结构不一样</li>
<li><strong>解决</strong>：Maven提供了一套标准化的项目结构，不同职能的代码应该放在哪个位置，降低上手难度，约定大于以来</li>
</ul>
</li>
<li><p><strong>项目构建</strong></p>
<ul>
<li><strong>问题</strong>：部署项目的流程包括编译→测试→打包（war包）→部署，较为复杂</li>
<li><strong>解决</strong>：maven提供了一套标准化的构建流程，只需要程序员配置好相关参数（比如Tomcat服务器地址），就可以一键部署（清理、编译、测试、报告、打包、部署）</li>
</ul>
</li>
<li><p><strong>项目依赖</strong></p>
<ul>
<li><p>提供一套依赖管理工具，管理项目所有的jar包</p>
<ol>
<li><p>传统项目通常都将jar包置于lib文件夹内，与项目绑定在一起，存在以下缺陷</p>
<p>问题：不同项目使用同一份依赖，重复存储</p>
<p>解决：maven引入了一个仓库的概念，存放所有jar，可以共享给所有项目</p>
<hr>
<p>问题：不同项目成员都需要拷贝一份依赖，存在无效的空间浪费和传输开销</p>
<p>解决：传输项目时无需传输jar包，而是相当于传输jar包名称，对方只需要根据jar包名称在自己的仓库找到就行了（本地没有，可以远程自动下载）</p>
</li>
<li><p>缓解jar包之间的版本冲突问题</p>
<p>问题：传统项目是通过升降版本解决这个问题</p>
<p>解决：maven会在我们引入某个jar包时，基于依赖传递特性自动引入与该jar存在依赖关系且兼容的其他jar包</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>开发基础知识</tag>
      </tags>
  </entry>
</search>
